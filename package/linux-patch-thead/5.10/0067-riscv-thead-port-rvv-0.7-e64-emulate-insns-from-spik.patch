From cc2076323978159ad69a4a3ed2b8e208bba4f7ff Mon Sep 17 00:00:00 2001
From: liweiwei <liweiwei@iscas.ac.cn>
Date: Fri, 19 Mar 2021 16:55:41 +0800
Subject: [PATCH 67/72] riscv: thead: port rvv 0.7 e64 emulate insns from spike

---
 arch/riscv/kernel/soft_vector/Makefile        |    9 +
 .../arch_riscv_kernel_soft_vector_generate    |  485 +++++
 arch/riscv/kernel/soft_vector/arith.h         |   75 +
 arch/riscv/kernel/soft_vector/decode.c        |  601 +++++
 arch/riscv/kernel/soft_vector/encoding.h      | 1451 +++++++++++++
 arch/riscv/kernel/soft_vector/insn_list.h     |  361 +++
 arch/riscv/kernel/soft_vector/insn_template.c |   49 +
 arch/riscv/kernel/soft_vector/insn_template.h |   34 +
 arch/riscv/kernel/soft_vector/insns/Makefile  |  365 ++++
 .../riscv/kernel/soft_vector/insns/vaadd_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vaadd_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vaadd_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vadc_vim.c |   49 +
 .../riscv/kernel/soft_vector/insns/vadc_vvm.c |   49 +
 .../riscv/kernel/soft_vector/insns/vadc_vxm.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vadd_vi.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vadd_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vadd_vx.c |   49 +
 .../kernel/soft_vector/insns/vamoaddd_v.c     |   49 +
 .../kernel/soft_vector/insns/vamoaddw_v.c     |   49 +
 .../kernel/soft_vector/insns/vamoandd_v.c     |   49 +
 .../kernel/soft_vector/insns/vamoandw_v.c     |   49 +
 .../kernel/soft_vector/insns/vamomaxd_v.c     |   49 +
 .../kernel/soft_vector/insns/vamomaxud_v.c    |   49 +
 .../kernel/soft_vector/insns/vamomaxuw_v.c    |   49 +
 .../kernel/soft_vector/insns/vamomaxw_v.c     |   49 +
 .../kernel/soft_vector/insns/vamomind_v.c     |   49 +
 .../kernel/soft_vector/insns/vamominud_v.c    |   49 +
 .../kernel/soft_vector/insns/vamominuw_v.c    |   49 +
 .../kernel/soft_vector/insns/vamominw_v.c     |   49 +
 .../kernel/soft_vector/insns/vamoord_v.c      |   49 +
 .../kernel/soft_vector/insns/vamoorw_v.c      |   49 +
 .../kernel/soft_vector/insns/vamoswapd_v.c    |   49 +
 .../kernel/soft_vector/insns/vamoswapw_v.c    |   49 +
 .../kernel/soft_vector/insns/vamoxord_v.c     |   49 +
 .../kernel/soft_vector/insns/vamoxorw_v.c     |   49 +
 arch/riscv/kernel/soft_vector/insns/vand_vi.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vand_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vand_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vasub_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vasub_vx.c |   49 +
 .../kernel/soft_vector/insns/vcompress_vm.c   |   49 +
 arch/riscv/kernel/soft_vector/insns/vdiv_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vdiv_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vdivu_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vdivu_vx.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vdot_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vdotu_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vext_x_v.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfadd_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfadd_vv.c |   49 +
 .../kernel/soft_vector/insns/vfclass_v.c      |   49 +
 .../kernel/soft_vector/insns/vfcvt_f_x_v.c    |   49 +
 .../kernel/soft_vector/insns/vfcvt_f_xu_v.c   |   49 +
 .../kernel/soft_vector/insns/vfcvt_x_f_v.c    |   49 +
 .../kernel/soft_vector/insns/vfcvt_xu_f_v.c   |   49 +
 .../riscv/kernel/soft_vector/insns/vfdiv_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfdiv_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfdot_vv.c |   49 +
 .../kernel/soft_vector/insns/vfmacc_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfmacc_vv.c      |   49 +
 .../kernel/soft_vector/insns/vfmadd_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfmadd_vv.c      |   49 +
 .../riscv/kernel/soft_vector/insns/vfmax_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfmax_vv.c |   49 +
 .../kernel/soft_vector/insns/vfmerge_vfm.c    |   49 +
 .../riscv/kernel/soft_vector/insns/vfmin_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfmin_vv.c |   49 +
 .../kernel/soft_vector/insns/vfmsac_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfmsac_vv.c      |   49 +
 .../kernel/soft_vector/insns/vfmsub_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfmsub_vv.c      |   49 +
 .../riscv/kernel/soft_vector/insns/vfmul_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfmul_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfmv_f_s.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfmv_s_f.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfmv_v_f.c |   49 +
 .../kernel/soft_vector/insns/vfncvt_f_f_v.c   |   49 +
 .../kernel/soft_vector/insns/vfncvt_f_x_v.c   |   49 +
 .../kernel/soft_vector/insns/vfncvt_f_xu_v.c  |   49 +
 .../kernel/soft_vector/insns/vfncvt_x_f_v.c   |   49 +
 .../kernel/soft_vector/insns/vfncvt_xu_f_v.c  |   49 +
 .../kernel/soft_vector/insns/vfnmacc_vf.c     |   49 +
 .../kernel/soft_vector/insns/vfnmacc_vv.c     |   49 +
 .../kernel/soft_vector/insns/vfnmadd_vf.c     |   49 +
 .../kernel/soft_vector/insns/vfnmadd_vv.c     |   49 +
 .../kernel/soft_vector/insns/vfnmsac_vf.c     |   49 +
 .../kernel/soft_vector/insns/vfnmsac_vv.c     |   49 +
 .../kernel/soft_vector/insns/vfnmsub_vf.c     |   49 +
 .../kernel/soft_vector/insns/vfnmsub_vv.c     |   49 +
 .../kernel/soft_vector/insns/vfrdiv_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfredmax_vs.c    |   49 +
 .../kernel/soft_vector/insns/vfredmin_vs.c    |   49 +
 .../kernel/soft_vector/insns/vfredosum_vs.c   |   49 +
 .../kernel/soft_vector/insns/vfredsum_vs.c    |   49 +
 .../kernel/soft_vector/insns/vfrsub_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfsgnj_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfsgnj_vv.c      |   49 +
 .../kernel/soft_vector/insns/vfsgnjn_vf.c     |   49 +
 .../kernel/soft_vector/insns/vfsgnjn_vv.c     |   49 +
 .../kernel/soft_vector/insns/vfsgnjx_vf.c     |   49 +
 .../kernel/soft_vector/insns/vfsgnjx_vv.c     |   49 +
 .../riscv/kernel/soft_vector/insns/vfsqrt_v.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfsub_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vfsub_vv.c |   49 +
 .../kernel/soft_vector/insns/vfwadd_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfwadd_vv.c      |   49 +
 .../kernel/soft_vector/insns/vfwadd_wf.c      |   49 +
 .../kernel/soft_vector/insns/vfwadd_wv.c      |   49 +
 .../kernel/soft_vector/insns/vfwcvt_f_f_v.c   |   49 +
 .../kernel/soft_vector/insns/vfwcvt_f_x_v.c   |   49 +
 .../kernel/soft_vector/insns/vfwcvt_f_xu_v.c  |   49 +
 .../kernel/soft_vector/insns/vfwcvt_x_f_v.c   |   49 +
 .../kernel/soft_vector/insns/vfwcvt_xu_f_v.c  |   49 +
 .../kernel/soft_vector/insns/vfwmacc_vf.c     |   49 +
 .../kernel/soft_vector/insns/vfwmacc_vv.c     |   49 +
 .../kernel/soft_vector/insns/vfwmsac_vf.c     |   49 +
 .../kernel/soft_vector/insns/vfwmsac_vv.c     |   49 +
 .../kernel/soft_vector/insns/vfwmul_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfwmul_vv.c      |   49 +
 .../kernel/soft_vector/insns/vfwnmacc_vf.c    |   49 +
 .../kernel/soft_vector/insns/vfwnmacc_vv.c    |   49 +
 .../kernel/soft_vector/insns/vfwnmsac_vf.c    |   49 +
 .../kernel/soft_vector/insns/vfwnmsac_vv.c    |   49 +
 .../kernel/soft_vector/insns/vfwredosum_vs.c  |   49 +
 .../kernel/soft_vector/insns/vfwredsum_vs.c   |   49 +
 .../kernel/soft_vector/insns/vfwsub_vf.c      |   49 +
 .../kernel/soft_vector/insns/vfwsub_vv.c      |   49 +
 .../kernel/soft_vector/insns/vfwsub_wf.c      |   49 +
 .../kernel/soft_vector/insns/vfwsub_wv.c      |   49 +
 arch/riscv/kernel/soft_vector/insns/vid_v.c   |   49 +
 arch/riscv/kernel/soft_vector/insns/viota_m.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlb_v.c   |   49 +
 arch/riscv/kernel/soft_vector/insns/vlbff_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlbu_v.c  |   49 +
 .../riscv/kernel/soft_vector/insns/vlbuff_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vle_v.c   |   49 +
 arch/riscv/kernel/soft_vector/insns/vleff_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlh_v.c   |   49 +
 arch/riscv/kernel/soft_vector/insns/vlhff_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlhu_v.c  |   49 +
 .../riscv/kernel/soft_vector/insns/vlhuff_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlsb_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vlsbu_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlse_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vlsh_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vlshu_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlsw_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vlswu_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlw_v.c   |   49 +
 arch/riscv/kernel/soft_vector/insns/vlwff_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlwu_v.c  |   49 +
 .../riscv/kernel/soft_vector/insns/vlwuff_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlxb_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vlxbu_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlxe_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vlxh_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vlxhu_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vlxw_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vlxwu_v.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmacc_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmacc_vx.c |   49 +
 .../kernel/soft_vector/insns/vmadc_vim.c      |   49 +
 .../kernel/soft_vector/insns/vmadc_vvm.c      |   49 +
 .../kernel/soft_vector/insns/vmadc_vxm.c      |   49 +
 .../riscv/kernel/soft_vector/insns/vmadd_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmadd_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmand_mm.c |   49 +
 .../kernel/soft_vector/insns/vmandnot_mm.c    |   49 +
 arch/riscv/kernel/soft_vector/insns/vmax_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vmax_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmaxu_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmaxu_vx.c |   49 +
 .../kernel/soft_vector/insns/vmerge_vim.c     |   49 +
 .../kernel/soft_vector/insns/vmerge_vvm.c     |   49 +
 .../kernel/soft_vector/insns/vmerge_vxm.c     |   49 +
 .../riscv/kernel/soft_vector/insns/vmfeq_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmfeq_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmfge_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmfgt_vf.c |   49 +
 .../kernel/soft_vector/insns/vmfirst_m.c      |   49 +
 .../riscv/kernel/soft_vector/insns/vmfle_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmfle_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmflt_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmflt_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmfne_vf.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmfne_vv.c |   49 +
 .../kernel/soft_vector/insns/vmford_vf.c      |   49 +
 .../kernel/soft_vector/insns/vmford_vv.c      |   49 +
 arch/riscv/kernel/soft_vector/insns/vmin_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vmin_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vminu_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vminu_vx.c |   49 +
 .../kernel/soft_vector/insns/vmnand_mm.c      |   49 +
 .../riscv/kernel/soft_vector/insns/vmnor_mm.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vmor_mm.c |   49 +
 .../kernel/soft_vector/insns/vmornot_mm.c     |   49 +
 .../riscv/kernel/soft_vector/insns/vmpopc_m.c |   49 +
 .../kernel/soft_vector/insns/vmsbc_vvm.c      |   49 +
 .../kernel/soft_vector/insns/vmsbc_vxm.c      |   49 +
 arch/riscv/kernel/soft_vector/insns/vmsbf_m.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmseq_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmseq_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmseq_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmsgt_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmsgt_vx.c |   49 +
 .../kernel/soft_vector/insns/vmsgtu_vi.c      |   49 +
 .../kernel/soft_vector/insns/vmsgtu_vx.c      |   49 +
 arch/riscv/kernel/soft_vector/insns/vmsif_m.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmsle_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmsle_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmsle_vx.c |   49 +
 .../kernel/soft_vector/insns/vmsleu_vi.c      |   49 +
 .../kernel/soft_vector/insns/vmsleu_vv.c      |   49 +
 .../kernel/soft_vector/insns/vmsleu_vx.c      |   49 +
 .../riscv/kernel/soft_vector/insns/vmslt_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmslt_vx.c |   49 +
 .../kernel/soft_vector/insns/vmsltu_vv.c      |   49 +
 .../kernel/soft_vector/insns/vmsltu_vx.c      |   49 +
 .../riscv/kernel/soft_vector/insns/vmsne_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmsne_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmsne_vx.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vmsof_m.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vmul_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vmul_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmulh_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vmulh_vx.c |   49 +
 .../kernel/soft_vector/insns/vmulhsu_vv.c     |   49 +
 .../kernel/soft_vector/insns/vmulhsu_vx.c     |   49 +
 .../kernel/soft_vector/insns/vmulhu_vv.c      |   49 +
 .../kernel/soft_vector/insns/vmulhu_vx.c      |   49 +
 arch/riscv/kernel/soft_vector/insns/vmv_s_x.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vmv_v_i.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vmv_v_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vmv_v_x.c |   49 +
 .../kernel/soft_vector/insns/vmxnor_mm.c      |   49 +
 .../riscv/kernel/soft_vector/insns/vmxor_mm.c |   49 +
 .../kernel/soft_vector/insns/vnclip_vi.c      |   49 +
 .../kernel/soft_vector/insns/vnclip_vv.c      |   49 +
 .../kernel/soft_vector/insns/vnclip_vx.c      |   49 +
 .../kernel/soft_vector/insns/vnclipu_vi.c     |   49 +
 .../kernel/soft_vector/insns/vnclipu_vv.c     |   49 +
 .../kernel/soft_vector/insns/vnclipu_vx.c     |   49 +
 .../kernel/soft_vector/insns/vnmsac_vv.c      |   49 +
 .../kernel/soft_vector/insns/vnmsac_vx.c      |   49 +
 .../kernel/soft_vector/insns/vnmsub_vv.c      |   49 +
 .../kernel/soft_vector/insns/vnmsub_vx.c      |   49 +
 .../riscv/kernel/soft_vector/insns/vnsra_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vnsra_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vnsra_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vnsrl_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vnsrl_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vnsrl_vx.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vor_vi.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vor_vv.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vor_vx.c  |   49 +
 .../kernel/soft_vector/insns/vredand_vs.c     |   49 +
 .../kernel/soft_vector/insns/vredmax_vs.c     |   49 +
 .../kernel/soft_vector/insns/vredmaxu_vs.c    |   49 +
 .../kernel/soft_vector/insns/vredmin_vs.c     |   49 +
 .../kernel/soft_vector/insns/vredminu_vs.c    |   49 +
 .../kernel/soft_vector/insns/vredor_vs.c      |   49 +
 .../kernel/soft_vector/insns/vredsum_vs.c     |   49 +
 .../kernel/soft_vector/insns/vredxor_vs.c     |   49 +
 arch/riscv/kernel/soft_vector/insns/vrem_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vrem_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vremu_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vremu_vx.c |   49 +
 .../kernel/soft_vector/insns/vrgather_vi.c    |   49 +
 .../kernel/soft_vector/insns/vrgather_vv.c    |   49 +
 .../kernel/soft_vector/insns/vrgather_vx.c    |   49 +
 .../riscv/kernel/soft_vector/insns/vrsub_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vrsub_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vsadd_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vsadd_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vsadd_vx.c |   49 +
 .../kernel/soft_vector/insns/vsaddu_vi.c      |   49 +
 .../kernel/soft_vector/insns/vsaddu_vv.c      |   49 +
 .../kernel/soft_vector/insns/vsaddu_vx.c      |   49 +
 arch/riscv/kernel/soft_vector/insns/vsb_v.c   |   49 +
 .../riscv/kernel/soft_vector/insns/vsbc_vvm.c |   49 +
 .../riscv/kernel/soft_vector/insns/vsbc_vxm.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vse_v.c   |   49 +
 arch/riscv/kernel/soft_vector/insns/vsetvl.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vsetvli.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsh_v.c   |   49 +
 .../kernel/soft_vector/insns/vslide1down_vx.c |   49 +
 .../kernel/soft_vector/insns/vslide1up_vx.c   |   49 +
 .../kernel/soft_vector/insns/vslidedown_vi.c  |   49 +
 .../kernel/soft_vector/insns/vslidedown_vx.c  |   49 +
 .../kernel/soft_vector/insns/vslideup_vi.c    |   49 +
 .../kernel/soft_vector/insns/vslideup_vx.c    |   49 +
 arch/riscv/kernel/soft_vector/insns/vsll_vi.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsll_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsll_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vsmul_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vsmul_vx.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsra_vi.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsra_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsra_vx.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsrl_vi.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsrl_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsrl_vx.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vssb_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vsse_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vssh_v.c  |   49 +
 .../riscv/kernel/soft_vector/insns/vssra_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vssra_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vssra_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vssrl_vi.c |   49 +
 .../riscv/kernel/soft_vector/insns/vssrl_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vssrl_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vssub_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vssub_vx.c |   49 +
 .../kernel/soft_vector/insns/vssubu_vv.c      |   49 +
 .../kernel/soft_vector/insns/vssubu_vx.c      |   49 +
 arch/riscv/kernel/soft_vector/insns/vssw_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vsub_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsub_vx.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsuxb_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsuxe_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsuxh_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsuxw_v.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vsw_v.c   |   49 +
 arch/riscv/kernel/soft_vector/insns/vsxb_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vsxe_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vsxh_v.c  |   49 +
 arch/riscv/kernel/soft_vector/insns/vsxw_v.c  |   49 +
 .../riscv/kernel/soft_vector/insns/vwadd_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vwadd_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vwadd_wv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vwadd_wx.c |   49 +
 .../kernel/soft_vector/insns/vwaddu_vv.c      |   49 +
 .../kernel/soft_vector/insns/vwaddu_vx.c      |   49 +
 .../kernel/soft_vector/insns/vwaddu_wv.c      |   49 +
 .../kernel/soft_vector/insns/vwaddu_wx.c      |   49 +
 .../kernel/soft_vector/insns/vwmacc_vv.c      |   49 +
 .../kernel/soft_vector/insns/vwmacc_vx.c      |   49 +
 .../kernel/soft_vector/insns/vwmaccsu_vv.c    |   49 +
 .../kernel/soft_vector/insns/vwmaccsu_vx.c    |   49 +
 .../kernel/soft_vector/insns/vwmaccu_vv.c     |   49 +
 .../kernel/soft_vector/insns/vwmaccu_vx.c     |   49 +
 .../kernel/soft_vector/insns/vwmaccus_vx.c    |   49 +
 .../riscv/kernel/soft_vector/insns/vwmul_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vwmul_vx.c |   49 +
 .../kernel/soft_vector/insns/vwmulsu_vv.c     |   49 +
 .../kernel/soft_vector/insns/vwmulsu_vx.c     |   49 +
 .../kernel/soft_vector/insns/vwmulu_vv.c      |   49 +
 .../kernel/soft_vector/insns/vwmulu_vx.c      |   49 +
 .../kernel/soft_vector/insns/vwredsum_vs.c    |   49 +
 .../kernel/soft_vector/insns/vwredsumu_vs.c   |   49 +
 .../kernel/soft_vector/insns/vwsmacc_vv.c     |   49 +
 .../kernel/soft_vector/insns/vwsmacc_vx.c     |   49 +
 .../kernel/soft_vector/insns/vwsmaccsu_vv.c   |   49 +
 .../kernel/soft_vector/insns/vwsmaccsu_vx.c   |   49 +
 .../kernel/soft_vector/insns/vwsmaccu_vv.c    |   49 +
 .../kernel/soft_vector/insns/vwsmaccu_vx.c    |   49 +
 .../kernel/soft_vector/insns/vwsmaccus_vx.c   |   49 +
 .../riscv/kernel/soft_vector/insns/vwsub_vv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vwsub_vx.c |   49 +
 .../riscv/kernel/soft_vector/insns/vwsub_wv.c |   49 +
 .../riscv/kernel/soft_vector/insns/vwsub_wx.c |   49 +
 .../kernel/soft_vector/insns/vwsubu_vv.c      |   49 +
 .../kernel/soft_vector/insns/vwsubu_vx.c      |   49 +
 .../kernel/soft_vector/insns/vwsubu_wv.c      |   49 +
 .../kernel/soft_vector/insns/vwsubu_wx.c      |   49 +
 arch/riscv/kernel/soft_vector/insns/vxor_vi.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vxor_vv.c |   49 +
 arch/riscv/kernel/soft_vector/insns/vxor_vx.c |   49 +
 .../kernel/soft_vector/insns_func/vaadd_vi.h  |    9 +
 .../kernel/soft_vector/insns_func/vaadd_vv.h  |    2 +
 .../kernel/soft_vector/insns_func/vaadd_vx.h  |    2 +
 .../kernel/soft_vector/insns_func/vadc_vim.h  |   11 +
 .../kernel/soft_vector/insns_func/vadc_vvm.h  |   11 +
 .../kernel/soft_vector/insns_func/vadc_vxm.h  |   11 +
 .../kernel/soft_vector/insns_func/vadd_vi.h   |    5 +
 .../kernel/soft_vector/insns_func/vadd_vv.h   |    5 +
 .../kernel/soft_vector/insns_func/vadd_vx.h   |    5 +
 .../soft_vector/insns_func/vamoaddd_v.h       |    2 +
 .../soft_vector/insns_func/vamoaddw_v.h       |    2 +
 .../soft_vector/insns_func/vamoandd_v.h       |    2 +
 .../soft_vector/insns_func/vamoandw_v.h       |    2 +
 .../soft_vector/insns_func/vamomaxd_v.h       |    2 +
 .../soft_vector/insns_func/vamomaxud_v.h      |    2 +
 .../soft_vector/insns_func/vamomaxuw_v.h      |    2 +
 .../soft_vector/insns_func/vamomaxw_v.h       |    2 +
 .../soft_vector/insns_func/vamomind_v.h       |    2 +
 .../soft_vector/insns_func/vamominud_v.h      |    2 +
 .../soft_vector/insns_func/vamominuw_v.h      |    2 +
 .../soft_vector/insns_func/vamominw_v.h       |    2 +
 .../kernel/soft_vector/insns_func/vamoord_v.h |    2 +
 .../kernel/soft_vector/insns_func/vamoorw_v.h |    2 +
 .../soft_vector/insns_func/vamoswapd_v.h      |    2 +
 .../soft_vector/insns_func/vamoswapw_v.h      |    2 +
 .../soft_vector/insns_func/vamoxord_v.h       |    2 +
 .../soft_vector/insns_func/vamoxorw_v.h       |    2 +
 .../kernel/soft_vector/insns_func/vand_vi.h   |    5 +
 .../kernel/soft_vector/insns_func/vand_vv.h   |    5 +
 .../kernel/soft_vector/insns_func/vand_vx.h   |    5 +
 .../kernel/soft_vector/insns_func/vasub_vv.h  |    2 +
 .../kernel/soft_vector/insns_func/vasub_vx.h  |    2 +
 .../soft_vector/insns_func/vcompress_vm.h     |   44 +
 .../kernel/soft_vector/insns_func/vdiv_vv.h   |   10 +
 .../kernel/soft_vector/insns_func/vdiv_vx.h   |   10 +
 .../kernel/soft_vector/insns_func/vdivu_vv.h  |    8 +
 .../kernel/soft_vector/insns_func/vdivu_vx.h  |    8 +
 .../kernel/soft_vector/insns_func/vdot_vv.h   |    5 +
 .../kernel/soft_vector/insns_func/vdotu_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vext_x_v.h  |   32 +
 .../kernel/soft_vector/insns_func/vfadd_vf.h  |    8 +
 .../kernel/soft_vector/insns_func/vfadd_vv.h  |    8 +
 .../kernel/soft_vector/insns_func/vfclass_v.h |    8 +
 .../soft_vector/insns_func/vfcvt_f_x_v.h      |   10 +
 .../soft_vector/insns_func/vfcvt_f_xu_v.h     |   10 +
 .../soft_vector/insns_func/vfcvt_x_f_v.h      |    7 +
 .../soft_vector/insns_func/vfcvt_xu_f_v.h     |    8 +
 .../kernel/soft_vector/insns_func/vfdiv_vf.h  |    8 +
 .../kernel/soft_vector/insns_func/vfdiv_vv.h  |    8 +
 .../kernel/soft_vector/insns_func/vfdot_vv.h  |    8 +
 .../kernel/soft_vector/insns_func/vfmacc_vf.h |    8 +
 .../kernel/soft_vector/insns_func/vfmacc_vv.h |    8 +
 .../kernel/soft_vector/insns_func/vfmadd_vf.h |    8 +
 .../kernel/soft_vector/insns_func/vfmadd_vv.h |    8 +
 .../kernel/soft_vector/insns_func/vfmax_vf.h  |    8 +
 .../kernel/soft_vector/insns_func/vfmax_vv.h  |    8 +
 .../soft_vector/insns_func/vfmerge_vfm.h      |   21 +
 .../kernel/soft_vector/insns_func/vfmin_vf.h  |    8 +
 .../kernel/soft_vector/insns_func/vfmin_vv.h  |    8 +
 .../kernel/soft_vector/insns_func/vfmsac_vf.h |    8 +
 .../kernel/soft_vector/insns_func/vfmsac_vv.h |    8 +
 .../kernel/soft_vector/insns_func/vfmsub_vf.h |    8 +
 .../kernel/soft_vector/insns_func/vfmsub_vv.h |    8 +
 .../kernel/soft_vector/insns_func/vfmul_vf.h  |    8 +
 .../kernel/soft_vector/insns_func/vfmul_vv.h  |    8 +
 .../kernel/soft_vector/insns_func/vfmv_f_s.h  |   35 +
 .../kernel/soft_vector/insns_func/vfmv_s_f.h  |   29 +
 .../kernel/soft_vector/insns_func/vfmv_v_f.h  |   16 +
 .../soft_vector/insns_func/vfncvt_f_f_v.h     |    8 +
 .../soft_vector/insns_func/vfncvt_f_x_v.h     |    8 +
 .../soft_vector/insns_func/vfncvt_f_xu_v.h    |    8 +
 .../soft_vector/insns_func/vfncvt_x_f_v.h     |    8 +
 .../soft_vector/insns_func/vfncvt_xu_f_v.h    |    8 +
 .../soft_vector/insns_func/vfnmacc_vf.h       |    8 +
 .../soft_vector/insns_func/vfnmacc_vv.h       |    8 +
 .../soft_vector/insns_func/vfnmadd_vf.h       |    8 +
 .../soft_vector/insns_func/vfnmadd_vv.h       |    8 +
 .../soft_vector/insns_func/vfnmsac_vf.h       |    8 +
 .../soft_vector/insns_func/vfnmsac_vv.h       |    8 +
 .../soft_vector/insns_func/vfnmsub_vf.h       |    8 +
 .../soft_vector/insns_func/vfnmsub_vv.h       |    8 +
 .../kernel/soft_vector/insns_func/vfrdiv_vf.h |    8 +
 .../soft_vector/insns_func/vfredmax_vs.h      |    5 +
 .../soft_vector/insns_func/vfredmin_vs.h      |    5 +
 .../soft_vector/insns_func/vfredosum_vs.h     |    5 +
 .../soft_vector/insns_func/vfredsum_vs.h      |    5 +
 .../kernel/soft_vector/insns_func/vfrsub_vf.h |    8 +
 .../kernel/soft_vector/insns_func/vfsgnj_vf.h |    8 +
 .../kernel/soft_vector/insns_func/vfsgnj_vv.h |    8 +
 .../soft_vector/insns_func/vfsgnjn_vf.h       |    8 +
 .../soft_vector/insns_func/vfsgnjn_vv.h       |    8 +
 .../soft_vector/insns_func/vfsgnjx_vf.h       |    8 +
 .../soft_vector/insns_func/vfsgnjx_vv.h       |    8 +
 .../kernel/soft_vector/insns_func/vfsqrt_v.h  |    8 +
 .../kernel/soft_vector/insns_func/vfsub_vf.h  |    8 +
 .../kernel/soft_vector/insns_func/vfsub_vv.h  |    8 +
 .../kernel/soft_vector/insns_func/vfwadd_vf.h |    5 +
 .../kernel/soft_vector/insns_func/vfwadd_vv.h |    5 +
 .../kernel/soft_vector/insns_func/vfwadd_wf.h |    5 +
 .../kernel/soft_vector/insns_func/vfwadd_wv.h |    5 +
 .../soft_vector/insns_func/vfwcvt_f_f_v.h     |    9 +
 .../soft_vector/insns_func/vfwcvt_f_x_v.h     |    9 +
 .../soft_vector/insns_func/vfwcvt_f_xu_v.h    |    9 +
 .../soft_vector/insns_func/vfwcvt_x_f_v.h     |    9 +
 .../soft_vector/insns_func/vfwcvt_xu_f_v.h    |    9 +
 .../soft_vector/insns_func/vfwmacc_vf.h       |    5 +
 .../soft_vector/insns_func/vfwmacc_vv.h       |    5 +
 .../soft_vector/insns_func/vfwmsac_vf.h       |    5 +
 .../soft_vector/insns_func/vfwmsac_vv.h       |    5 +
 .../kernel/soft_vector/insns_func/vfwmul_vf.h |    5 +
 .../kernel/soft_vector/insns_func/vfwmul_vv.h |    5 +
 .../soft_vector/insns_func/vfwnmacc_vf.h      |    5 +
 .../soft_vector/insns_func/vfwnmacc_vv.h      |    5 +
 .../soft_vector/insns_func/vfwnmsac_vf.h      |    5 +
 .../soft_vector/insns_func/vfwnmsac_vv.h      |    5 +
 .../soft_vector/insns_func/vfwredosum_vs.h    |    5 +
 .../soft_vector/insns_func/vfwredsum_vs.h     |    5 +
 .../kernel/soft_vector/insns_func/vfwsub_vf.h |    5 +
 .../kernel/soft_vector/insns_func/vfwsub_vv.h |    5 +
 .../kernel/soft_vector/insns_func/vfwsub_wf.h |    5 +
 .../kernel/soft_vector/insns_func/vfwsub_wv.h |    5 +
 .../kernel/soft_vector/insns_func/vid_v.h     |   31 +
 .../kernel/soft_vector/insns_func/viota_m.h   |   54 +
 .../kernel/soft_vector/insns_func/vlb_v.h     |    5 +
 .../kernel/soft_vector/insns_func/vlbff_v.h   |    2 +
 .../kernel/soft_vector/insns_func/vlbu_v.h    |    5 +
 .../kernel/soft_vector/insns_func/vlbuff_v.h  |    2 +
 .../kernel/soft_vector/insns_func/vle_v.h     |   12 +
 .../kernel/soft_vector/insns_func/vleff_v.h   |   58 +
 .../kernel/soft_vector/insns_func/vlh_v.h     |    5 +
 .../kernel/soft_vector/insns_func/vlhff_v.h   |    2 +
 .../kernel/soft_vector/insns_func/vlhu_v.h    |    5 +
 .../kernel/soft_vector/insns_func/vlhuff_v.h  |    2 +
 .../kernel/soft_vector/insns_func/vlsb_v.h    |    5 +
 .../kernel/soft_vector/insns_func/vlsbu_v.h   |    5 +
 .../kernel/soft_vector/insns_func/vlse_v.h    |   13 +
 .../kernel/soft_vector/insns_func/vlsh_v.h    |    5 +
 .../kernel/soft_vector/insns_func/vlshu_v.h   |    5 +
 .../kernel/soft_vector/insns_func/vlsw_v.h    |    5 +
 .../kernel/soft_vector/insns_func/vlswu_v.h   |    5 +
 .../kernel/soft_vector/insns_func/vlw_v.h     |    5 +
 .../kernel/soft_vector/insns_func/vlwff_v.h   |    3 +
 .../kernel/soft_vector/insns_func/vlwu_v.h    |    5 +
 .../kernel/soft_vector/insns_func/vlwuff_v.h  |    2 +
 .../kernel/soft_vector/insns_func/vlxb_v.h    |    8 +
 .../kernel/soft_vector/insns_func/vlxbu_v.h   |    8 +
 .../kernel/soft_vector/insns_func/vlxe_v.h    |   13 +
 .../kernel/soft_vector/insns_func/vlxh_v.h    |    8 +
 .../kernel/soft_vector/insns_func/vlxhu_v.h   |    8 +
 .../kernel/soft_vector/insns_func/vlxw_v.h    |    8 +
 .../kernel/soft_vector/insns_func/vlxwu_v.h   |    8 +
 .../kernel/soft_vector/insns_func/vmacc_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmacc_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vmadc_vim.h |   16 +
 .../kernel/soft_vector/insns_func/vmadc_vvm.h |   16 +
 .../kernel/soft_vector/insns_func/vmadc_vxm.h |   16 +
 .../kernel/soft_vector/insns_func/vmadd_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmadd_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vmand_mm.h  |    2 +
 .../soft_vector/insns_func/vmandnot_mm.h      |    2 +
 .../kernel/soft_vector/insns_func/vmax_vv.h   |   10 +
 .../kernel/soft_vector/insns_func/vmax_vx.h   |   10 +
 .../kernel/soft_vector/insns_func/vmaxu_vv.h  |    9 +
 .../kernel/soft_vector/insns_func/vmaxu_vx.h  |    9 +
 .../soft_vector/insns_func/vmerge_vim.h       |    9 +
 .../soft_vector/insns_func/vmerge_vvm.h       |    9 +
 .../soft_vector/insns_func/vmerge_vxm.h       |    9 +
 .../kernel/soft_vector/insns_func/vmfeq_vf.h  |    5 +
 .../kernel/soft_vector/insns_func/vmfeq_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmfge_vf.h  |    5 +
 .../kernel/soft_vector/insns_func/vmfgt_vf.h  |    5 +
 .../kernel/soft_vector/insns_func/vmfirst_m.h |   22 +
 .../kernel/soft_vector/insns_func/vmfle_vf.h  |    5 +
 .../kernel/soft_vector/insns_func/vmfle_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmflt_vf.h  |    5 +
 .../kernel/soft_vector/insns_func/vmflt_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmfne_vf.h  |    5 +
 .../kernel/soft_vector/insns_func/vmfne_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmford_vf.h |    5 +
 .../kernel/soft_vector/insns_func/vmford_vv.h |    5 +
 .../kernel/soft_vector/insns_func/vmin_vv.h   |   11 +
 .../kernel/soft_vector/insns_func/vmin_vx.h   |   11 +
 .../kernel/soft_vector/insns_func/vminu_vv.h  |    9 +
 .../kernel/soft_vector/insns_func/vminu_vx.h  |   10 +
 .../kernel/soft_vector/insns_func/vmnand_mm.h |    2 +
 .../kernel/soft_vector/insns_func/vmnor_mm.h  |    2 +
 .../kernel/soft_vector/insns_func/vmor_mm.h   |    2 +
 .../soft_vector/insns_func/vmornot_mm.h       |    2 +
 .../kernel/soft_vector/insns_func/vmpopc_m.h  |   25 +
 .../kernel/soft_vector/insns_func/vmsbc_vvm.h |   16 +
 .../kernel/soft_vector/insns_func/vmsbc_vxm.h |   16 +
 .../kernel/soft_vector/insns_func/vmsbf_m.h   |   35 +
 .../kernel/soft_vector/insns_func/vmseq_vi.h  |    5 +
 .../kernel/soft_vector/insns_func/vmseq_vv.h  |    6 +
 .../kernel/soft_vector/insns_func/vmseq_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsgt_vi.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsgt_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsgtu_vi.h |    5 +
 .../kernel/soft_vector/insns_func/vmsgtu_vx.h |    5 +
 .../kernel/soft_vector/insns_func/vmsif_m.h   |   35 +
 .../kernel/soft_vector/insns_func/vmsle_vi.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsle_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsle_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsleu_vi.h |    5 +
 .../kernel/soft_vector/insns_func/vmsleu_vv.h |    5 +
 .../kernel/soft_vector/insns_func/vmsleu_vx.h |    5 +
 .../kernel/soft_vector/insns_func/vmslt_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmslt_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsltu_vv.h |    5 +
 .../kernel/soft_vector/insns_func/vmsltu_vx.h |    5 +
 .../kernel/soft_vector/insns_func/vmsne_vi.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsne_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsne_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vmsof_m.h   |   33 +
 .../kernel/soft_vector/insns_func/vmul_vv.h   |    5 +
 .../kernel/soft_vector/insns_func/vmul_vx.h   |    5 +
 .../kernel/soft_vector/insns_func/vmulh_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vmulh_vx.h  |    5 +
 .../soft_vector/insns_func/vmulhsu_vv.h       |   37 +
 .../soft_vector/insns_func/vmulhsu_vx.h       |   37 +
 .../kernel/soft_vector/insns_func/vmulhu_vv.h |    5 +
 .../kernel/soft_vector/insns_func/vmulhu_vx.h |    5 +
 .../kernel/soft_vector/insns_func/vmv_s_x.h   |   48 +
 .../kernel/soft_vector/insns_func/vmv_v_i.h   |    5 +
 .../kernel/soft_vector/insns_func/vmv_v_v.h   |    5 +
 .../kernel/soft_vector/insns_func/vmv_v_x.h   |    5 +
 .../kernel/soft_vector/insns_func/vmxnor_mm.h |    2 +
 .../kernel/soft_vector/insns_func/vmxor_mm.h  |    2 +
 .../kernel/soft_vector/insns_func/vnclip_vi.h |   24 +
 .../kernel/soft_vector/insns_func/vnclip_vv.h |   31 +
 .../kernel/soft_vector/insns_func/vnclip_vx.h |   30 +
 .../soft_vector/insns_func/vnclipu_vi.h       |   20 +
 .../soft_vector/insns_func/vnclipu_vv.h       |   27 +
 .../soft_vector/insns_func/vnclipu_vx.h       |   26 +
 .../kernel/soft_vector/insns_func/vnmsac_vv.h |    5 +
 .../kernel/soft_vector/insns_func/vnmsac_vx.h |    5 +
 .../kernel/soft_vector/insns_func/vnmsub_vv.h |    5 +
 .../kernel/soft_vector/insns_func/vnmsub_vx.h |    5 +
 .../kernel/soft_vector/insns_func/vnsra_vi.h  |    5 +
 .../kernel/soft_vector/insns_func/vnsra_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vnsra_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vnsrl_vi.h  |    5 +
 .../kernel/soft_vector/insns_func/vnsrl_vv.h  |    5 +
 .../kernel/soft_vector/insns_func/vnsrl_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vor_vi.h    |    5 +
 .../kernel/soft_vector/insns_func/vor_vv.h    |    5 +
 .../kernel/soft_vector/insns_func/vor_vx.h    |    5 +
 .../soft_vector/insns_func/vredand_vs.h       |    5 +
 .../soft_vector/insns_func/vredmax_vs.h       |    5 +
 .../soft_vector/insns_func/vredmaxu_vs.h      |    5 +
 .../soft_vector/insns_func/vredmin_vs.h       |    5 +
 .../soft_vector/insns_func/vredminu_vs.h      |    5 +
 .../kernel/soft_vector/insns_func/vredor_vs.h |    5 +
 .../soft_vector/insns_func/vredsum_vs.h       |    5 +
 .../soft_vector/insns_func/vredxor_vs.h       |    5 +
 .../kernel/soft_vector/insns_func/vrem_vv.h   |   11 +
 .../kernel/soft_vector/insns_func/vrem_vx.h   |   10 +
 .../kernel/soft_vector/insns_func/vremu_vv.h  |    8 +
 .../kernel/soft_vector/insns_func/vremu_vx.h  |    8 +
 .../soft_vector/insns_func/vrgather_vi.h      |   32 +
 .../soft_vector/insns_func/vrgather_vv.h      |   42 +
 .../soft_vector/insns_func/vrgather_vx.h      |   32 +
 .../kernel/soft_vector/insns_func/vrsub_vi.h  |    5 +
 .../kernel/soft_vector/insns_func/vrsub_vx.h  |    5 +
 .../kernel/soft_vector/insns_func/vsadd_vi.h  |   29 +
 .../kernel/soft_vector/insns_func/vsadd_vv.h  |   30 +
 .../kernel/soft_vector/insns_func/vsadd_vx.h  |   29 +
 .../kernel/soft_vector/insns_func/vsaddu_vi.h |   11 +
 .../kernel/soft_vector/insns_func/vsaddu_vv.h |   11 +
 .../kernel/soft_vector/insns_func/vsaddu_vx.h |   12 +
 .../kernel/soft_vector/insns_func/vsb_v.h     |    5 +
 .../kernel/soft_vector/insns_func/vsbc_vvm.h  |   11 +
 .../kernel/soft_vector/insns_func/vsbc_vxm.h  |   11 +
 .../kernel/soft_vector/insns_func/vse_v.h     |   13 +
 .../kernel/soft_vector/insns_func/vsetvl.h    |    1 +
 .../kernel/soft_vector/insns_func/vsetvli.h   |    1 +
 .../kernel/soft_vector/insns_func/vsh_v.h     |    5 +
 .../soft_vector/insns_func/vslide1down_vx.h   |   42 +
 .../soft_vector/insns_func/vslide1up_vx.h     |   34 +
 .../soft_vector/insns_func/vslidedown_vi.h    |   35 +
 .../soft_vector/insns_func/vslidedown_vx.h    |   34 +
 .../soft_vector/insns_func/vslideup_vi.h      |   37 +
 .../soft_vector/insns_func/vslideup_vx.h      |   32 +
 .../kernel/soft_vector/insns_func/vsll_vi.h   |    5 +
 .../kernel/soft_vector/insns_func/vsll_vv.h   |    5 +
 .../kernel/soft_vector/insns_func/vsll_vx.h   |    5 +
 .../kernel/soft_vector/insns_func/vsmul_vv.h  |   33 +
 .../kernel/soft_vector/insns_func/vsmul_vx.h  |   33 +
 .../kernel/soft_vector/insns_func/vsra_vi.h   |    5 +
 .../kernel/soft_vector/insns_func/vsra_vv.h   |    5 +
 .../kernel/soft_vector/insns_func/vsra_vx.h   |    5 +
 .../kernel/soft_vector/insns_func/vsrl_vi.h   |    5 +
 .../kernel/soft_vector/insns_func/vsrl_vv.h   |    5 +
 .../kernel/soft_vector/insns_func/vsrl_vx.h   |    5 +
 .../kernel/soft_vector/insns_func/vssb_v.h    |    5 +
 .../kernel/soft_vector/insns_func/vsse_v.h    |   13 +
 .../kernel/soft_vector/insns_func/vssh_v.h    |    5 +
 .../kernel/soft_vector/insns_func/vssra_vi.h  |    8 +
 .../kernel/soft_vector/insns_func/vssra_vv.h  |    9 +
 .../kernel/soft_vector/insns_func/vssra_vx.h  |    9 +
 .../kernel/soft_vector/insns_func/vssrl_vi.h  |    9 +
 .../kernel/soft_vector/insns_func/vssrl_vv.h  |   10 +
 .../kernel/soft_vector/insns_func/vssrl_vx.h  |   10 +
 .../kernel/soft_vector/insns_func/vssub_vv.h  |   30 +
 .../kernel/soft_vector/insns_func/vssub_vx.h  |   30 +
 .../kernel/soft_vector/insns_func/vssubu_vv.h |   30 +
 .../kernel/soft_vector/insns_func/vssubu_vx.h |   30 +
 .../kernel/soft_vector/insns_func/vssw_v.h    |    5 +
 .../kernel/soft_vector/insns_func/vsub_vv.h   |    5 +
 .../kernel/soft_vector/insns_func/vsub_vx.h   |    5 +
 .../kernel/soft_vector/insns_func/vsuxb_v.h   |   36 +
 .../kernel/soft_vector/insns_func/vsuxe_v.h   |   37 +
 .../kernel/soft_vector/insns_func/vsuxh_v.h   |   32 +
 .../kernel/soft_vector/insns_func/vsuxw_v.h   |   26 +
 .../kernel/soft_vector/insns_func/vsw_v.h     |    5 +
 .../kernel/soft_vector/insns_func/vsxb_v.h    |    8 +
 .../kernel/soft_vector/insns_func/vsxe_v.h    |   14 +
 .../kernel/soft_vector/insns_func/vsxh_v.h    |    8 +
 .../kernel/soft_vector/insns_func/vsxw_v.h    |    8 +
 .../kernel/soft_vector/insns_func/vwadd_vv.h  |    6 +
 .../kernel/soft_vector/insns_func/vwadd_vx.h  |    6 +
 .../kernel/soft_vector/insns_func/vwadd_wv.h  |    6 +
 .../kernel/soft_vector/insns_func/vwadd_wx.h  |    6 +
 .../kernel/soft_vector/insns_func/vwaddu_vv.h |    6 +
 .../kernel/soft_vector/insns_func/vwaddu_vx.h |    6 +
 .../kernel/soft_vector/insns_func/vwaddu_wv.h |    6 +
 .../kernel/soft_vector/insns_func/vwaddu_wx.h |    6 +
 .../kernel/soft_vector/insns_func/vwmacc_vv.h |    6 +
 .../kernel/soft_vector/insns_func/vwmacc_vx.h |    6 +
 .../soft_vector/insns_func/vwmaccsu_vv.h      |    6 +
 .../soft_vector/insns_func/vwmaccsu_vx.h      |    6 +
 .../soft_vector/insns_func/vwmaccu_vv.h       |    6 +
 .../soft_vector/insns_func/vwmaccu_vx.h       |    6 +
 .../soft_vector/insns_func/vwmaccus_vx.h      |    6 +
 .../kernel/soft_vector/insns_func/vwmul_vv.h  |    6 +
 .../kernel/soft_vector/insns_func/vwmul_vx.h  |    6 +
 .../soft_vector/insns_func/vwmulsu_vv.h       |   16 +
 .../soft_vector/insns_func/vwmulsu_vx.h       |   16 +
 .../kernel/soft_vector/insns_func/vwmulu_vv.h |    6 +
 .../kernel/soft_vector/insns_func/vwmulu_vx.h |    6 +
 .../soft_vector/insns_func/vwredsum_vs.h      |    5 +
 .../soft_vector/insns_func/vwredsumu_vs.h     |    5 +
 .../soft_vector/insns_func/vwsmacc_vv.h       |    2 +
 .../soft_vector/insns_func/vwsmacc_vx.h       |    2 +
 .../soft_vector/insns_func/vwsmaccsu_vv.h     |    2 +
 .../soft_vector/insns_func/vwsmaccsu_vx.h     |    2 +
 .../soft_vector/insns_func/vwsmaccu_vv.h      |    2 +
 .../soft_vector/insns_func/vwsmaccu_vx.h      |    2 +
 .../soft_vector/insns_func/vwsmaccus_vx.h     |    2 +
 .../kernel/soft_vector/insns_func/vwsub_vv.h  |    6 +
 .../kernel/soft_vector/insns_func/vwsub_vx.h  |    6 +
 .../kernel/soft_vector/insns_func/vwsub_wv.h  |    6 +
 .../kernel/soft_vector/insns_func/vwsub_wx.h  |    6 +
 .../kernel/soft_vector/insns_func/vwsubu_vv.h |    6 +
 .../kernel/soft_vector/insns_func/vwsubu_vx.h |    6 +
 .../kernel/soft_vector/insns_func/vwsubu_wv.h |    6 +
 .../kernel/soft_vector/insns_func/vwsubu_wx.h |    6 +
 .../kernel/soft_vector/insns_func/vxor_vi.h   |    5 +
 .../kernel/soft_vector/insns_func/vxor_vv.h   |    5 +
 .../kernel/soft_vector/insns_func/vxor_vx.h   |    5 +
 arch/riscv/kernel/soft_vector/riscv_decode.h  | 1933 +++++++++++++++++
 .../kernel/soft_vector/softfloat/Makefile     |  227 ++
 .../kernel/soft_vector/softfloat/config.h     |  107 +
 .../kernel/soft_vector/softfloat/f128_add.c   |   78 +
 .../soft_vector/softfloat/f128_classify.c     |   37 +
 .../kernel/soft_vector/softfloat/f128_div.c   |  199 ++
 .../kernel/soft_vector/softfloat/f128_eq.c    |   73 +
 .../soft_vector/softfloat/f128_eq_signaling.c |   67 +
 .../softfloat/f128_isSignalingNaN.c           |   51 +
 .../kernel/soft_vector/softfloat/f128_le.c    |   72 +
 .../soft_vector/softfloat/f128_le_quiet.c     |   78 +
 .../kernel/soft_vector/softfloat/f128_lt.c    |   72 +
 .../soft_vector/softfloat/f128_lt_quiet.c     |   78 +
 .../kernel/soft_vector/softfloat/f128_mul.c   |  163 ++
 .../soft_vector/softfloat/f128_mulAdd.c       |   63 +
 .../kernel/soft_vector/softfloat/f128_rem.c   |  190 ++
 .../soft_vector/softfloat/f128_roundToInt.c   |  160 ++
 .../kernel/soft_vector/softfloat/f128_sqrt.c  |  201 ++
 .../kernel/soft_vector/softfloat/f128_sub.c   |   78 +
 .../soft_vector/softfloat/f128_to_f16.c       |   95 +
 .../soft_vector/softfloat/f128_to_f32.c       |   95 +
 .../soft_vector/softfloat/f128_to_f64.c       |  100 +
 .../soft_vector/softfloat/f128_to_i32.c       |   85 +
 .../softfloat/f128_to_i32_r_minMag.c          |  100 +
 .../soft_vector/softfloat/f128_to_i64.c       |   95 +
 .../softfloat/f128_to_i64_r_minMag.c          |  113 +
 .../soft_vector/softfloat/f128_to_ui32.c      |   86 +
 .../softfloat/f128_to_ui32_r_minMag.c         |   89 +
 .../soft_vector/softfloat/f128_to_ui64.c      |   96 +
 .../softfloat/f128_to_ui64_r_minMag.c         |  105 +
 .../kernel/soft_vector/softfloat/f16_add.c    |   70 +
 .../soft_vector/softfloat/f16_classify.c      |   36 +
 .../kernel/soft_vector/softfloat/f16_div.c    |  186 ++
 .../kernel/soft_vector/softfloat/f16_eq.c     |   66 +
 .../soft_vector/softfloat/f16_eq_signaling.c  |   61 +
 .../softfloat/f16_isSignalingNaN.c            |   51 +
 .../kernel/soft_vector/softfloat/f16_le.c     |   66 +
 .../soft_vector/softfloat/f16_le_quiet.c      |   71 +
 .../kernel/soft_vector/softfloat/f16_lt.c     |   66 +
 .../soft_vector/softfloat/f16_lt_quiet.c      |   71 +
 .../kernel/soft_vector/softfloat/f16_mul.c    |  140 ++
 .../kernel/soft_vector/softfloat/f16_mulAdd.c |   60 +
 .../kernel/soft_vector/softfloat/f16_rem.c    |  171 ++
 .../soft_vector/softfloat/f16_roundToInt.c    |  112 +
 .../kernel/soft_vector/softfloat/f16_sqrt.c   |  136 ++
 .../kernel/soft_vector/softfloat/f16_sub.c    |   70 +
 .../soft_vector/softfloat/f16_to_f128.c       |   96 +
 .../kernel/soft_vector/softfloat/f16_to_f32.c |   93 +
 .../kernel/soft_vector/softfloat/f16_to_f64.c |   93 +
 .../kernel/soft_vector/softfloat/f16_to_i16.c |   57 +
 .../kernel/soft_vector/softfloat/f16_to_i32.c |   87 +
 .../softfloat/f16_to_i32_r_minMag.c           |   88 +
 .../kernel/soft_vector/softfloat/f16_to_i64.c |   87 +
 .../softfloat/f16_to_i64_r_minMag.c           |   88 +
 .../kernel/soft_vector/softfloat/f16_to_i8.c  |   57 +
 .../soft_vector/softfloat/f16_to_ui16.c       |   54 +
 .../soft_vector/softfloat/f16_to_ui32.c       |   84 +
 .../softfloat/f16_to_ui32_r_minMag.c          |   87 +
 .../soft_vector/softfloat/f16_to_ui64.c       |   84 +
 .../softfloat/f16_to_ui64_r_minMag.c          |   87 +
 .../kernel/soft_vector/softfloat/f16_to_ui8.c |   54 +
 .../kernel/soft_vector/softfloat/f32_add.c    |   70 +
 .../soft_vector/softfloat/f32_classify.c      |   36 +
 .../kernel/soft_vector/softfloat/f32_div.c    |  180 ++
 .../kernel/soft_vector/softfloat/f32_eq.c     |   66 +
 .../soft_vector/softfloat/f32_eq_signaling.c  |   61 +
 .../softfloat/f32_isSignalingNaN.c            |   51 +
 .../kernel/soft_vector/softfloat/f32_le.c     |   66 +
 .../soft_vector/softfloat/f32_le_quiet.c      |   71 +
 .../kernel/soft_vector/softfloat/f32_lt.c     |   66 +
 .../soft_vector/softfloat/f32_lt_quiet.c      |   71 +
 .../kernel/soft_vector/softfloat/f32_mul.c    |  137 ++
 .../kernel/soft_vector/softfloat/f32_mulAdd.c |   60 +
 .../kernel/soft_vector/softfloat/f32_rem.c    |  168 ++
 .../soft_vector/softfloat/f32_roundToInt.c    |  112 +
 .../kernel/soft_vector/softfloat/f32_sqrt.c   |  121 ++
 .../kernel/soft_vector/softfloat/f32_sub.c    |   70 +
 .../soft_vector/softfloat/f32_to_f128.c       |   96 +
 .../kernel/soft_vector/softfloat/f32_to_f16.c |   88 +
 .../kernel/soft_vector/softfloat/f32_to_f64.c |   93 +
 .../kernel/soft_vector/softfloat/f32_to_i16.c |   57 +
 .../kernel/soft_vector/softfloat/f32_to_i32.c |   84 +
 .../softfloat/f32_to_i32_r_minMag.c           |   89 +
 .../kernel/soft_vector/softfloat/f32_to_i64.c |   96 +
 .../softfloat/f32_to_i64_r_minMag.c           |   94 +
 .../soft_vector/softfloat/f32_to_ui16.c       |   53 +
 .../soft_vector/softfloat/f32_to_ui32.c       |   84 +
 .../softfloat/f32_to_ui32_r_minMag.c          |   88 +
 .../soft_vector/softfloat/f32_to_ui64.c       |   96 +
 .../softfloat/f32_to_ui64_r_minMag.c          |   90 +
 .../kernel/soft_vector/softfloat/f64_add.c    |   74 +
 .../soft_vector/softfloat/f64_classify.c      |   36 +
 .../kernel/soft_vector/softfloat/f64_div.c    |  172 ++
 .../kernel/soft_vector/softfloat/f64_eq.c     |   66 +
 .../soft_vector/softfloat/f64_eq_signaling.c  |   61 +
 .../softfloat/f64_isSignalingNaN.c            |   51 +
 .../kernel/soft_vector/softfloat/f64_le.c     |   67 +
 .../soft_vector/softfloat/f64_le_quiet.c      |   72 +
 .../kernel/soft_vector/softfloat/f64_lt.c     |   67 +
 .../soft_vector/softfloat/f64_lt_quiet.c      |   72 +
 .../kernel/soft_vector/softfloat/f64_mul.c    |  150 ++
 .../kernel/soft_vector/softfloat/f64_mulAdd.c |   60 +
 .../kernel/soft_vector/softfloat/f64_rem.c    |  189 ++
 .../soft_vector/softfloat/f64_roundToInt.c    |  112 +
 .../kernel/soft_vector/softfloat/f64_sqrt.c   |  133 ++
 .../kernel/soft_vector/softfloat/f64_sub.c    |   74 +
 .../soft_vector/softfloat/f64_to_f128.c       |   98 +
 .../kernel/soft_vector/softfloat/f64_to_f16.c |   88 +
 .../kernel/soft_vector/softfloat/f64_to_f32.c |   88 +
 .../kernel/soft_vector/softfloat/f64_to_i32.c |   82 +
 .../softfloat/f64_to_i32_r_minMag.c           |   96 +
 .../kernel/soft_vector/softfloat/f64_to_i64.c |  103 +
 .../softfloat/f64_to_i64_r_minMag.c           |  100 +
 .../soft_vector/softfloat/f64_to_ui32.c       |   82 +
 .../softfloat/f64_to_ui32_r_minMag.c          |   88 +
 .../soft_vector/softfloat/f64_to_ui64.c       |  103 +
 .../softfloat/f64_to_ui64_r_minMag.c          |   93 +
 .../soft_vector/softfloat/fall_maxmin.c       |   80 +
 .../soft_vector/softfloat/i32_to_f128.c       |   64 +
 .../kernel/soft_vector/softfloat/i32_to_f16.c |   71 +
 .../kernel/soft_vector/softfloat/i32_to_f32.c |   58 +
 .../kernel/soft_vector/softfloat/i32_to_f64.c |   65 +
 .../soft_vector/softfloat/i64_to_f128.c       |   72 +
 .../kernel/soft_vector/softfloat/i64_to_f16.c |   70 +
 .../kernel/soft_vector/softfloat/i64_to_f32.c |   70 +
 .../kernel/soft_vector/softfloat/i64_to_f64.c |   58 +
 .../kernel/soft_vector/softfloat/internals.h  |  286 +++
 .../kernel/soft_vector/softfloat/platform.h   |   52 +
 .../soft_vector/softfloat/primitiveTypes.h    |   86 +
 .../kernel/soft_vector/softfloat/primitives.h | 1168 ++++++++++
 .../kernel/soft_vector/softfloat/s_add128.c   |   55 +
 .../kernel/soft_vector/softfloat/s_add256M.c  |   65 +
 .../soft_vector/softfloat/s_addCarryM.c       |   70 +
 .../soft_vector/softfloat/s_addComplCarryM.c  |   70 +
 .../kernel/soft_vector/softfloat/s_addM.c     |   70 +
 .../soft_vector/softfloat/s_addMagsF128.c     |  154 ++
 .../soft_vector/softfloat/s_addMagsF16.c      |  183 ++
 .../soft_vector/softfloat/s_addMagsF32.c      |  126 ++
 .../soft_vector/softfloat/s_addMagsF64.c      |  128 ++
 .../soft_vector/softfloat/s_approxRecip32_1.c |   66 +
 .../softfloat/s_approxRecipSqrt32_1.c         |   73 +
 .../softfloat/s_approxRecipSqrt_1Ks.c         |   49 +
 .../soft_vector/softfloat/s_approxRecip_1Ks.c |   49 +
 .../softfloat/s_commonNaNToF128UI.c           |   56 +
 .../softfloat/s_commonNaNToF16UI.c            |    5 +
 .../softfloat/s_commonNaNToF32UI.c            |    5 +
 .../softfloat/s_commonNaNToF64UI.c            |    5 +
 .../soft_vector/softfloat/s_compare128M.c     |   62 +
 .../soft_vector/softfloat/s_compare96M.c      |   62 +
 .../softfloat/s_countLeadingZeros16.c         |   60 +
 .../softfloat/s_countLeadingZeros32.c         |   64 +
 .../softfloat/s_countLeadingZeros64.c         |   73 +
 .../softfloat/s_countLeadingZeros8.c          |   59 +
 .../kernel/soft_vector/softfloat/s_eq128.c    |   51 +
 .../softfloat/s_f128UIToCommonNaN.c           |    5 +
 .../softfloat/s_f16UIToCommonNaN.c            |    5 +
 .../softfloat/s_f32UIToCommonNaN.c            |    5 +
 .../softfloat/s_f64UIToCommonNaN.c            |    5 +
 .../kernel/soft_vector/softfloat/s_le128.c    |   51 +
 .../kernel/soft_vector/softfloat/s_lt128.c    |   51 +
 .../soft_vector/softfloat/s_mul128By32.c      |   58 +
 .../soft_vector/softfloat/s_mul128MTo256M.c   |  100 +
 .../soft_vector/softfloat/s_mul128To256M.c    |   71 +
 .../softfloat/s_mul64ByShifted32To128.c       |   56 +
 .../soft_vector/softfloat/s_mul64To128.c      |   66 +
 .../soft_vector/softfloat/s_mul64To128M.c     |   68 +
 .../soft_vector/softfloat/s_mulAddF128.c      |  350 +++
 .../soft_vector/softfloat/s_mulAddF16.c       |  226 ++
 .../soft_vector/softfloat/s_mulAddF32.c       |  224 ++
 .../soft_vector/softfloat/s_mulAddF64.c       |  496 +++++
 .../kernel/soft_vector/softfloat/s_negXM.c    |   63 +
 .../softfloat/s_normRoundPackToF128.c         |   81 +
 .../softfloat/s_normRoundPackToF16.c          |   58 +
 .../softfloat/s_normRoundPackToF32.c          |   58 +
 .../softfloat/s_normRoundPackToF64.c          |   58 +
 .../softfloat/s_normSubnormalF128Sig.c        |   65 +
 .../softfloat/s_normSubnormalF16Sig.c         |   52 +
 .../softfloat/s_normSubnormalF32Sig.c         |   52 +
 .../softfloat/s_normSubnormalF64Sig.c         |   52 +
 .../softfloat/s_propagateNaNF128UI.c          |   73 +
 .../softfloat/s_propagateNaNF16UI.c           |   58 +
 .../softfloat/s_propagateNaNF32UI.c           |   58 +
 .../softfloat/s_propagateNaNF64UI.c           |   58 +
 .../soft_vector/softfloat/s_remStepMBy32.c    |   86 +
 .../soft_vector/softfloat/s_roundMToI64.c     |   88 +
 .../soft_vector/softfloat/s_roundMToUI64.c    |   84 +
 .../soft_vector/softfloat/s_roundPackMToI64.c |   88 +
 .../softfloat/s_roundPackMToUI64.c            |   84 +
 .../soft_vector/softfloat/s_roundPackToF128.c |  171 ++
 .../soft_vector/softfloat/s_roundPackToF16.c  |  113 +
 .../soft_vector/softfloat/s_roundPackToF32.c  |  113 +
 .../soft_vector/softfloat/s_roundPackToF64.c  |  117 +
 .../soft_vector/softfloat/s_roundPackToI32.c  |   84 +
 .../soft_vector/softfloat/s_roundPackToI64.c  |   89 +
 .../soft_vector/softfloat/s_roundPackToUI32.c |   80 +
 .../soft_vector/softfloat/s_roundPackToUI64.c |   85 +
 .../soft_vector/softfloat/s_roundToI32.c      |   84 +
 .../soft_vector/softfloat/s_roundToI64.c      |   89 +
 .../soft_vector/softfloat/s_roundToUI32.c     |   80 +
 .../soft_vector/softfloat/s_roundToUI64.c     |   85 +
 .../softfloat/s_shiftRightJam128.c            |   69 +
 .../softfloat/s_shiftRightJam128Extra.c       |   77 +
 .../softfloat/s_shiftRightJam256M.c           |  126 ++
 .../soft_vector/softfloat/s_shiftRightJam32.c |   51 +
 .../soft_vector/softfloat/s_shiftRightJam64.c |   51 +
 .../softfloat/s_shiftRightJam64Extra.c        |   62 +
 .../softfloat/s_shortShiftLeft128.c           |   55 +
 .../softfloat/s_shortShiftLeft64To96M.c       |   56 +
 .../softfloat/s_shortShiftRight128.c          |   55 +
 .../softfloat/s_shortShiftRightExtendM.c      |   73 +
 .../softfloat/s_shortShiftRightJam128.c       |   60 +
 .../softfloat/s_shortShiftRightJam128Extra.c  |   59 +
 .../softfloat/s_shortShiftRightJam64.c        |   50 +
 .../softfloat/s_shortShiftRightJam64Extra.c   |   56 +
 .../softfloat/s_shortShiftRightM.c            |   70 +
 .../kernel/soft_vector/softfloat/s_sub128.c   |   55 +
 .../kernel/soft_vector/softfloat/s_sub1XM.c   |   60 +
 .../kernel/soft_vector/softfloat/s_sub256M.c  |   65 +
 .../kernel/soft_vector/softfloat/s_subM.c     |   70 +
 .../soft_vector/softfloat/s_subMagsF128.c     |  139 ++
 .../soft_vector/softfloat/s_subMagsF16.c      |  187 ++
 .../soft_vector/softfloat/s_subMagsF32.c      |  143 ++
 .../soft_vector/softfloat/s_subMagsF64.c      |  141 ++
 .../kernel/soft_vector/softfloat/softfloat.h  |  396 ++++
 .../softfloat/softfloat_raiseFlags.c          |   52 +
 .../soft_vector/softfloat/softfloat_state.c   |   52 +
 .../soft_vector/softfloat/softfloat_types.h   |   81 +
 .../kernel/soft_vector/softfloat/specialize.h |  429 ++++
 .../kernel/soft_vector/softfloat/stdbool.h    |    7 +
 .../kernel/soft_vector/softfloat/stdint.h     |  338 +++
 .../soft_vector/softfloat/ui32_to_f128.c      |   60 +
 .../soft_vector/softfloat/ui32_to_f16.c       |   65 +
 .../soft_vector/softfloat/ui32_to_f32.c       |   57 +
 .../soft_vector/softfloat/ui32_to_f64.c       |   59 +
 .../soft_vector/softfloat/ui64_to_f128.c      |   68 +
 .../soft_vector/softfloat/ui64_to_f16.c       |   64 +
 .../soft_vector/softfloat/ui64_to_f32.c       |   64 +
 .../soft_vector/softfloat/ui64_to_f64.c       |   59 +
 967 files changed, 48883 insertions(+)
 create mode 100644 arch/riscv/kernel/soft_vector/Makefile
 create mode 100644 arch/riscv/kernel/soft_vector/arch_riscv_kernel_soft_vector_generate
 create mode 100644 arch/riscv/kernel/soft_vector/arith.h
 create mode 100644 arch/riscv/kernel/soft_vector/decode.c
 create mode 100644 arch/riscv/kernel/soft_vector/encoding.h
 create mode 100644 arch/riscv/kernel/soft_vector/insn_list.h
 create mode 100644 arch/riscv/kernel/soft_vector/insn_template.c
 create mode 100644 arch/riscv/kernel/soft_vector/insn_template.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns/Makefile
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vaadd_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vaadd_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vaadd_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vadc_vim.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vadc_vvm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vadc_vxm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vadd_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vadd_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vadd_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoaddd_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoaddw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoandd_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoandw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamomaxd_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamomaxud_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamomaxuw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamomaxw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamomind_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamominud_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamominuw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamominw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoord_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoorw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoswapd_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoswapw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoxord_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vamoxorw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vand_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vand_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vand_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vasub_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vasub_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vcompress_vm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vdiv_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vdiv_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vdivu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vdivu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vdot_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vdotu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vext_x_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfadd_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfadd_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfclass_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfcvt_f_x_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfcvt_f_xu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfcvt_x_f_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfcvt_xu_f_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfdiv_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfdiv_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfdot_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmacc_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmacc_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmadd_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmadd_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmax_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmax_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmerge_vfm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmin_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmin_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmsac_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmsac_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmsub_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmsub_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmul_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmul_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmv_f_s.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmv_s_f.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfmv_v_f.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfncvt_f_f_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfncvt_f_x_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfncvt_f_xu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfncvt_x_f_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfncvt_xu_f_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfnmacc_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfnmacc_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfnmadd_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfnmadd_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfnmsac_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfnmsac_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfnmsub_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfnmsub_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfrdiv_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfredmax_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfredmin_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfredosum_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfredsum_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfrsub_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfsgnj_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfsgnj_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfsgnjn_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfsgnjn_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfsgnjx_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfsgnjx_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfsqrt_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfsub_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfsub_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwadd_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwadd_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwadd_wf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwadd_wv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwcvt_f_f_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwcvt_f_x_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwcvt_f_xu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwcvt_x_f_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwcvt_xu_f_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwmacc_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwmacc_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwmsac_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwmsac_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwmul_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwmul_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwnmacc_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwnmacc_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwnmsac_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwnmsac_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwredosum_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwredsum_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwsub_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwsub_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwsub_wf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vfwsub_wv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vid_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/viota_m.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlb_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlbff_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlbu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlbuff_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vle_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vleff_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlh_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlhff_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlhu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlhuff_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlsb_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlsbu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlse_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlsh_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlshu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlsw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlswu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlwff_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlwu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlwuff_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlxb_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlxbu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlxe_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlxh_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlxhu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlxw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vlxwu_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmacc_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmacc_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmadc_vim.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmadc_vvm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmadc_vxm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmadd_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmadd_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmand_mm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmandnot_mm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmax_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmax_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmaxu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmaxu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmerge_vim.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmerge_vvm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmerge_vxm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmfeq_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmfeq_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmfge_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmfgt_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmfirst_m.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmfle_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmfle_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmflt_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmflt_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmfne_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmfne_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmford_vf.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmford_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmin_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmin_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vminu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vminu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmnand_mm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmnor_mm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmor_mm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmornot_mm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmpopc_m.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsbc_vvm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsbc_vxm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsbf_m.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmseq_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmseq_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmseq_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsgt_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsgt_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsgtu_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsgtu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsif_m.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsle_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsle_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsle_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsleu_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsleu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsleu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmslt_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmslt_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsltu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsltu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsne_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsne_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsne_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmsof_m.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmul_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmul_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmulh_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmulh_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmulhsu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmulhsu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmulhu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmulhu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmv_s_x.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmv_v_i.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmv_v_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmv_v_x.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmxnor_mm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vmxor_mm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnclip_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnclip_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnclip_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnclipu_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnclipu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnclipu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnmsac_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnmsac_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnmsub_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnmsub_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnsra_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnsra_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnsra_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnsrl_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnsrl_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vnsrl_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vor_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vor_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vor_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vredand_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vredmax_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vredmaxu_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vredmin_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vredminu_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vredor_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vredsum_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vredxor_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vrem_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vrem_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vremu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vremu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vrgather_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vrgather_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vrgather_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vrsub_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vrsub_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsadd_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsadd_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsadd_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsaddu_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsaddu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsaddu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsb_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsbc_vvm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsbc_vxm.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vse_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsetvl.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsetvli.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsh_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vslide1down_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vslide1up_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vslidedown_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vslidedown_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vslideup_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vslideup_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsll_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsll_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsll_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsmul_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsmul_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsra_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsra_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsra_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsrl_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsrl_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsrl_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssb_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsse_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssh_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssra_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssra_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssra_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssrl_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssrl_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssrl_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssub_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssub_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssubu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssubu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vssw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsub_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsub_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsuxb_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsuxe_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsuxh_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsuxw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsxb_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsxe_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsxh_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vsxw_v.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwadd_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwadd_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwadd_wv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwadd_wx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwaddu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwaddu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwaddu_wv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwaddu_wx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmacc_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmacc_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmaccsu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmaccsu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmaccu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmaccu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmaccus_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmul_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmul_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmulsu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmulsu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmulu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwmulu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwredsum_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwredsumu_vs.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsmacc_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsmacc_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsmaccu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsmaccu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsmaccus_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsub_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsub_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsub_wv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsub_wx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsubu_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsubu_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsubu_wv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vwsubu_wx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vxor_vi.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vxor_vv.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns/vxor_vx.c
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vaadd_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vaadd_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vaadd_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vadc_vim.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vadc_vvm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vadc_vxm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vadd_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vadd_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vadd_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoaddd_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoaddw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoandd_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoandw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamomaxd_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamomaxud_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamomaxuw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamomaxw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamomind_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamominud_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamominuw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamominw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoord_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoorw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoswapd_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoswapw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoxord_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vamoxorw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vand_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vand_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vand_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vasub_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vasub_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vcompress_vm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vdiv_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vdiv_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vdivu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vdivu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vdot_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vdotu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vext_x_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfadd_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfadd_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfclass_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_x_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_xu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfcvt_x_f_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfcvt_xu_f_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfdiv_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfdiv_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfdot_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmacc_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmacc_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmadd_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmadd_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmax_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmax_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmerge_vfm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmin_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmin_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmsac_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmsac_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmsub_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmsub_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmul_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmul_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmv_f_s.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmv_s_f.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfmv_v_f.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_f_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_x_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_xu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfncvt_x_f_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfncvt_xu_f_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfrdiv_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfredmax_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfredmin_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfredosum_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfredsum_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfrsub_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfsqrt_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfsub_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfsub_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwadd_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwadd_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwadd_wf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwadd_wv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_f_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_x_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_xu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwcvt_x_f_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwcvt_xu_f_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwmul_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwmul_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwredosum_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwredsum_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwsub_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwsub_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwsub_wf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vfwsub_wv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vid_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/viota_m.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlb_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlbff_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlbu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlbuff_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vle_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vleff_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlh_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlhff_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlhu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlhuff_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlsb_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlsbu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlse_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlsh_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlshu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlsw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlswu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlwff_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlwu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlwuff_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlxb_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlxbu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlxe_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlxh_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlxhu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlxw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vlxwu_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmacc_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmacc_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmadc_vim.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmadc_vvm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmadc_vxm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmadd_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmadd_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmand_mm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmandnot_mm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmax_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmax_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmaxu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmaxu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmerge_vim.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmerge_vvm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmerge_vxm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmfeq_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmfeq_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmfge_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmfgt_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmfirst_m.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmfle_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmfle_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmflt_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmflt_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmfne_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmfne_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmford_vf.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmford_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmin_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmin_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vminu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vminu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmnand_mm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmnor_mm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmor_mm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmornot_mm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmpopc_m.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsbc_vvm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsbc_vxm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsbf_m.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmseq_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmseq_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmseq_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsgt_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsgt_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsif_m.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsle_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsle_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsle_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsleu_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsleu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsleu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmslt_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmslt_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsltu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsltu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsne_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsne_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsne_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmsof_m.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmul_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmul_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmulh_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmulh_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmulhu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmulhu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmv_s_x.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmv_v_i.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmv_v_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmv_v_x.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmxnor_mm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vmxor_mm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnclip_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnclip_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnclip_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnclipu_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnclipu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnclipu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnmsac_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnmsac_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnmsub_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnmsub_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnsra_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnsra_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnsra_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnsrl_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnsrl_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vnsrl_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vor_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vor_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vor_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vredand_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vredmax_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vredmaxu_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vredmin_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vredminu_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vredor_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vredsum_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vredxor_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vrem_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vrem_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vremu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vremu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vrgather_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vrgather_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vrgather_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vrsub_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vrsub_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsadd_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsadd_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsadd_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsaddu_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsaddu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsaddu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsb_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsbc_vvm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsbc_vxm.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vse_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsetvl.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsetvli.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsh_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vslide1down_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vslide1up_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vslidedown_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vslidedown_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vslideup_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vslideup_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsll_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsll_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsll_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsmul_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsmul_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsra_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsra_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsra_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsrl_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsrl_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsrl_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssb_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsse_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssh_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssra_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssra_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssra_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssrl_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssrl_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssrl_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssub_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssub_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssubu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssubu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vssw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsub_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsub_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsuxb_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsuxe_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsuxh_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsuxw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsxb_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsxe_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsxh_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vsxw_v.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwadd_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwadd_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwadd_wv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwadd_wx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwaddu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwaddu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwaddu_wv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwaddu_wx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmacc_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmacc_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmaccus_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmul_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmul_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmulu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwmulu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwredsum_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwredsumu_vs.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsmaccus_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsub_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsub_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsub_wv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsub_wx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsubu_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsubu_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsubu_wv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vwsubu_wx.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vxor_vi.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vxor_vv.h
 create mode 100644 arch/riscv/kernel/soft_vector/insns_func/vxor_vx.h
 create mode 100644 arch/riscv/kernel/soft_vector/riscv_decode.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/Makefile
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/config.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_add.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_classify.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_div.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_eq.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_eq_signaling.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_isSignalingNaN.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_le.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_le_quiet.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_lt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_lt_quiet.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_mul.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_mulAdd.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_rem.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_roundToInt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_sqrt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_sub.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_f16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_f32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_f64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_i32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_i32_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_i64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_i64_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_add.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_classify.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_div.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_eq.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_eq_signaling.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_isSignalingNaN.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_le.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_le_quiet.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_lt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_lt_quiet.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_mul.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_mulAdd.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_rem.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_roundToInt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_sqrt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_sub.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_f128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_f32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_f64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_i16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_i32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_i32_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_i64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_i64_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_i8.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_ui16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f16_to_ui8.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_add.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_classify.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_div.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_eq.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_eq_signaling.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_isSignalingNaN.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_le.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_le_quiet.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_lt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_lt_quiet.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_mul.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_mulAdd.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_rem.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_roundToInt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_sqrt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_sub.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_f128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_f16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_f64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_i16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_i32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_i32_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_i64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_i64_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_ui16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_add.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_classify.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_div.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_eq.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_eq_signaling.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_isSignalingNaN.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_le.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_le_quiet.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_lt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_lt_quiet.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_mul.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_mulAdd.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_rem.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_roundToInt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_sqrt.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_sub.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_f128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_f16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_f32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_i32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_i32_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_i64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_i64_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64_r_minMag.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/fall_maxmin.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/i32_to_f128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/i32_to_f16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/i32_to_f32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/i32_to_f64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/i64_to_f128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/i64_to_f16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/i64_to_f32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/i64_to_f64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/internals.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/platform.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/primitiveTypes.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/primitives.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_add128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_add256M.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_addCarryM.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_addComplCarryM.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_addM.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_addMagsF128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_addMagsF16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_addMagsF32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_addMagsF64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_approxRecip32_1.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt32_1.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt_1Ks.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_approxRecip_1Ks.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF128UI.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF16UI.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF32UI.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF64UI.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_compare128M.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_compare96M.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros8.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_eq128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_f128UIToCommonNaN.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_f16UIToCommonNaN.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_f32UIToCommonNaN.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_f64UIToCommonNaN.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_le128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_lt128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mul128By32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mul128MTo256M.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mul128To256M.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mul64ByShifted32To128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mul64To128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mul64To128M.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mulAddF128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mulAddF16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mulAddF32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_mulAddF64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_negXM.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF128Sig.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF16Sig.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF32Sig.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF64Sig.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF128UI.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF16UI.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF32UI.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF64UI.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_remStepMBy32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundMToI64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundMToUI64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToI64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToUI64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundToI32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundToI64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundToUI32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_roundToUI64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128Extra.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam256M.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64Extra.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft64To96M.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRight128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightExtendM.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128Extra.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64Extra.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightM.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_sub128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_sub1XM.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_sub256M.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_subM.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_subMagsF128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_subMagsF16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_subMagsF32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/s_subMagsF64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/softfloat.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/softfloat_raiseFlags.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/softfloat_state.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/softfloat_types.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/specialize.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/stdbool.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/stdint.h
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/ui32_to_f128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/ui32_to_f16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/ui32_to_f32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/ui32_to_f64.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/ui64_to_f128.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/ui64_to_f16.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/ui64_to_f32.c
 create mode 100644 arch/riscv/kernel/soft_vector/softfloat/ui64_to_f64.c

diff --git a/arch/riscv/kernel/soft_vector/Makefile b/arch/riscv/kernel/soft_vector/Makefile
new file mode 100644
index 000000000000..d0f8984c8132
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the RISC-V Linux kernel
+#
+obj-$(CONFIG_VECTOR_EMU)	+= softfloat/
+obj-$(CONFIG_VECTOR_EMU)	+= insns/
+obj-$(CONFIG_VECTOR_EMU)	+= decode.o
+
+clean:
diff --git a/arch/riscv/kernel/soft_vector/arch_riscv_kernel_soft_vector_generate b/arch/riscv/kernel/soft_vector/arch_riscv_kernel_soft_vector_generate
new file mode 100644
index 000000000000..f32ebfc8aaa7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/arch_riscv_kernel_soft_vector_generate
@@ -0,0 +1,485 @@
+#!/bin/bash
+function get_opcode() {
+      grep ^DECLARE_INSN.*\\\<$2\\\> $1 | sed 's/DECLARE_INSN(.*,\(.*\),.*)/\1/' | sed 's/ //';
+};
+
+insns=( 'vaadd_vi' \
+    'vaadd_vv' \
+    'vaadd_vx' \
+    'vadc_vim' \
+    'vadc_vvm' \
+    'vadc_vxm' \
+    'vadd_vi' \
+    'vadd_vv' \
+    'vadd_vx' \
+    'vand_vi' \
+    'vand_vv' \
+    'vand_vx' \
+    'vasub_vv' \
+    'vasub_vx' \
+    'vcompress_vm' \
+    'vdiv_vv' \
+    'vdiv_vx' \
+    'vdivu_vv' \
+    'vdivu_vx' \
+    'vdot_vv' \
+    'vdotu_vv' \
+    'vext_x_v' \
+    'vid_v' \
+    'viota_m' \
+    'vmacc_vv' \
+    'vmacc_vx' \
+    'vmadc_vim' \
+    'vmadc_vvm' \
+    'vmadc_vxm' \
+    'vmadd_vv' \
+    'vmadd_vx' \
+    'vmand_mm' \
+    'vmandnot_mm' \
+    'vmax_vv' \
+    'vmax_vx' \
+    'vmaxu_vv' \
+    'vmaxu_vx' \
+    'vmerge_vim' \
+    'vmerge_vvm' \
+    'vmerge_vxm' \
+    'vmfirst_m' \
+    'vmin_vv' \
+    'vmin_vx' \
+    'vminu_vv' \
+    'vminu_vx' \
+    'vmnand_mm' \
+    'vmnor_mm' \
+    'vmor_mm' \
+    'vmornot_mm' \
+    'vmpopc_m' \
+    'vmsbc_vvm' \
+    'vmsbc_vxm' \
+    'vmsbf_m' \
+    'vmseq_vi' \
+    'vmseq_vv' \
+    'vmseq_vx' \
+    'vmsgt_vi' \
+    'vmsgt_vx' \
+    'vmsgtu_vi' \
+    'vmsgtu_vx' \
+    'vmsif_m' \
+    'vmsle_vi' \
+    'vmsle_vv' \
+    'vmsle_vx' \
+    'vmsleu_vi' \
+    'vmsleu_vv' \
+    'vmsleu_vx' \
+    'vmslt_vv' \
+    'vmslt_vx' \
+    'vmsltu_vv' \
+    'vmsltu_vx' \
+    'vmsne_vi' \
+    'vmsne_vv' \
+    'vmsne_vx' \
+    'vmsof_m' \
+    'vmul_vv' \
+    'vmul_vx' \
+    'vmulh_vv' \
+    'vmulh_vx' \
+    'vmulhsu_vv' \
+    'vmulhsu_vx' \
+    'vmulhu_vv' \
+    'vmulhu_vx' \
+    'vmv_s_x' \
+    'vmv_v_i' \
+    'vmv_v_v' \
+    'vmv_v_x' \
+    'vmxnor_mm' \
+    'vmxor_mm' \
+    'vnclip_vi' \
+    'vnclip_vv' \
+    'vnclip_vx' \
+    'vnclipu_vi' \
+    'vnclipu_vv' \
+    'vnclipu_vx' \
+    'vnmsac_vv' \
+    'vnmsac_vx' \
+    'vnmsub_vv' \
+    'vnmsub_vx' \
+    'vnsra_vi' \
+    'vnsra_vv' \
+    'vnsra_vx' \
+    'vnsrl_vi' \
+    'vnsrl_vv' \
+    'vnsrl_vx' \
+    'vor_vi' \
+    'vor_vv' \
+    'vor_vx' \
+    'vredand_vs' \
+    'vredmax_vs' \
+    'vredmaxu_vs' \
+    'vredmin_vs' \
+    'vredminu_vs' \
+    'vredor_vs' \
+    'vredsum_vs' \
+    'vredxor_vs' \
+    'vrem_vv' \
+    'vrem_vx' \
+    'vremu_vv' \
+    'vremu_vx' \
+    'vrgather_vi' \
+    'vrgather_vv' \
+    'vrgather_vx' \
+    'vrsub_vi' \
+    'vrsub_vx' \
+    'vsadd_vi' \
+    'vsadd_vv' \
+    'vsadd_vx' \
+    'vsaddu_vi' \
+    'vsaddu_vv' \
+    'vsaddu_vx' \
+    'vsbc_vvm' \
+    'vsbc_vxm' \
+    'vslide1down_vx' \
+    'vslide1up_vx' \
+    'vslidedown_vi' \
+    'vslidedown_vx' \
+    'vslideup_vi' \
+    'vslideup_vx' \
+    'vsll_vi' \
+    'vsll_vv' \
+    'vsll_vx' \
+    'vsmul_vv' \
+    'vsmul_vx' \
+    'vsra_vi' \
+    'vsra_vv' \
+    'vsra_vx' \
+    'vsrl_vi' \
+    'vsrl_vv' \
+    'vsrl_vx' \
+    'vssra_vi' \
+    'vssra_vv' \
+    'vssra_vx' \
+    'vssrl_vi' \
+    'vssrl_vv' \
+    'vssrl_vx' \
+    'vssub_vv' \
+    'vssub_vx' \
+    'vssubu_vv' \
+    'vssubu_vx' \
+    'vsub_vv' \
+    'vsub_vx' \
+    'vwadd_vv' \
+    'vwadd_vx' \
+    'vwadd_wv' \
+    'vwadd_wx' \
+    'vwaddu_vv' \
+    'vwaddu_vx' \
+    'vwaddu_wv' \
+    'vwaddu_wx' \
+    'vwmacc_vv' \
+    'vwmacc_vx' \
+    'vwmaccsu_vv' \
+    'vwmaccsu_vx' \
+    'vwmaccu_vv' \
+    'vwmaccu_vx' \
+    'vwmaccus_vx' \
+    'vwmul_vv' \
+    'vwmul_vx' \
+    'vwmulsu_vv' \
+    'vwmulsu_vx' \
+    'vwmulu_vv' \
+    'vwmulu_vx' \
+    'vwredsum_vs' \
+    'vwredsumu_vs' \
+    'vwsmacc_vv' \
+    'vwsmacc_vx' \
+    'vwsmaccsu_vv' \
+    'vwsmaccsu_vx' \
+    'vwsmaccu_vv' \
+    'vwsmaccu_vx' \
+    'vwsmaccus_vx' \
+    'vwsub_vv' \
+    'vwsub_vx' \
+    'vwsub_wv' \
+    'vwsub_wx' \
+    'vwsubu_vv' \
+    'vwsubu_vx' \
+    'vwsubu_wv' \
+    'vwsubu_wx' \
+    'vxor_vi' \
+    'vxor_vv' \
+    'vxor_vx' \
+    'vfadd_vf' \
+    'vfadd_vv' \
+    'vfclass_v' \
+    'vfcvt_f_x_v' \
+    'vfcvt_f_xu_v' \
+    'vfcvt_x_f_v' \
+    'vfcvt_xu_f_v' \
+    'vfdiv_vf' \
+    'vfdiv_vv' \
+    'vfdot_vv' \
+    'vfmacc_vf' \
+    'vfmacc_vv' \
+    'vfmadd_vf' \
+    'vfmadd_vv' \
+    'vfmax_vf' \
+    'vfmax_vv' \
+    'vfmerge_vfm' \
+    'vfmin_vf' \
+    'vfmin_vv' \
+    'vfmsac_vf' \
+    'vfmsac_vv' \
+    'vfmsub_vf' \
+    'vfmsub_vv' \
+    'vfmul_vf' \
+    'vfmul_vv' \
+    'vfmv_f_s' \
+    'vfmv_s_f' \
+    'vfmv_v_f' \
+    'vfncvt_f_f_v' \
+    'vfncvt_f_x_v' \
+    'vfncvt_f_xu_v' \
+    'vfncvt_x_f_v' \
+    'vfncvt_xu_f_v' \
+    'vfnmacc_vf' \
+    'vfnmacc_vv' \
+    'vfnmadd_vf' \
+    'vfnmadd_vv' \
+    'vfnmsac_vf' \
+    'vfnmsac_vv' \
+    'vfnmsub_vf' \
+    'vfnmsub_vv' \
+    'vfrdiv_vf' \
+    'vfredmax_vs' \
+    'vfredmin_vs' \
+    'vfredosum_vs' \
+    'vfredsum_vs' \
+    'vfrsub_vf' \
+    'vfsgnj_vf' \
+    'vfsgnj_vv' \
+    'vfsgnjn_vf' \
+    'vfsgnjn_vv' \
+    'vfsgnjx_vf' \
+    'vfsgnjx_vv' \
+    'vfsqrt_v' \
+    'vfsub_vf' \
+    'vfsub_vv' \
+    'vfwadd_vf' \
+    'vfwadd_vv' \
+    'vfwadd_wf' \
+    'vfwadd_wv' \
+    'vfwcvt_f_f_v' \
+    'vfwcvt_f_x_v' \
+    'vfwcvt_f_xu_v' \
+    'vfwcvt_x_f_v' \
+    'vfwcvt_xu_f_v' \
+    'vfwmacc_vf' \
+    'vfwmacc_vv' \
+    'vfwmsac_vf' \
+    'vfwmsac_vv' \
+    'vfwmul_vf' \
+    'vfwmul_vv' \
+    'vfwnmacc_vf' \
+    'vfwnmacc_vv' \
+    'vfwnmsac_vf' \
+    'vfwnmsac_vv' \
+    'vfwredosum_vs' \
+    'vfwredsum_vs' \
+    'vfwsub_vf' \
+    'vfwsub_vv' \
+    'vfwsub_wf' \
+    'vfwsub_wv' \
+    'vmfeq_vf' \
+    'vmfeq_vv' \
+    'vmfge_vf' \
+    'vmfgt_vf' \
+    'vmfle_vf' \
+    'vmfle_vv' \
+    'vmflt_vf' \
+    'vmflt_vv' \
+    'vmfne_vf' \
+    'vmfne_vv' \
+    'vmford_vf' \
+    'vmford_vv' \
+    'vlb_v' \
+    'vlh_v' \
+    'vlw_v' \
+    'vle_v' \
+    'vlbu_v' \
+    'vlhu_v' \
+    'vlwu_v' \
+    'vlsb_v' \
+    'vlsh_v' \
+    'vlsw_v' \
+    'vlse_v' \
+    'vlxb_v' \
+    'vlxh_v' \
+    'vlxw_v' \
+    'vlxe_v' \
+    'vlsbu_v' \
+    'vlshu_v' \
+    'vlswu_v' \
+    'vlxbu_v' \
+    'vlxhu_v' \
+    'vlxwu_v' \
+    'vlbff_v' \
+    'vlhff_v' \
+    'vlwff_v' \
+    'vleff_v' \
+    'vlbuff_v' \
+    'vlhuff_v' \
+    'vlwuff_v' \
+    'vsb_v' \
+    'vsh_v' \
+    'vsw_v' \
+    'vse_v' \
+    'vssb_v' \
+    'vssh_v' \
+    'vssw_v' \
+    'vsse_v' \
+    'vsxb_v' \
+    'vsxh_v' \
+    'vsxw_v' \
+    'vsxe_v' \
+    'vsuxb_v' \
+    'vsuxh_v' \
+    'vsuxw_v' \
+    'vsuxe_v' \
+    'vsetvli' \
+    'vsetvl' \
+    'vamoaddd_v' \
+    'vamoandd_v' \ 
+    'vamomaxd_v' \
+    'vamomaxuw_v' \ 
+    'vamomind_v' \
+    'vamominuw_v' \
+    'vamoord_v' \
+    'vamoswapd_v' \
+    'vamoxord_v' \
+    'vamoaddw_v' \
+    'vamoandw_v' \
+    'vamomaxud_v' \
+    'vamomaxw_v' \
+    'vamominud_v' \
+    'vamominw_v' \
+    'vamoorw_v' \
+    'vamoswapw_v' \
+    'vamoxorw_v' \
+);
+f_insns=( 'fadd_s' \
+    'fclass_s' \
+    'fcvt_l_s' \
+    'fcvt_lu_s' \
+    'fcvt_s_l' \
+    'fcvt_s_lu' \
+    'fcvt_s_w' \
+    'fcvt_s_wu' \
+    'fcvt_w_s' \
+    'fcvt_wu_s' \
+    'fdiv_s' \
+    'feq_s' \
+    'fle_s' \
+    'flt_s' \
+    'flw' \
+    'fmadd_s' \
+    'fmax_s' \
+    'fmin_s' \
+    'fmsub_s' \
+    'fmul_s' \
+    'fmv_w_x' \
+    'fmv_x_w' \
+    'fnmadd_s' \
+    'fnmsub_s' \
+    'fsgnj_s' \
+    'fsgnjn_s' \
+    'fsgnjx_s' \
+    'fsqrt_s' \
+    'fsub_s' \
+    'fsw' \
+    'fadd_d' \
+    'fclass_d' \
+    'fcvt_d_l' \
+    'fcvt_d_lu' \
+    'fcvt_d_q' \
+    'fcvt_d_s' \
+    'fcvt_d_w' \
+    'fcvt_d_wu' \
+    'fcvt_l_d' \
+    'fcvt_lu_d' \
+    'fcvt_s_d' \
+    'fcvt_w_d' \
+    'fcvt_wu_d' \
+    'fdiv_d' \
+    'feq_d' \
+    'fld' \
+    'fle_d' \
+    'flt_d' \
+    'fmadd_d' \
+    'fmax_d' \
+    'fmin_d' \
+    'fmsub_d' \
+    'fmul_d' \
+    'fmv_d_x' \
+    'fmv_x_d' \
+    'fnmadd_d' \
+    'fnmsub_d' \
+    'fsd' \
+    'fsgnj_d' \
+    'fsgnjn_d' \
+    'fsgnjx_d' \
+    'fsqrt_d' \
+    'fsub_d' \
+    'fadd_q' \
+    'fclass_q' \
+    'fcvt_l_q' \
+    'fcvt_lu_q' \
+    'fcvt_q_d' \
+    'fcvt_q_l' \
+    'fcvt_q_lu' \
+    'fcvt_q_s' \
+    'fcvt_q_w' \
+    'fcvt_q_wu' \
+    'fcvt_s_q' \
+    'fcvt_w_q' \
+    'fcvt_wu_q' \
+    'fgidiv_q' \
+    'feq_q' \
+    'fle_q' \
+    'flq' \
+    'flt_q' \
+    'fmadd_q' \
+    'fmax_q' \
+    'fmin_q' \
+    'fmsub_q' \
+    'fmul_q' \
+    'fnmadd_q' \
+    'fnmsub_q' \
+    'fsgnj_q' \
+    'fsgnjn_q' \
+    'fsgnjx_q' \
+    'fsq' \
+    'fsqrt_q' \
+    'fsub_q' \
+);
+
+rm ./insns/*
+echo '/*generated by shell*/' > insn_list.h
+echo '# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the RISC-V Linux kernel
+#
+' > ./insns/Makefile
+for i in ${insns[@]}; do
+        if [ -f ./insns_func/$i.h ] ; then
+             match=$(get_opcode ./encoding.h $i)
+             #echo $i,'s/NAME/'$i'/g', $match,. 's/OPCODE/'$match'/', ./insns/$i.c
+             touch ./insns/$i.c
+             sed 's/NAME/'$i'/g' ./insn_template.c | sed 's/OPCODE/'$match'/g' >&./insns/$i.c
+             echo 'DEFINE_INSN('$i')' >> insn_list.h 
+             echo 'obj-$(CONFIG_VECTOR_EMU)    += '$i.o >> ./insns/Makefile
+        else
+        	echo 'not find', $i
+        fi
+done
+
+if [ -f ./insns/.c ]; then
+    rm ./insns/.c
+fi
diff --git a/arch/riscv/kernel/soft_vector/arith.h b/arch/riscv/kernel/soft_vector/arith.h
new file mode 100644
index 000000000000..02b2c7de49df
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/arith.h
@@ -0,0 +1,75 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#ifndef _RISCV_ARITH_H
+#define _RISCV_ARITH_H
+
+inline uint64_t mulhu(uint64_t a, uint64_t b);
+
+inline int64_t mulh(int64_t a, int64_t b);
+
+inline int64_t mulhsu(int64_t a, uint64_t b);
+
+//ref:  https://locklessinc.com/articles/sat_arithmetic/
+#define sat_add(T, UT) \
+inline T sat_add_##T##_##UT(T x, T y, bool *sat);
+
+sat_add(int8_t, uint8_t)
+sat_add(int16_t, uint16_t)
+sat_add(int32_t, uint32_t)
+sat_add(int64_t, uint64_t)
+#undef sat_add
+
+#define sat_sub(T, UT) \
+inline T sat_sub_##T##_##UT(T x, T y, bool *sat);
+
+sat_sub(int8_t, uint8_t)
+sat_sub(int16_t, uint16_t)
+sat_sub(int32_t, uint32_t)
+sat_sub(int64_t, uint64_t)
+#undef sat_sub
+
+#define sat_addu(T) \
+T sat_addu_##T(T x, T y, bool *sat);
+
+sat_addu(uint8_t)
+sat_addu(uint16_t)
+sat_addu(uint32_t)
+sat_addu(uint64_t)
+#undef sat_addu
+
+#define sat_subu(T) \
+T sat_subu_##T(T x, T y, bool *sat);
+
+sat_subu(uint8_t)
+sat_subu(uint16_t)
+sat_subu(uint32_t)
+sat_subu(uint64_t)
+#undef sat_subu
+#endif
diff --git a/arch/riscv/kernel/soft_vector/decode.c b/arch/riscv/kernel/soft_vector/decode.c
new file mode 100644
index 000000000000..f0a4f44d3df0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/decode.c
@@ -0,0 +1,601 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include <linux/uaccess.h>
+#include <asm/switch_to.h>
+#include <asm/csr.h>
+#include "riscv_decode.h"
+#include "arith.h"
+#define vector_elt(type) \
+        type * vector_elt_##type(vector_state* vector, reg_t vReg, reg_t n){ \
+          reg_t elts_per_reg;\
+          type *regStart;\
+          require(vector->vsew != 0); \
+          require((vector->VLEN >> 3)/sizeof(type) > 0); \
+          elts_per_reg = (vector->VLEN >> 3) / (sizeof(type)); \
+          vReg += n / elts_per_reg; \
+          n = n % elts_per_reg; \
+          regStart = (type*)((char*)vector->regs + vReg * (vector->VLEN >> 3)); \
+          return &regStart[n]; \
+        } \
+
+vector_elt(float32_t)
+vector_elt(float64_t)
+vector_elt(int8_t)
+vector_elt(int16_t)
+vector_elt(int32_t)
+vector_elt(int64_t)
+vector_elt(uint8_t)
+vector_elt(uint16_t)
+vector_elt(uint32_t)
+vector_elt(uint64_t)
+
+#define load_store(type) \
+      type##_t load_##type(reg_t addr) { \
+          type##_t tmp; \
+          type##_t __user *in; \
+          long err; \
+          in = (type##_t __user *)addr; \
+          err = __copy_from_user(&tmp, in , sizeof(type##_t)); \
+	      if (unlikely(err)) \
+		      panic("load memory error\n"); \
+          return tmp; \
+      } \
+      \
+      void store_##type(reg_t addr, type##_t val) { \
+          type##_t __user *out; \
+          long err; \
+          out = (type##_t __user *)addr; \
+          err = __copy_to_user(out, &val, sizeof(type##_t)); \
+	      if (unlikely(err)) \
+		      panic("store memory error\n"); \
+          return; \
+      } \
+      
+load_store(uint8)
+load_store(uint16)
+load_store(uint32)
+load_store(uint64)
+
+load_store(int8)
+load_store(int16)
+load_store(int32)
+load_store(int64)
+
+inline uint64_t x(insn_t b, int lo, int len) { return (b >> lo) & (((insn_bits_t)1 << len)-1); }
+inline uint64_t xs(insn_t b, int lo, int len) { return (int64_t)b << (64-lo-len) >> (64-len); }
+inline uint64_t imm_sign(insn_t b) { return xs(b, 63, 1); }
+inline int length(insn_t b) { return insn_length(b); }
+inline int64_t i_imm(insn_t b) { return (int64_t)b >> 20; }
+inline int64_t shamt(insn_t b) { return x(b, 20, 6); }
+inline int64_t s_imm(insn_t b) { return x(b, 7, 5) + (xs(b, 25, 7) << 5); }
+inline int64_t sb_imm(insn_t b) { return (x(b, 8, 4) << 1) + (x(b, 25,6) << 5) + (x(b, 7,1) << 11) + (imm_sign(b) << 12); }
+inline int64_t u_imm(insn_t b) { return (int64_t)b >> 12 << 12; }
+inline int64_t uj_imm(insn_t b) { return (x(b, 21, 10) << 1) + (x(b, 20, 1) << 11) + (x(b, 12, 8) << 12) + (imm_sign(b) << 20); }
+inline uint64_t rd(insn_t b) { return x(b, 7, 5); }
+inline uint64_t insn_rs1(insn_t b) { return x(b, 15, 5); }
+inline uint64_t rs2(insn_t b) { return x(b, 20, 5); }
+inline uint64_t rs3(insn_t b) { return x(b, 27, 5); }
+inline uint64_t rm(insn_t b) { return x(b, 12, 3); }
+inline uint64_t csr(insn_t b) { return x(b, 20, 12); }
+
+inline uint64_t v_vm(insn_t b) { return x(b, 25, 1); }
+inline uint64_t v_wd(insn_t b) { return x(b, 26, 1); }
+inline uint64_t v_nf(insn_t b) { return x(b, 29, 3); }
+inline uint64_t v_simm5(insn_t b) { return xs(b, 15, 5); }
+inline uint64_t v_zimm5(insn_t b) { return x(b, 15, 5); }
+inline uint64_t v_zimm11(insn_t b) { return x(b, 20, 11); }
+inline uint64_t v_lmul(insn_t b) { return 1 << x(b, 20, 2); }
+inline uint64_t v_sew(insn_t b) { return 1 << (x(b, 22, 3) + 3); }
+
+extern unsigned long elf_hwcap;
+bool supports_extension(processor_t * state, unsigned char ext) {
+  if (ext >= 'A' && ext <= 'Z')
+    return ((elf_hwcap >> (ext - 'A')) & 1);
+  return false;
+}
+
+int get_flen(processor_t * state) {
+    return supports_extension(state, 'Q') ? 128 :
+           supports_extension(state, 'D') ? 64 :
+           supports_extension(state, 'F') ? 32 : 0;
+}
+
+inline float128_t defaultNaNF128(void)
+{
+  float128_t nan;
+  nan.v[1] = defaultNaNF128UI64;
+  nan.v[0] = defaultNaNF128UI0;
+  return nan;
+}
+inline freg_t fsgnj128(freg_t a, freg_t b, bool n, bool x)
+{
+  a.v[1] = (a.v[1] & ~F64_SIGN) | (((x ? a.v[1] : n ? F64_SIGN : 0) ^ b.v[1]) & F64_SIGN);
+  return a;
+}
+inline freg_t f128_negate(freg_t a)
+{
+  a.v[1] ^= F64_SIGN;
+  return a;
+}
+
+inline float32_t f32(uint32_t v) { return (float32_t){v}; }
+inline float64_t f64(uint64_t v) { return (float64_t){v}; }
+inline float32_t f32_f(freg_t r) { return f32(unboxF32(r)); }
+inline float64_t f64_f(freg_t r) { return f64(unboxF64(r)); }
+inline float128_t f128(freg_t r) { return r; }
+inline freg_t freg32(float32_t f) { return (float128_t){{((uint64_t)-1 << 32) | f.v, (uint64_t)-1}};}
+inline freg_t freg64(float64_t f) { return (float128_t){{f.v, (uint64_t)-1}};}
+inline freg_t freg128(float128_t f) { return f; }
+
+inline int max_internal(int a, int b) {return a > b? a : b;}
+inline int min_internal(int a, int b) {return a > b? b : a;}
+
+inline bool is_overlaped(const int astart, const int asize,
+                                const int bstart, const int bsize)
+{
+  const int aend = astart + asize;
+  const int bend = bstart + bsize;
+  return max_internal(aend, bend) - min_internal(astart, bstart) < asize + bsize;
+}
+
+reg_t set_vl(vector_state *vector, uint64_t regId, reg_t reqVL, reg_t newType){
+  if (vector->vtype != newType){
+    vector->vtype = newType;
+    vector->vsew = 1 << (BITS(newType, 4, 2) + 3);
+    vector->vlmul = 1 << BITS(newType, 1, 0);
+    vector->vediv = 1 << BITS(newType, 6, 5);
+    vector->vlmax = vector->VLEN/vector->vsew * vector->vlmul;
+    vector->vmlen = vector->vsew / vector->vlmul;
+    vector->reg_mask = (NVPR-1) & ~(vector->vlmul-1);
+    vector->vill = false;
+  }
+  vector->vl = reqVL <= vector->vlmax ? (regId == 0)? vector->vlmax: reqVL : vector->vlmax;
+  vector->vstart = 0;
+  return vector->vl;
+}
+
+inline uint64_t mulhu(uint64_t a, uint64_t b)
+{
+  uint64_t t, a0, b0, a1, b1;
+  uint32_t y1, y2, y3;
+  a0 = (uint32_t)a;
+  a1 = a >> 32;
+  b0 = (uint32_t)b;
+  b1 = b >> 32;
+
+  t = a1*b0 + ((a0*b0) >> 32);
+  y1 = t;
+  y2 = t >> 32;
+
+  t = a0*b1 + y1;
+  y1 = t;
+
+  t = a1*b1 + y2 + (t >> 32);
+  y2 = t;
+  y3 = t >> 32;
+
+  return ((uint64_t)y3 << 32) | y2;
+}
+
+inline int64_t mulh(int64_t a, int64_t b)
+{
+  int negate;
+  uint64_t res;
+  negate  = (a < 0) != (b < 0);
+  res = mulhu(a < 0 ? -a : a, b < 0 ? -b : b);
+  return negate ? ~res + (a * b == 0) : res;
+}
+
+inline int64_t mulhsu(int64_t a, uint64_t b)
+{
+  int negate;
+  uint64_t res;
+  negate = a < 0;
+  res = mulhu(a < 0 ? -a : a, b);
+  return negate ? ~res + (a * b == 0) : res;
+}
+
+//ref:  https://locklessinc.com/articles/sat_arithmetic/
+#define sat_add(T, UT) \
+inline T sat_add_##T##_##UT(T x, T y, bool *sat) \
+{ \
+  UT ux, uy, res;\
+  int sh; \
+  ux = x; \
+  uy = y; \
+  res = ux + uy; \
+  *sat = false; \
+  sh = sizeof(T) * 8 - 1; \
+  \
+  /* Calculate overflowed result. (Don't change the sign bit of ux) */ \
+  ux = (ux >> sh) + (((UT)0x1 << sh) - 1); \
+  \
+  /* Force compiler to use cmovns instruction */ \
+  if ((T) ((ux ^ uy) | ~(uy ^ res)) >= 0) { \
+    res = ux; \
+    *sat = true; \
+  } \
+  \
+  return res; \
+}
+
+sat_add(int8_t, uint8_t)
+sat_add(int16_t, uint16_t)
+sat_add(int32_t, uint32_t)
+sat_add(int64_t, uint64_t)
+#undef sat_add
+
+#define sat_sub(T, UT) \
+inline T sat_sub_##T##_##UT(T x, T y, bool *sat) { \
+  UT ux, uy, res; \
+  int sh; \
+  ux = x; \
+  uy = y; \
+  res = ux - uy; \
+  *sat = false; \
+  sh  = sizeof(T) * 8 - 1; \
+  \
+  /* Calculate overflowed result. (Don't change the sign bit of ux) */ \
+  ux = (ux >> sh) + (((UT)0x1 << sh) - 1); \
+  \
+  /* Force compiler to use cmovns instruction */ \
+  if ((T) ((ux ^ uy) & (ux ^ res)) < 0) { \
+    res = ux; \
+    *sat = true; \
+  } \
+  \
+  return res; \
+}
+
+sat_sub(int8_t, uint8_t)
+sat_sub(int16_t, uint16_t)
+sat_sub(int32_t, uint32_t)
+sat_sub(int64_t, uint64_t)
+#undef sat_sub
+
+#define sat_addu(T) \
+T sat_addu_##T(T x, T y, bool *sat) { \
+  T res; \
+  res = x + y; \
+  *sat = false; \
+  \
+  *sat = res < x; \
+  res |= -(res < x); \
+  \
+  return res; \
+}
+
+sat_addu(uint8_t)
+sat_addu(uint16_t)
+sat_addu(uint32_t)
+sat_addu(uint64_t)
+#undef sat_addu
+
+#define sat_subu(T) \
+T sat_subu_##T(T x, T y, bool *sat) { \
+  T res; \
+  res = x - y; \
+  *sat = false; \
+  \
+  *sat = !(res <= x); \
+  res &= -(res <= x); \
+  \
+  return res; \
+}
+
+sat_subu(uint8_t)
+sat_subu(uint16_t)
+sat_subu(uint32_t)
+sat_subu(uint64_t)
+#undef sat_subu
+
+inline int get_xlen(void)
+{
+   return 64;// to fix
+}
+
+inline int get_max_xlen(void)
+{
+   return 64;//to fix
+}
+
+typedef reg_t (*insn_func_t)(processor_t* p, insn_t insn);
+typedef struct
+{
+  insn_bits_t match;
+  insn_bits_t mask;
+  insn_func_t rv32;
+  insn_func_t rv64;
+} insn_desc_t;
+#ifndef INSN_REG
+#define DECLARE_INSN(name, match, mask) \
+		{match, mask, rv32_##name, rv64_##name},
+insn_desc_t insts[] = {
+	#include "encoding.h"
+	{0,0, NULL, NULL}
+};
+#undef DECLARE_INSN
+#else
+insn_desc_t insts[1000];
+static int idx = 0;
+
+void register_insn( insn_bits_t match, insn_bits_t mask, insn_func_t rv32, insn_func_t rv64)
+{
+  insts[idx].match = match;
+  insts[idx].mask = mask;
+  insts[idx].rv32 = rv32;
+  insts[idx].rv64 = rv64;
+  idx++;
+}
+
+#define REGISTER_INSN(name, match, mask) \
+  register_insn(match, mask, rv32_##name, rv64_##name);
+
+void register_base_instructions(void)
+{
+  pr_info("register base %x, %d\n", insts, sizeof(insn_desc_t));
+  #define DECLARE_INSN(name, match, mask) \
+    insn_bits_t name##_match , name##_mask; \
+    name##_match = (match); \
+    name##_mask = (mask);
+  #include "encoding.h"
+  #undef DECLARE_INSN
+
+  #define DEFINE_INSN(name) \
+    REGISTER_INSN(name, name##_match, name##_mask)
+  #include "insn_list.h"
+  #undef DEFINE_INSN
+
+  register_insn(0, 0, NULL, NULL);
+  pr_info("idx: %d\n", idx);
+}
+#endif
+#define MAX_SEARCH_INSNS 100
+#define GCC_SUPPORT_VSETVL
+//#define GCC_SUPPORT_VSETVL
+//#define DEBUG_SOFT_VECTER
+int back_search_vsetvl(struct pt_regs *regs, processor_t *state, insn_t vinsn) {
+#ifdef GCC_SUPPORT_VSETVL
+    uint32_t insn;
+    uint32_t __user *in;
+    processor_t *p = state;
+    reg_t addr;
+	long err;
+	if (vinsn != 0x32002057) { //vmv.x.s	zero,v0
+		set_vl(VECTOR, current->thread.vsetvl_state.regid, current->thread.vsetvl_state.vl, current->thread.vsetvl_state.vtype);
+		return 1;
+	} else {
+		addr = regs->epc - 4;
+		in = (uint32_t __user *)addr;
+		err = __copy_from_user(&insn, in , sizeof(uint32_t));
+		if (unlikely(err)) { // cannot fetch insns
+			printk("cannot fetch vsetvl insn, default:use last vsetvl info\n");
+			set_vl(VECTOR, current->thread.vsetvl_state.regid, current->thread.vsetvl_state.vl, current->thread.vsetvl_state.vtype);
+			return 1;
+		}
+		if ((insn & MASK_VSETVLI) == MATCH_VSETVLI) {
+			WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, v_zimm11(insn)));
+			current->thread.vsetvl_state.last_vector_pc = regs->epc;
+			current->thread.vsetvl_state.regid = insn_rs1(insn);
+			current->thread.vsetvl_state.vl = VECTOR->vl;
+			current->thread.vsetvl_state.vtype = VECTOR->vtype;
+			return 1;
+		} else if((insn & MASK_VSETVL) == MATCH_VSETVL) {
+			WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, RS2));
+			current->thread.vsetvl_state.last_vector_pc = regs->epc;
+			current->thread.vsetvl_state.regid = insn_rs1(insn);
+			current->thread.vsetvl_state.vl = VECTOR->vl;
+			current->thread.vsetvl_state.vtype = VECTOR->vtype;
+			return 1;
+		} else {// possible c-ext insns
+			printk("cannot find vsetvl insn, default:use last vsetvl info\n");
+			set_vl(VECTOR, current->thread.vsetvl_state.regid, current->thread.vsetvl_state.vl, current->thread.vsetvl_state.vtype);
+			return 1;
+		}
+	}
+
+#else
+	reg_t addr;
+	uint8_t match = 0;
+	reg_t pos_list[MAX_SEARCH_INSNS];
+	uint8_t pos_list_insn[MAX_SEARCH_INSNS];
+	uint8_t pos_num;
+	uint8_t insn_count = 0;
+    uint32_t insn;
+    uint32_t __user *in;
+	long err;
+	processor_t* p = state;
+    pos_list[0] = regs->epc - 4;
+    pos_list_insn[0] = 0;
+    pos_num = 1;
+	do {
+		addr = pos_list[--pos_num];
+		insn_count = pos_list_insn[pos_num];
+		do { // search one insn per loop
+			if (addr == current->thread.vsetvl_state.last_vector_pc) {// match last setvl
+				set_vl(VECTOR, current->thread.vsetvl_state.regid, current->thread.vsetvl_state.vl, current->thread.vsetvl_state.vtype);
+				current->thread.vsetvl_state.last_vector_pc = regs->epc;
+				match = 1;
+				break;
+			}
+			in = (uint32_t __user *)addr;
+			err = __copy_from_user(&insn, in , sizeof(uint32_t));
+			if (unlikely(err)) // cannot fetch insns
+				break;
+			if((insn & 0x3) == 3) { // possible 32-bit insn
+				if ((insn & MASK_VSETVLI) == MATCH_VSETVLI) {
+					WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, v_zimm11(insn)));
+					current->thread.vsetvl_state.last_vector_pc = regs->epc;
+					current->thread.vsetvl_state.regid = insn_rs1(insn);
+					current->thread.vsetvl_state.vl = VECTOR->vl;
+					current->thread.vsetvl_state.vtype = VECTOR->vtype;
+					match = 1;
+					break;
+				} else if((insn & MASK_VSETVL) == MATCH_VSETVL) {
+					WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, RS2));
+					current->thread.vsetvl_state.last_vector_pc = regs->epc;
+					current->thread.vsetvl_state.regid = insn_rs1(insn);
+					current->thread.vsetvl_state.vl = VECTOR->vl;
+					current->thread.vsetvl_state.vtype = VECTOR->vtype;
+					match = 1;
+					break;
+				} else if (((insn >> 16) & 0x3) != 3) {// possible c-ext insns
+					pos_list[pos_num] =  addr - 4;
+					pos_list_insn[pos_num++] = insn_count + 1;
+					addr = addr - 2;
+					insn_count++;
+					continue;
+				}
+				insn_count++;
+				addr = addr - 4;
+			} else if (((insn >> 16) & 0x3) != 3) { // c-ext insn
+				addr = addr - 2;
+				insn_count++;
+				continue;
+			} else //illegal insn
+				break;
+		} while (insn_count < MAX_SEARCH_INSNS); //search 100 insns at most
+		if (match) {
+			break;
+		}
+	} while(pos_num > 0);
+	return match;
+#endif
+}
+
+int get_processor_state(struct pt_regs *regs, processor_t * state, insn_t insn) {
+  int i;
+#ifdef DEBUG_SOFT_VECTER
+  unsigned long *origin = (unsigned long *)&(regs->epc);
+#endif
+  state->pc = regs->epc;
+  state->XPR[0] = 0;
+  memcpy (&(state->XPR[1]), &(regs->ra), 31 * sizeof(unsigned long));
+  state->saved_a0 = state->XPR[10];
+  state->XPR[10] = regs->orig_a0;
+  state->mstatus = regs->status;
+  if (has_fpu) {
+	fstate_save(current, regs);
+    for (i = 0; i < 32; i++) {
+      state->FPR[i] = freg64(f64(current->thread.fstate.f[i]));
+      state->frm = (current->thread.fstate.fcsr >> 5) & 0x7;
+      state->fflags = (current->thread.fstate.fcsr & 0x1f);
+    }
+  }
+  if (has_vector) {
+	vstate_save(current, regs);
+    state->vector.VLEN = 128; //to fix
+    state->vector.ELEN = 64;  //to fix
+    state->vector.SLEN = 128;  //to fix
+    {
+		for (i = 0; i < 32; i++) {
+		  state->vector.regs[i] = current->thread.vstate.v[i];
+		}
+    }
+    state->vector.vstart = current->thread.vstate.vstart;
+    state->vector.vxrm = current->thread.vstate.vxrm;
+    state->vector.vxsat = current->thread.vstate.vxsat;
+	state->vector.vl = current->thread.vstate.vl;
+    state->vector.vtype = current->thread.vstate.vtype;
+    state->vector.vill = BITS(state->vector.vtype, (get_xlen() - 1), (get_xlen() - 1));
+    if (state->vector.vill != 0) {
+    	if (back_search_vsetvl(regs, state, insn) != 1) {
+    		printk("ERROR: cannot find related vsetvl\n");
+    		return 1;
+    	}
+    } else {
+		state->vector.vsew = 1 << (BITS(state->vector.vtype, 4, 2) + 3);
+		state->vector.vlmul = 1 << BITS(state->vector.vtype, 1, 0);
+		state->vector.vediv = 1 << BITS(state->vector.vtype, 6, 5);
+		state->vector.vlmax = state->vector.VLEN/state->vector.vsew * state->vector.vlmul;
+		state->vector.vmlen = state->vector.vsew / state->vector.vlmul;
+		state->vector.reg_mask = (NVPR-1) & ~(state->vector.vlmul-1);
+    }
+  }
+  return 0;
+}
+
+void restore_processor_state(struct pt_regs *regs, processor_t * state) {
+	int i;
+	memcpy (&(regs->ra), &(state->XPR[1]), 31 * sizeof(unsigned long));
+	if (state->XPR[10] == regs->orig_a0)
+		regs->a0 = state->saved_a0;
+	regs->status = state->mstatus;
+	if (has_fpu) {
+		for (i = 0; i < 32; i++) {
+			current->thread.fstate.f[i] = state->FPR[i].v[0];
+		}
+		current->thread.fstate.fcsr = (state->frm << 5) | state->fflags;
+		fstate_restore(current, regs);
+	}
+	if (has_vector) {
+		for (i = 0; i < 32; i++) {
+		   current->thread.vstate.v[i] = state->vector.regs[i];
+		}
+		current->thread.vstate.vstart = state->vector.vstart;
+		current->thread.vstate.vxrm = state->vector.vxrm;
+		current->thread.vstate.vxsat = state->vector.vxsat;
+		current->thread.vstate.vl = state->vector.vl;
+		current->thread.vstate.vtype = state->vector.vtype;
+	}
+	regs->epc = state->pc;
+	vstate_restore(current, regs);
+}
+
+bool decode_exec_insn(struct pt_regs *regs, insn_t insn)
+{
+	processor_t state;
+	insn_desc_t *p;
+	reg_t len;
+#ifdef INSN_REG
+	if (idx == 0) register_base_instructions();
+#endif
+	p = & insts[0];
+    if (get_processor_state(regs, &state, insn))
+    	return false;
+    if (insn == 0x32002057) {
+		state.pc += 4;
+		restore_processor_state(regs, &state);
+		return true;
+    }
+    while (p->rv64 && ((insn & p->mask) != p->match))
+    	p++;
+    if (p->rv64) {
+    	if ((len = p->rv64(&state, insn))) {
+    		state.pc += len;
+    		restore_processor_state(regs, &state);
+    		return true;
+    	}
+    	pr_info("exec insn fail %llx %lx\n", insn, regs->epc);
+   } else
+	    pr_info("decode insn %llx %lx fail\n", insn, regs->epc);
+
+   return false;
+}
diff --git a/arch/riscv/kernel/soft_vector/encoding.h b/arch/riscv/kernel/soft_vector/encoding.h
new file mode 100644
index 000000000000..23bbe38eb6dc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/encoding.h
@@ -0,0 +1,1451 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#ifndef RISCV_CSR_ENCODING_H
+#define RISCV_CSR_ENCODING_H
+
+#define MSTATUS_UIE         0x00000001
+#define MSTATUS_SIE         0x00000002
+#define MSTATUS_HIE         0x00000004
+#define MSTATUS_MIE         0x00000008
+#define MSTATUS_UPIE        0x00000010
+#define MSTATUS_SPIE        0x00000020
+#define MSTATUS_HPIE        0x00000040
+#define MSTATUS_MPIE        0x00000080
+#define MSTATUS_SPP         0x00000100
+#define MSTATUS_HPP         0x00000600
+#define MSTATUS_MPP         0x00001800
+#define MSTATUS_FS          0x00006000
+#define MSTATUS_XS          0x00018000
+#define MSTATUS_MPRV        0x00020000
+#define MSTATUS_SUM         0x00040000
+#define MSTATUS_MXR         0x00080000
+#define MSTATUS_TVM         0x00100000
+#define MSTATUS_TW          0x00200000
+#define MSTATUS_TSR         0x00400000
+#define MSTATUS32_SD        0x80000000
+#define MSTATUS_UXL         0x0000000300000000
+#define MSTATUS_SXL         0x0000000C00000000
+#define MSTATUS64_SD        0x8000000000000000
+
+#define SSTATUS_UIE         0x00000001
+#define SSTATUS_SIE         0x00000002
+#define SSTATUS_UPIE        0x00000010
+#define SSTATUS_SPIE        0x00000020
+#define SSTATUS_SPP         0x00000100
+#define SSTATUS_FS          0x00006000
+#define SSTATUS_XS          0x00018000
+#define SSTATUS_SUM         0x00040000
+#define SSTATUS_MXR         0x00080000
+#define SSTATUS32_SD        0x80000000
+#define SSTATUS_UXL         0x0000000300000000
+#define SSTATUS64_SD        0x8000000000000000
+#endif
+/* Automatically generated by parse-opcodes.  */
+#ifndef RISCV_ENCODING_H
+#define RISCV_ENCODING_H
+#define MATCH_VSETVLI 0x7057
+#define MASK_VSETVLI  0x8000707f
+#define MATCH_VSETVL 0x80007057
+#define MASK_VSETVL  0xfe00707f
+#define MATCH_VLB_V 0x10000007
+#define MASK_VLB_V  0x1df0707f
+#define MATCH_VLH_V 0x10005007
+#define MASK_VLH_V  0x1df0707f
+#define MATCH_VLW_V 0x10006007
+#define MASK_VLW_V  0x1df0707f
+#define MATCH_VLE_V 0x7007
+#define MASK_VLE_V  0x1df0707f
+#define MATCH_VLBU_V 0x7
+#define MASK_VLBU_V  0x1df0707f
+#define MATCH_VLHU_V 0x5007
+#define MASK_VLHU_V  0x1df0707f
+#define MATCH_VLWU_V 0x6007
+#define MASK_VLWU_V  0x1df0707f
+#define MATCH_VSB_V 0x27
+#define MASK_VSB_V  0x1df0707f
+#define MATCH_VSH_V 0x5027
+#define MASK_VSH_V  0x1df0707f
+#define MATCH_VSW_V 0x6027
+#define MASK_VSW_V  0x1df0707f
+#define MATCH_VSE_V 0x7027
+#define MASK_VSE_V  0x1df0707f
+#define MATCH_VLSB_V 0x18000007
+#define MASK_VLSB_V  0x1c00707f
+#define MATCH_VLSH_V 0x18005007
+#define MASK_VLSH_V  0x1c00707f
+#define MATCH_VLSW_V 0x18006007
+#define MASK_VLSW_V  0x1c00707f
+#define MATCH_VLSE_V 0x8007007
+#define MASK_VLSE_V  0x1c00707f
+#define MATCH_VLSBU_V 0x8000007
+#define MASK_VLSBU_V  0x1c00707f
+#define MATCH_VLSHU_V 0x8005007
+#define MASK_VLSHU_V  0x1c00707f
+#define MATCH_VLSWU_V 0x8006007
+#define MASK_VLSWU_V  0x1c00707f
+#define MATCH_VSSB_V 0x8000027
+#define MASK_VSSB_V  0x1c00707f
+#define MATCH_VSSH_V 0x8005027
+#define MASK_VSSH_V  0x1c00707f
+#define MATCH_VSSW_V 0x8006027
+#define MASK_VSSW_V  0x1c00707f
+#define MATCH_VSSE_V 0x8007027
+#define MASK_VSSE_V  0x1c00707f
+#define MATCH_VLXB_V 0x1c000007
+#define MASK_VLXB_V  0x1c00707f
+#define MATCH_VLXH_V 0x1c005007
+#define MASK_VLXH_V  0x1c00707f
+#define MATCH_VLXW_V 0x1c006007
+#define MASK_VLXW_V  0x1c00707f
+#define MATCH_VLXE_V 0xc007007
+#define MASK_VLXE_V  0x1c00707f
+#define MATCH_VLXBU_V 0xc000007
+#define MASK_VLXBU_V  0x1c00707f
+#define MATCH_VLXHU_V 0xc005007
+#define MASK_VLXHU_V  0x1c00707f
+#define MATCH_VLXWU_V 0xc006007
+#define MASK_VLXWU_V  0x1c00707f
+#define MATCH_VSXB_V 0xc000027
+#define MASK_VSXB_V  0x1c00707f
+#define MATCH_VSXH_V 0xc005027
+#define MASK_VSXH_V  0x1c00707f
+#define MATCH_VSXW_V 0xc006027
+#define MASK_VSXW_V  0x1c00707f
+#define MATCH_VSXE_V 0xc007027
+#define MASK_VSXE_V  0x1c00707f
+#define MATCH_VSUXB_V 0x1c000027
+#define MASK_VSUXB_V  0xfc00707f
+#define MATCH_VSUXH_V 0x1c005027
+#define MASK_VSUXH_V  0xfc00707f
+#define MATCH_VSUXW_V 0x1c006027
+#define MASK_VSUXW_V  0xfc00707f
+#define MATCH_VSUXE_V 0x1c007027
+#define MASK_VSUXE_V  0xfc00707f
+#define MATCH_VLBFF_V 0x11000007
+#define MASK_VLBFF_V  0x1df0707f
+#define MATCH_VLHFF_V 0x11005007
+#define MASK_VLHFF_V  0x1df0707f
+#define MATCH_VLWFF_V 0x11006007
+#define MASK_VLWFF_V  0x1df0707f
+#define MATCH_VLEFF_V 0x1007007
+#define MASK_VLEFF_V  0x1df0707f
+#define MATCH_VLBUFF_V 0x1000007
+#define MASK_VLBUFF_V  0x1df0707f
+#define MATCH_VLHUFF_V 0x1005007
+#define MASK_VLHUFF_V  0x1df0707f
+#define MATCH_VLWUFF_V 0x1006007
+#define MASK_VLWUFF_V  0x1df0707f
+#define MATCH_VFADD_VF 0x5057
+#define MASK_VFADD_VF  0xfc00707f
+#define MATCH_VFSUB_VF 0x8005057
+#define MASK_VFSUB_VF  0xfc00707f
+#define MATCH_VFMIN_VF 0x10005057
+#define MASK_VFMIN_VF  0xfc00707f
+#define MATCH_VFMAX_VF 0x18005057
+#define MASK_VFMAX_VF  0xfc00707f
+#define MATCH_VFSGNJ_VF 0x20005057
+#define MASK_VFSGNJ_VF  0xfc00707f
+#define MATCH_VFSGNJN_VF 0x24005057
+#define MASK_VFSGNJN_VF  0xfc00707f
+#define MATCH_VFSGNJX_VF 0x28005057
+#define MASK_VFSGNJX_VF  0xfc00707f
+#define MATCH_VFMV_S_F 0x36005057
+#define MASK_VFMV_S_F  0xfff0707f
+#define MATCH_VFMERGE_VFM 0x5c005057
+#define MASK_VFMERGE_VFM  0xfe00707f
+#define MATCH_VFMV_V_F 0x5e005057
+#define MASK_VFMV_V_F  0xfff0707f
+#define MATCH_VMFEQ_VF 0x60005057
+#define MASK_VMFEQ_VF  0xfc00707f
+#define MATCH_VMFLE_VF 0x64005057
+#define MASK_VMFLE_VF  0xfc00707f
+#define MATCH_VMFORD_VF 0x68005057
+#define MASK_VMFORD_VF  0xfc00707f
+#define MATCH_VMFLT_VF 0x6c005057
+#define MASK_VMFLT_VF  0xfc00707f
+#define MATCH_VMFNE_VF 0x70005057
+#define MASK_VMFNE_VF  0xfc00707f
+#define MATCH_VMFGT_VF 0x74005057
+#define MASK_VMFGT_VF  0xfc00707f
+#define MATCH_VMFGE_VF 0x7c005057
+#define MASK_VMFGE_VF  0xfc00707f
+#define MATCH_VFDIV_VF 0x80005057
+#define MASK_VFDIV_VF  0xfc00707f
+#define MATCH_VFRDIV_VF 0x84005057
+#define MASK_VFRDIV_VF  0xfc00707f
+#define MATCH_VFMUL_VF 0x90005057
+#define MASK_VFMUL_VF  0xfc00707f
+#define MATCH_VFRSUB_VF 0x9c005057
+#define MASK_VFRSUB_VF  0xfc00707f
+#define MATCH_VFMADD_VF 0xa0005057
+#define MASK_VFMADD_VF  0xfc00707f
+#define MATCH_VFNMADD_VF 0xa4005057
+#define MASK_VFNMADD_VF  0xfc00707f
+#define MATCH_VFMSUB_VF 0xa8005057
+#define MASK_VFMSUB_VF  0xfc00707f
+#define MATCH_VFNMSUB_VF 0xac005057
+#define MASK_VFNMSUB_VF  0xfc00707f
+#define MATCH_VFMACC_VF 0xb0005057
+#define MASK_VFMACC_VF  0xfc00707f
+#define MATCH_VFNMACC_VF 0xb4005057
+#define MASK_VFNMACC_VF  0xfc00707f
+#define MATCH_VFMSAC_VF 0xb8005057
+#define MASK_VFMSAC_VF  0xfc00707f
+#define MATCH_VFNMSAC_VF 0xbc005057
+#define MASK_VFNMSAC_VF  0xfc00707f
+#define MATCH_VFWADD_VF 0xc0005057
+#define MASK_VFWADD_VF  0xfc00707f
+#define MATCH_VFWSUB_VF 0xc8005057
+#define MASK_VFWSUB_VF  0xfc00707f
+#define MATCH_VFWADD_WF 0xd0005057
+#define MASK_VFWADD_WF  0xfc00707f
+#define MATCH_VFWSUB_WF 0xd8005057
+#define MASK_VFWSUB_WF  0xfc00707f
+#define MATCH_VFWMUL_VF 0xe0005057
+#define MASK_VFWMUL_VF  0xfc00707f
+#define MATCH_VFWMACC_VF 0xf0005057
+#define MASK_VFWMACC_VF  0xfc00707f
+#define MATCH_VFWNMACC_VF 0xf4005057
+#define MASK_VFWNMACC_VF  0xfc00707f
+#define MATCH_VFWMSAC_VF 0xf8005057
+#define MASK_VFWMSAC_VF  0xfc00707f
+#define MATCH_VFWNMSAC_VF 0xfc005057
+#define MASK_VFWNMSAC_VF  0xfc00707f
+#define MATCH_VFADD_VV 0x1057
+#define MASK_VFADD_VV  0xfc00707f
+#define MATCH_VFREDSUM_VS 0x4001057
+#define MASK_VFREDSUM_VS  0xfc00707f
+#define MATCH_VFSUB_VV 0x8001057
+#define MASK_VFSUB_VV  0xfc00707f
+#define MATCH_VFREDOSUM_VS 0xc001057
+#define MASK_VFREDOSUM_VS  0xfc00707f
+#define MATCH_VFMIN_VV 0x10001057
+#define MASK_VFMIN_VV  0xfc00707f
+#define MATCH_VFREDMIN_VS 0x14001057
+#define MASK_VFREDMIN_VS  0xfc00707f
+#define MATCH_VFMAX_VV 0x18001057
+#define MASK_VFMAX_VV  0xfc00707f
+#define MATCH_VFREDMAX_VS 0x1c001057
+#define MASK_VFREDMAX_VS  0xfc00707f
+#define MATCH_VFSGNJ_VV 0x20001057
+#define MASK_VFSGNJ_VV  0xfc00707f
+#define MATCH_VFSGNJN_VV 0x24001057
+#define MASK_VFSGNJN_VV  0xfc00707f
+#define MATCH_VFSGNJX_VV 0x28001057
+#define MASK_VFSGNJX_VV  0xfc00707f
+#define MATCH_VFMV_F_S 0x32001057
+#define MASK_VFMV_F_S  0xfe0ff07f
+#define MATCH_VMFEQ_VV 0x60001057
+#define MASK_VMFEQ_VV  0xfc00707f
+#define MATCH_VMFLE_VV 0x64001057
+#define MASK_VMFLE_VV  0xfc00707f
+#define MATCH_VMFORD_VV 0x68001057
+#define MASK_VMFORD_VV  0xfc00707f
+#define MATCH_VMFLT_VV 0x6c001057
+#define MASK_VMFLT_VV  0xfc00707f
+#define MATCH_VMFNE_VV 0x70001057
+#define MASK_VMFNE_VV  0xfc00707f
+#define MATCH_VFDIV_VV 0x80001057
+#define MASK_VFDIV_VV  0xfc00707f
+#define MATCH_VFMUL_VV 0x90001057
+#define MASK_VFMUL_VV  0xfc00707f
+#define MATCH_VFMADD_VV 0xa0001057
+#define MASK_VFMADD_VV  0xfc00707f
+#define MATCH_VFNMADD_VV 0xa4001057
+#define MASK_VFNMADD_VV  0xfc00707f
+#define MATCH_VFMSUB_VV 0xa8001057
+#define MASK_VFMSUB_VV  0xfc00707f
+#define MATCH_VFNMSUB_VV 0xac001057
+#define MASK_VFNMSUB_VV  0xfc00707f
+#define MATCH_VFMACC_VV 0xb0001057
+#define MASK_VFMACC_VV  0xfc00707f
+#define MATCH_VFNMACC_VV 0xb4001057
+#define MASK_VFNMACC_VV  0xfc00707f
+#define MATCH_VFMSAC_VV 0xb8001057
+#define MASK_VFMSAC_VV  0xfc00707f
+#define MATCH_VFNMSAC_VV 0xbc001057
+#define MASK_VFNMSAC_VV  0xfc00707f
+#define MATCH_VFCVT_XU_F_V 0x88001057
+#define MASK_VFCVT_XU_F_V  0xfc0ff07f
+#define MATCH_VFCVT_X_F_V 0x88009057
+#define MASK_VFCVT_X_F_V  0xfc0ff07f
+#define MATCH_VFCVT_F_XU_V 0x88011057
+#define MASK_VFCVT_F_XU_V  0xfc0ff07f
+#define MATCH_VFCVT_F_X_V 0x88019057
+#define MASK_VFCVT_F_X_V  0xfc0ff07f
+#define MATCH_VFWCVT_XU_F_V 0x88041057
+#define MASK_VFWCVT_XU_F_V  0xfc0ff07f
+#define MATCH_VFWCVT_X_F_V 0x88049057
+#define MASK_VFWCVT_X_F_V  0xfc0ff07f
+#define MATCH_VFWCVT_F_XU_V 0x88051057
+#define MASK_VFWCVT_F_XU_V  0xfc0ff07f
+#define MATCH_VFWCVT_F_X_V 0x88059057
+#define MASK_VFWCVT_F_X_V  0xfc0ff07f
+#define MATCH_VFWCVT_F_F_V 0x88061057
+#define MASK_VFWCVT_F_F_V  0xfc0ff07f
+#define MATCH_VFNCVT_XU_F_V 0x88081057
+#define MASK_VFNCVT_XU_F_V  0xfc0ff07f
+#define MATCH_VFNCVT_X_F_V 0x88089057
+#define MASK_VFNCVT_X_F_V  0xfc0ff07f
+#define MATCH_VFNCVT_F_XU_V 0x88091057
+#define MASK_VFNCVT_F_XU_V  0xfc0ff07f
+#define MATCH_VFNCVT_F_X_V 0x88099057
+#define MASK_VFNCVT_F_X_V  0xfc0ff07f
+#define MATCH_VFNCVT_F_F_V 0x880a1057
+#define MASK_VFNCVT_F_F_V  0xfc0ff07f
+#define MATCH_VFSQRT_V 0x8c001057
+#define MASK_VFSQRT_V  0xfc0ff07f
+#define MATCH_VFCLASS_V 0x8c081057
+#define MASK_VFCLASS_V  0xfc0ff07f
+#define MATCH_VFWADD_VV 0xc0001057
+#define MASK_VFWADD_VV  0xfc00707f
+#define MATCH_VFWREDSUM_VS 0xc4001057
+#define MASK_VFWREDSUM_VS  0xfc00707f
+#define MATCH_VFWSUB_VV 0xc8001057
+#define MASK_VFWSUB_VV  0xfc00707f
+#define MATCH_VFWREDOSUM_VS 0xcc001057
+#define MASK_VFWREDOSUM_VS  0xfc00707f
+#define MATCH_VFWADD_WV 0xd0001057
+#define MASK_VFWADD_WV  0xfc00707f
+#define MATCH_VFWSUB_WV 0xd8001057
+#define MASK_VFWSUB_WV  0xfc00707f
+#define MATCH_VFWMUL_VV 0xe0001057
+#define MASK_VFWMUL_VV  0xfc00707f
+#define MATCH_VFDOT_VV 0xe4001057
+#define MASK_VFDOT_VV  0xfc00707f
+#define MATCH_VFWMACC_VV 0xf0001057
+#define MASK_VFWMACC_VV  0xfc00707f
+#define MATCH_VFWNMACC_VV 0xf4001057
+#define MASK_VFWNMACC_VV  0xfc00707f
+#define MATCH_VFWMSAC_VV 0xf8001057
+#define MASK_VFWMSAC_VV  0xfc00707f
+#define MATCH_VFWNMSAC_VV 0xfc001057
+#define MASK_VFWNMSAC_VV  0xfc00707f
+#define MATCH_VADD_VX 0x4057
+#define MASK_VADD_VX  0xfc00707f
+#define MATCH_VSUB_VX 0x8004057
+#define MASK_VSUB_VX  0xfc00707f
+#define MATCH_VRSUB_VX 0xc004057
+#define MASK_VRSUB_VX  0xfc00707f
+#define MATCH_VMINU_VX 0x10004057
+#define MASK_VMINU_VX  0xfc00707f
+#define MATCH_VMIN_VX 0x14004057
+#define MASK_VMIN_VX  0xfc00707f
+#define MATCH_VMAXU_VX 0x18004057
+#define MASK_VMAXU_VX  0xfc00707f
+#define MATCH_VMAX_VX 0x1c004057
+#define MASK_VMAX_VX  0xfc00707f
+#define MATCH_VAND_VX 0x24004057
+#define MASK_VAND_VX  0xfc00707f
+#define MATCH_VOR_VX 0x28004057
+#define MASK_VOR_VX  0xfc00707f
+#define MATCH_VXOR_VX 0x2c004057
+#define MASK_VXOR_VX  0xfc00707f
+#define MATCH_VRGATHER_VX 0x30004057
+#define MASK_VRGATHER_VX  0xfc00707f
+#define MATCH_VSLIDEUP_VX 0x38004057
+#define MASK_VSLIDEUP_VX  0xfc00707f
+#define MATCH_VSLIDEDOWN_VX 0x3c004057
+#define MASK_VSLIDEDOWN_VX  0xfc00707f
+#define MATCH_VADC_VXM 0x42004057
+#define MASK_VADC_VXM  0xfe00707f
+#define MATCH_VMADC_VXM 0x46004057
+#define MASK_VMADC_VXM  0xfe00707f
+#define MATCH_VSBC_VXM 0x4a004057
+#define MASK_VSBC_VXM  0xfe00707f
+#define MATCH_VMSBC_VXM 0x4e004057
+#define MASK_VMSBC_VXM  0xfe00707f
+#define MATCH_VMERGE_VXM 0x5c004057
+#define MASK_VMERGE_VXM  0xfe00707f
+#define MATCH_VMV_V_X 0x5e004057
+#define MASK_VMV_V_X  0xfff0707f
+#define MATCH_VMSEQ_VX 0x60004057
+#define MASK_VMSEQ_VX  0xfc00707f
+#define MATCH_VMSNE_VX 0x64004057
+#define MASK_VMSNE_VX  0xfc00707f
+#define MATCH_VMSLTU_VX 0x68004057
+#define MASK_VMSLTU_VX  0xfc00707f
+#define MATCH_VMSLT_VX 0x6c004057
+#define MASK_VMSLT_VX  0xfc00707f
+#define MATCH_VMSLEU_VX 0x70004057
+#define MASK_VMSLEU_VX  0xfc00707f
+#define MATCH_VMSLE_VX 0x74004057
+#define MASK_VMSLE_VX  0xfc00707f
+#define MATCH_VMSGTU_VX 0x78004057
+#define MASK_VMSGTU_VX  0xfc00707f
+#define MATCH_VMSGT_VX 0x7c004057
+#define MASK_VMSGT_VX  0xfc00707f
+#define MATCH_VSADDU_VX 0x80004057
+#define MASK_VSADDU_VX  0xfc00707f
+#define MATCH_VSADD_VX 0x84004057
+#define MASK_VSADD_VX  0xfc00707f
+#define MATCH_VSSUBU_VX 0x88004057
+#define MASK_VSSUBU_VX  0xfc00707f
+#define MATCH_VSSUB_VX 0x8c004057
+#define MASK_VSSUB_VX  0xfc00707f
+#define MATCH_VAADD_VX 0x90004057
+#define MASK_VAADD_VX  0xfc00707f
+#define MATCH_VSLL_VX 0x94004057
+#define MASK_VSLL_VX  0xfc00707f
+#define MATCH_VASUB_VX 0x98004057
+#define MASK_VASUB_VX  0xfc00707f
+#define MATCH_VSMUL_VX 0x9c004057
+#define MASK_VSMUL_VX  0xfc00707f
+#define MATCH_VSRL_VX 0xa0004057
+#define MASK_VSRL_VX  0xfc00707f
+#define MATCH_VSRA_VX 0xa4004057
+#define MASK_VSRA_VX  0xfc00707f
+#define MATCH_VSSRL_VX 0xa8004057
+#define MASK_VSSRL_VX  0xfc00707f
+#define MATCH_VSSRA_VX 0xac004057
+#define MASK_VSSRA_VX  0xfc00707f
+#define MATCH_VNSRL_VX 0xb0004057
+#define MASK_VNSRL_VX  0xfc00707f
+#define MATCH_VNSRA_VX 0xb4004057
+#define MASK_VNSRA_VX  0xfc00707f
+#define MATCH_VNCLIPU_VX 0xb8004057
+#define MASK_VNCLIPU_VX  0xfc00707f
+#define MATCH_VNCLIP_VX 0xbc004057
+#define MASK_VNCLIP_VX  0xfc00707f
+#define MATCH_VWSMACCU_VX 0xf0004057
+#define MASK_VWSMACCU_VX  0xfc00707f
+#define MATCH_VWSMACC_VX 0xf4004057
+#define MASK_VWSMACC_VX  0xfc00707f
+#define MATCH_VWSMACCSU_VX 0xf8004057
+#define MASK_VWSMACCSU_VX  0xfc00707f
+#define MATCH_VWSMACCUS_VX 0xfc004057
+#define MASK_VWSMACCUS_VX  0xfc00707f
+#define MATCH_VADD_VV 0x57
+#define MASK_VADD_VV  0xfc00707f
+#define MATCH_VSUB_VV 0x8000057
+#define MASK_VSUB_VV  0xfc00707f
+#define MATCH_VMINU_VV 0x10000057
+#define MASK_VMINU_VV  0xfc00707f
+#define MATCH_VMIN_VV 0x14000057
+#define MASK_VMIN_VV  0xfc00707f
+#define MATCH_VMAXU_VV 0x18000057
+#define MASK_VMAXU_VV  0xfc00707f
+#define MATCH_VMAX_VV 0x1c000057
+#define MASK_VMAX_VV  0xfc00707f
+#define MATCH_VAND_VV 0x24000057
+#define MASK_VAND_VV  0xfc00707f
+#define MATCH_VOR_VV 0x28000057
+#define MASK_VOR_VV  0xfc00707f
+#define MATCH_VXOR_VV 0x2c000057
+#define MASK_VXOR_VV  0xfc00707f
+#define MATCH_VRGATHER_VV 0x30000057
+#define MASK_VRGATHER_VV  0xfc00707f
+#define MATCH_VADC_VVM 0x42000057
+#define MASK_VADC_VVM  0xfe00707f
+#define MATCH_VMADC_VVM 0x46000057
+#define MASK_VMADC_VVM  0xfe00707f
+#define MATCH_VSBC_VVM 0x4a000057
+#define MASK_VSBC_VVM  0xfe00707f
+#define MATCH_VMSBC_VVM 0x4e000057
+#define MASK_VMSBC_VVM  0xfe00707f
+#define MATCH_VMERGE_VVM 0x5c000057
+#define MASK_VMERGE_VVM  0xfe00707f
+#define MATCH_VMV_V_V 0x5e000057
+#define MASK_VMV_V_V  0xfff0707f
+#define MATCH_VMSEQ_VV 0x60000057
+#define MASK_VMSEQ_VV  0xfc00707f
+#define MATCH_VMSNE_VV 0x64000057
+#define MASK_VMSNE_VV  0xfc00707f
+#define MATCH_VMSLTU_VV 0x68000057
+#define MASK_VMSLTU_VV  0xfc00707f
+#define MATCH_VMSLT_VV 0x6c000057
+#define MASK_VMSLT_VV  0xfc00707f
+#define MATCH_VMSLEU_VV 0x70000057
+#define MASK_VMSLEU_VV  0xfc00707f
+#define MATCH_VMSLE_VV 0x74000057
+#define MASK_VMSLE_VV  0xfc00707f
+#define MATCH_VSADDU_VV 0x80000057
+#define MASK_VSADDU_VV  0xfc00707f
+#define MATCH_VSADD_VV 0x84000057
+#define MASK_VSADD_VV  0xfc00707f
+#define MATCH_VSSUBU_VV 0x88000057
+#define MASK_VSSUBU_VV  0xfc00707f
+#define MATCH_VSSUB_VV 0x8c000057
+#define MASK_VSSUB_VV  0xfc00707f
+#define MATCH_VAADD_VV 0x90000057
+#define MASK_VAADD_VV  0xfc00707f
+#define MATCH_VSLL_VV 0x94000057
+#define MASK_VSLL_VV  0xfc00707f
+#define MATCH_VASUB_VV 0x98000057
+#define MASK_VASUB_VV  0xfc00707f
+#define MATCH_VSMUL_VV 0x9c000057
+#define MASK_VSMUL_VV  0xfc00707f
+#define MATCH_VSRL_VV 0xa0000057
+#define MASK_VSRL_VV  0xfc00707f
+#define MATCH_VSRA_VV 0xa4000057
+#define MASK_VSRA_VV  0xfc00707f
+#define MATCH_VSSRL_VV 0xa8000057
+#define MASK_VSSRL_VV  0xfc00707f
+#define MATCH_VSSRA_VV 0xac000057
+#define MASK_VSSRA_VV  0xfc00707f
+#define MATCH_VNSRL_VV 0xb0000057
+#define MASK_VNSRL_VV  0xfc00707f
+#define MATCH_VNSRA_VV 0xb4000057
+#define MASK_VNSRA_VV  0xfc00707f
+#define MATCH_VNCLIPU_VV 0xb8000057
+#define MASK_VNCLIPU_VV  0xfc00707f
+#define MATCH_VNCLIP_VV 0xbc000057
+#define MASK_VNCLIP_VV  0xfc00707f
+#define MATCH_VWREDSUMU_VS 0xc0000057
+#define MASK_VWREDSUMU_VS  0xfc00707f
+#define MATCH_VWREDSUM_VS 0xc4000057
+#define MASK_VWREDSUM_VS  0xfc00707f
+#define MATCH_VDOTU_VV 0xe0000057
+#define MASK_VDOTU_VV  0xfc00707f
+#define MATCH_VDOT_VV 0xe4000057
+#define MASK_VDOT_VV  0xfc00707f
+#define MATCH_VWSMACCU_VV 0xf0000057
+#define MASK_VWSMACCU_VV  0xfc00707f
+#define MATCH_VWSMACC_VV 0xf4000057
+#define MASK_VWSMACC_VV  0xfc00707f
+#define MATCH_VWSMACCSU_VV 0xf8000057
+#define MASK_VWSMACCSU_VV  0xfc00707f
+#define MATCH_VADD_VI 0x3057
+#define MASK_VADD_VI  0xfc00707f
+#define MATCH_VRSUB_VI 0xc003057
+#define MASK_VRSUB_VI  0xfc00707f
+#define MATCH_VAND_VI 0x24003057
+#define MASK_VAND_VI  0xfc00707f
+#define MATCH_VOR_VI 0x28003057
+#define MASK_VOR_VI  0xfc00707f
+#define MATCH_VXOR_VI 0x2c003057
+#define MASK_VXOR_VI  0xfc00707f
+#define MATCH_VRGATHER_VI 0x30003057
+#define MASK_VRGATHER_VI  0xfc00707f
+#define MATCH_VSLIDEUP_VI 0x38003057
+#define MASK_VSLIDEUP_VI  0xfc00707f
+#define MATCH_VSLIDEDOWN_VI 0x3c003057
+#define MASK_VSLIDEDOWN_VI  0xfc00707f
+#define MATCH_VADC_VIM 0x42003057
+#define MASK_VADC_VIM  0xfe00707f
+#define MATCH_VMADC_VIM 0x46003057
+#define MASK_VMADC_VIM  0xfe00707f
+#define MATCH_VMERGE_VIM 0x5c003057
+#define MASK_VMERGE_VIM  0xfe00707f
+#define MATCH_VMV_V_I 0x5e003057
+#define MASK_VMV_V_I  0xfff0707f
+#define MATCH_VMSEQ_VI 0x60003057
+#define MASK_VMSEQ_VI  0xfc00707f
+#define MATCH_VMSNE_VI 0x64003057
+#define MASK_VMSNE_VI  0xfc00707f
+#define MATCH_VMSLEU_VI 0x70003057
+#define MASK_VMSLEU_VI  0xfc00707f
+#define MATCH_VMSLE_VI 0x74003057
+#define MASK_VMSLE_VI  0xfc00707f
+#define MATCH_VMSGTU_VI 0x78003057
+#define MASK_VMSGTU_VI  0xfc00707f
+#define MATCH_VMSGT_VI 0x7c003057
+#define MASK_VMSGT_VI  0xfc00707f
+#define MATCH_VSADDU_VI 0x80003057
+#define MASK_VSADDU_VI  0xfc00707f
+#define MATCH_VSADD_VI 0x84003057
+#define MASK_VSADD_VI  0xfc00707f
+#define MATCH_VAADD_VI 0x90003057
+#define MASK_VAADD_VI  0xfc00707f
+#define MATCH_VSLL_VI 0x94003057
+#define MASK_VSLL_VI  0xfc00707f
+#define MATCH_VSRL_VI 0xa0003057
+#define MASK_VSRL_VI  0xfc00707f
+#define MATCH_VSRA_VI 0xa4003057
+#define MASK_VSRA_VI  0xfc00707f
+#define MATCH_VSSRL_VI 0xa8003057
+#define MASK_VSSRL_VI  0xfc00707f
+#define MATCH_VSSRA_VI 0xac003057
+#define MASK_VSSRA_VI  0xfc00707f
+#define MATCH_VNSRL_VI 0xb0003057
+#define MASK_VNSRL_VI  0xfc00707f
+#define MATCH_VNSRA_VI 0xb4003057
+#define MASK_VNSRA_VI  0xfc00707f
+#define MATCH_VNCLIPU_VI 0xb8003057
+#define MASK_VNCLIPU_VI  0xfc00707f
+#define MATCH_VNCLIP_VI 0xbc003057
+#define MASK_VNCLIP_VI  0xfc00707f
+#define MATCH_VREDSUM_VS 0x2057
+#define MASK_VREDSUM_VS  0xfc00707f
+#define MATCH_VREDAND_VS 0x4002057
+#define MASK_VREDAND_VS  0xfc00707f
+#define MATCH_VREDOR_VS 0x8002057
+#define MASK_VREDOR_VS  0xfc00707f
+#define MATCH_VREDXOR_VS 0xc002057
+#define MASK_VREDXOR_VS  0xfc00707f
+#define MATCH_VREDMINU_VS 0x10002057
+#define MASK_VREDMINU_VS  0xfc00707f
+#define MATCH_VREDMIN_VS 0x14002057
+#define MASK_VREDMIN_VS  0xfc00707f
+#define MATCH_VREDMAXU_VS 0x18002057
+#define MASK_VREDMAXU_VS  0xfc00707f
+#define MATCH_VREDMAX_VS 0x1c002057
+#define MASK_VREDMAX_VS  0xfc00707f
+#define MATCH_VEXT_X_V 0x32002057
+#define MASK_VEXT_X_V  0xfe00707f
+#define MATCH_VMPOPC_M 0x50002057
+#define MASK_VMPOPC_M  0xfc00707f
+#define MATCH_VMFIRST_M 0x54002057
+#define MASK_VMFIRST_M  0xfc00707f
+#define MATCH_VCOMPRESS_VM 0x5c002057
+#define MASK_VCOMPRESS_VM  0xfc00707f
+#define MATCH_VMANDNOT_MM 0x60002057
+#define MASK_VMANDNOT_MM  0xfc00707f
+#define MATCH_VMAND_MM 0x64002057
+#define MASK_VMAND_MM  0xfc00707f
+#define MATCH_VMOR_MM 0x68002057
+#define MASK_VMOR_MM  0xfc00707f
+#define MATCH_VMXOR_MM 0x6c002057
+#define MASK_VMXOR_MM  0xfc00707f
+#define MATCH_VMORNOT_MM 0x70002057
+#define MASK_VMORNOT_MM  0xfc00707f
+#define MATCH_VMNAND_MM 0x74002057
+#define MASK_VMNAND_MM  0xfc00707f
+#define MATCH_VMNOR_MM 0x78002057
+#define MASK_VMNOR_MM  0xfc00707f
+#define MATCH_VMXNOR_MM 0x7c002057
+#define MASK_VMXNOR_MM  0xfc00707f
+#define MATCH_VMSBF_M 0x5800a057
+#define MASK_VMSBF_M  0xfc0ff07f
+#define MATCH_VMSOF_M 0x58012057
+#define MASK_VMSOF_M  0xfc0ff07f
+#define MATCH_VMSIF_M 0x5801a057
+#define MASK_VMSIF_M  0xfc0ff07f
+#define MATCH_VIOTA_M 0x58082057
+#define MASK_VIOTA_M  0xfc0ff07f
+#define MATCH_VID_V 0x5808a057
+#define MASK_VID_V  0xfdfff07f
+#define MATCH_VDIVU_VV 0x80002057
+#define MASK_VDIVU_VV  0xfc00707f
+#define MATCH_VDIV_VV 0x84002057
+#define MASK_VDIV_VV  0xfc00707f
+#define MATCH_VREMU_VV 0x88002057
+#define MASK_VREMU_VV  0xfc00707f
+#define MATCH_VREM_VV 0x8c002057
+#define MASK_VREM_VV  0xfc00707f
+#define MATCH_VMULHU_VV 0x90002057
+#define MASK_VMULHU_VV  0xfc00707f
+#define MATCH_VMUL_VV 0x94002057
+#define MASK_VMUL_VV  0xfc00707f
+#define MATCH_VMULHSU_VV 0x98002057
+#define MASK_VMULHSU_VV  0xfc00707f
+#define MATCH_VMULH_VV 0x9c002057
+#define MASK_VMULH_VV  0xfc00707f
+#define MATCH_VMADD_VV 0xa4002057
+#define MASK_VMADD_VV  0xfc00707f
+#define MATCH_VNMSUB_VV 0xac002057
+#define MASK_VNMSUB_VV  0xfc00707f
+#define MATCH_VMACC_VV 0xb4002057
+#define MASK_VMACC_VV  0xfc00707f
+#define MATCH_VNMSAC_VV 0xbc002057
+#define MASK_VNMSAC_VV  0xfc00707f
+#define MATCH_VWADDU_VV 0xc0002057
+#define MASK_VWADDU_VV  0xfc00707f
+#define MATCH_VWADD_VV 0xc4002057
+#define MASK_VWADD_VV  0xfc00707f
+#define MATCH_VWSUBU_VV 0xc8002057
+#define MASK_VWSUBU_VV  0xfc00707f
+#define MATCH_VWSUB_VV 0xcc002057
+#define MASK_VWSUB_VV  0xfc00707f
+#define MATCH_VWADDU_WV 0xd0002057
+#define MASK_VWADDU_WV  0xfc00707f
+#define MATCH_VWADD_WV 0xd4002057
+#define MASK_VWADD_WV  0xfc00707f
+#define MATCH_VWSUBU_WV 0xd8002057
+#define MASK_VWSUBU_WV  0xfc00707f
+#define MATCH_VWSUB_WV 0xdc002057
+#define MASK_VWSUB_WV  0xfc00707f
+#define MATCH_VWMULU_VV 0xe0002057
+#define MASK_VWMULU_VV  0xfc00707f
+#define MATCH_VWMULSU_VV 0xe8002057
+#define MASK_VWMULSU_VV  0xfc00707f
+#define MATCH_VWMUL_VV 0xec002057
+#define MASK_VWMUL_VV  0xfc00707f
+#define MATCH_VWMACCU_VV 0xf0002057
+#define MASK_VWMACCU_VV  0xfc00707f
+#define MATCH_VWMACC_VV 0xf4002057
+#define MASK_VWMACC_VV  0xfc00707f
+#define MATCH_VWMACCSU_VV 0xf8002057
+#define MASK_VWMACCSU_VV  0xfc00707f
+#define MATCH_VMV_S_X 0x36006057
+#define MASK_VMV_S_X  0xfff0707f
+#define MATCH_VSLIDE1UP_VX 0x38006057
+#define MASK_VSLIDE1UP_VX  0xfc00707f
+#define MATCH_VSLIDE1DOWN_VX 0x3c006057
+#define MASK_VSLIDE1DOWN_VX  0xfc00707f
+#define MATCH_VDIVU_VX 0x80006057
+#define MASK_VDIVU_VX  0xfc00707f
+#define MATCH_VDIV_VX 0x84006057
+#define MASK_VDIV_VX  0xfc00707f
+#define MATCH_VREMU_VX 0x88006057
+#define MASK_VREMU_VX  0xfc00707f
+#define MATCH_VREM_VX 0x8c006057
+#define MASK_VREM_VX  0xfc00707f
+#define MATCH_VMULHU_VX 0x90006057
+#define MASK_VMULHU_VX  0xfc00707f
+#define MATCH_VMUL_VX 0x94006057
+#define MASK_VMUL_VX  0xfc00707f
+#define MATCH_VMULHSU_VX 0x98006057
+#define MASK_VMULHSU_VX  0xfc00707f
+#define MATCH_VMULH_VX 0x9c006057
+#define MASK_VMULH_VX  0xfc00707f
+#define MATCH_VMADD_VX 0xa4006057
+#define MASK_VMADD_VX  0xfc00707f
+#define MATCH_VNMSUB_VX 0xac006057
+#define MASK_VNMSUB_VX  0xfc00707f
+#define MATCH_VMACC_VX 0xb4006057
+#define MASK_VMACC_VX  0xfc00707f
+#define MATCH_VNMSAC_VX 0xbc006057
+#define MASK_VNMSAC_VX  0xfc00707f
+#define MATCH_VWADDU_VX 0xc0006057
+#define MASK_VWADDU_VX  0xfc00707f
+#define MATCH_VWADD_VX 0xc4006057
+#define MASK_VWADD_VX  0xfc00707f
+#define MATCH_VWSUBU_VX 0xc8006057
+#define MASK_VWSUBU_VX  0xfc00707f
+#define MATCH_VWSUB_VX 0xcc006057
+#define MASK_VWSUB_VX  0xfc00707f
+#define MATCH_VWADDU_WX 0xd0006057
+#define MASK_VWADDU_WX  0xfc00707f
+#define MATCH_VWADD_WX 0xd4006057
+#define MASK_VWADD_WX  0xfc00707f
+#define MATCH_VWSUBU_WX 0xd8006057
+#define MASK_VWSUBU_WX  0xfc00707f
+#define MATCH_VWSUB_WX 0xdc006057
+#define MASK_VWSUB_WX  0xfc00707f
+#define MATCH_VWMULU_VX 0xe0006057
+#define MASK_VWMULU_VX  0xfc00707f
+#define MATCH_VWMULSU_VX 0xe8006057
+#define MASK_VWMULSU_VX  0xfc00707f
+#define MATCH_VWMUL_VX 0xec006057
+#define MASK_VWMUL_VX  0xfc00707f
+#define MATCH_VWMACCU_VX 0xf0006057
+#define MASK_VWMACCU_VX  0xfc00707f
+#define MATCH_VWMACC_VX 0xf4006057
+#define MASK_VWMACC_VX  0xfc00707f
+#define MATCH_VWMACCSU_VX 0xf8006057
+#define MASK_VWMACCSU_VX  0xfc00707f
+#define MATCH_VWMACCUS_VX 0xfc006057
+#define MASK_VWMACCUS_VX  0xfc00707f
+#define MATCH_VAMOSWAPW_V 0x800602f
+#define MASK_VAMOSWAPW_V  0xf800707f
+#define MATCH_VAMOADDW_V 0x602f
+#define MASK_VAMOADDW_V  0xf800707f
+#define MATCH_VAMOXORW_V 0x2000602f
+#define MASK_VAMOXORW_V  0xf800707f
+#define MATCH_VAMOANDW_V 0x6000602f
+#define MASK_VAMOANDW_V  0xf800707f
+#define MATCH_VAMOORW_V 0x4000602f
+#define MASK_VAMOORW_V  0xf800707f
+#define MATCH_VAMOMINW_V 0x8000602f
+#define MASK_VAMOMINW_V  0xf800707f
+#define MATCH_VAMOMAXW_V 0xa000602f
+#define MASK_VAMOMAXW_V  0xf800707f
+#define MATCH_VAMOMINUW_V 0xc000602f
+#define MASK_VAMOMINUW_V  0xf800707f
+#define MATCH_VAMOMAXUW_V 0xe000602f
+#define MASK_VAMOMAXUW_V  0xf800707f
+#define MATCH_VAMOSWAPD_V 0x800702f
+#define MASK_VAMOSWAPD_V  0xf800707f
+#define MATCH_VAMOADDD_V 0x702f
+#define MASK_VAMOADDD_V  0xf800707f
+#define MATCH_VAMOXORD_V 0x2000702f
+#define MASK_VAMOXORD_V  0xf800707f
+#define MATCH_VAMOANDD_V 0x6000702f
+#define MASK_VAMOANDD_V  0xf800707f
+#define MATCH_VAMOORD_V 0x4000702f
+#define MASK_VAMOORD_V  0xf800707f
+#define MATCH_VAMOMIND_V 0x8000702f
+#define MASK_VAMOMIND_V  0xf800707f
+#define MATCH_VAMOMAXD_V 0xa000702f
+#define MASK_VAMOMAXD_V  0xf800707f
+#define MATCH_VAMOMINUD_V 0xc000702f
+#define MASK_VAMOMINUD_V  0xf800707f
+#define MATCH_VAMOMAXUD_V 0xe000702f
+#define MASK_VAMOMAXUD_V  0xf800707f
+#define MATCH_VAMOSWAPQ_V 0x800002f
+#define MASK_VAMOSWAPQ_V  0xf800707f
+#define MATCH_VAMOADDQ_V 0x2f
+#define MASK_VAMOADDQ_V  0xf800707f
+#define MATCH_VAMOXORQ_V 0x2000002f
+#define MASK_VAMOXORQ_V  0xf800707f
+#define MATCH_VAMOANDQ_V 0x6000002f
+#define MASK_VAMOANDQ_V  0xf800707f
+#define MATCH_VAMOORQ_V 0x4000002f
+#define MASK_VAMOORQ_V  0xf800707f
+#define MATCH_VAMOMINQ_V 0x8000002f
+#define MASK_VAMOMINQ_V  0xf800707f
+#define MATCH_VAMOMAXQ_V 0xa000002f
+#define MASK_VAMOMAXQ_V  0xf800707f
+#define MATCH_VAMOMINUQ_V 0xc000002f
+#define MASK_VAMOMINUQ_V  0xf800707f
+#define MATCH_VAMOMAXUQ_V 0xe000002f
+#define MASK_VAMOMAXUQ_V  0xf800707f
+#define CSR_FFLAGS 0x1
+#define CSR_FRM 0x2
+#define CSR_FCSR 0x3
+#define CSR_USTATUS 0x0
+#define CSR_UIE 0x4
+#define CSR_UTVEC 0x5
+#define CSR_VSTART 0x8
+#define CSR_VXSAT 0x9
+#define CSR_VXRM 0xa
+#define CSR_USCRATCH 0x40
+#define CSR_UEPC 0x41
+#define CSR_UCAUSE 0x42
+#define CSR_UTVAL 0x43
+#define CSR_UIP 0x44
+#define CSR_CYCLE 0xc00
+#define CSR_TIME 0xc01
+#define CSR_INSTRET 0xc02
+#define CSR_HPMCOUNTER3 0xc03
+#define CSR_HPMCOUNTER4 0xc04
+#define CSR_HPMCOUNTER5 0xc05
+#define CSR_HPMCOUNTER6 0xc06
+#define CSR_HPMCOUNTER7 0xc07
+#define CSR_HPMCOUNTER8 0xc08
+#define CSR_HPMCOUNTER9 0xc09
+#define CSR_HPMCOUNTER10 0xc0a
+#define CSR_HPMCOUNTER11 0xc0b
+#define CSR_HPMCOUNTER12 0xc0c
+#define CSR_HPMCOUNTER13 0xc0d
+#define CSR_HPMCOUNTER14 0xc0e
+#define CSR_HPMCOUNTER15 0xc0f
+#define CSR_HPMCOUNTER16 0xc10
+#define CSR_HPMCOUNTER17 0xc11
+#define CSR_HPMCOUNTER18 0xc12
+#define CSR_HPMCOUNTER19 0xc13
+#define CSR_HPMCOUNTER20 0xc14
+#define CSR_HPMCOUNTER21 0xc15
+#define CSR_HPMCOUNTER22 0xc16
+#define CSR_HPMCOUNTER23 0xc17
+#define CSR_HPMCOUNTER24 0xc18
+#define CSR_HPMCOUNTER25 0xc19
+#define CSR_HPMCOUNTER26 0xc1a
+#define CSR_HPMCOUNTER27 0xc1b
+#define CSR_HPMCOUNTER28 0xc1c
+#define CSR_HPMCOUNTER29 0xc1d
+#define CSR_HPMCOUNTER30 0xc1e
+#define CSR_HPMCOUNTER31 0xc1f
+#define CSR_VL 0xc20
+#define CSR_VTYPE 0xc21
+#define CSR_SSTATUS 0x100
+#define CSR_SIE 0x104
+#define CSR_STVEC 0x105
+#define CSR_SCOUNTEREN 0x106
+#define CSR_SSCRATCH 0x140
+#define CSR_SEPC 0x141
+#define CSR_SCAUSE 0x142
+#define CSR_STVAL 0x143
+#define CSR_SIP 0x144
+#define CSR_SATP 0x180
+#define CSR_BSSTATUS 0x200
+#define CSR_BSIE 0x204
+#define CSR_BSTVEC 0x205
+#define CSR_BSSCRATCH 0x240
+#define CSR_BSEPC 0x241
+#define CSR_BSCAUSE 0x242
+#define CSR_BSTVAL 0x243
+#define CSR_BSIP 0x244
+#define CSR_BSATP 0x280
+#define CSR_HSTATUS 0xa00
+#define CSR_HEDELEG 0xa02
+#define CSR_HIDELEG 0xa03
+#define CSR_HGATP 0xa80
+#define CSR_UTVT 0x7
+#define CSR_UNXTI 0x45
+#define CSR_UINTSTATUS 0x46
+#define CSR_USCRATCHCSW 0x48
+#define CSR_USCRATCHCSWL 0x49
+#define CSR_STVT 0x107
+#define CSR_SNXTI 0x145
+#define CSR_SINTSTATUS 0x146
+#define CSR_SSCRATCHCSW 0x148
+#define CSR_SSCRATCHCSWL 0x149
+#define CSR_MTVT 0x307
+#define CSR_MNXTI 0x345
+#define CSR_MINTSTATUS 0x346
+#define CSR_MSCRATCHCSW 0x348
+#define CSR_MSCRATCHCSWL 0x349
+#define CSR_MSTATUS 0x300
+#define CSR_MISA 0x301
+#define CSR_MEDELEG 0x302
+#define CSR_MIDELEG 0x303
+#define CSR_MIE 0x304
+#define CSR_MTVEC 0x305
+#define CSR_MCOUNTEREN 0x306
+#define CSR_MSCRATCH 0x340
+#define CSR_MEPC 0x341
+#define CSR_MCAUSE 0x342
+#define CSR_MTVAL 0x343
+#define CSR_MIP 0x344
+#define CSR_PMPCFG0 0x3a0
+#define CSR_PMPCFG1 0x3a1
+#define CSR_PMPCFG2 0x3a2
+#define CSR_PMPCFG3 0x3a3
+#define CSR_PMPADDR0 0x3b0
+#define CSR_PMPADDR1 0x3b1
+#define CSR_PMPADDR2 0x3b2
+#define CSR_PMPADDR3 0x3b3
+#define CSR_PMPADDR4 0x3b4
+#define CSR_PMPADDR5 0x3b5
+#define CSR_PMPADDR6 0x3b6
+#define CSR_PMPADDR7 0x3b7
+#define CSR_PMPADDR8 0x3b8
+#define CSR_PMPADDR9 0x3b9
+#define CSR_PMPADDR10 0x3ba
+#define CSR_PMPADDR11 0x3bb
+#define CSR_PMPADDR12 0x3bc
+#define CSR_PMPADDR13 0x3bd
+#define CSR_PMPADDR14 0x3be
+#define CSR_PMPADDR15 0x3bf
+#define CSR_TSELECT 0x7a0
+#define CSR_TDATA1 0x7a1
+#define CSR_TDATA2 0x7a2
+#define CSR_TDATA3 0x7a3
+#define CSR_DCSR 0x7b0
+#define CSR_DPC 0x7b1
+#define CSR_DSCRATCH 0x7b2
+#define CSR_MCYCLE 0xb00
+#define CSR_MINSTRET 0xb02
+#define CSR_MHPMCOUNTER3 0xb03
+#define CSR_MHPMCOUNTER4 0xb04
+#define CSR_MHPMCOUNTER5 0xb05
+#define CSR_MHPMCOUNTER6 0xb06
+#define CSR_MHPMCOUNTER7 0xb07
+#define CSR_MHPMCOUNTER8 0xb08
+#define CSR_MHPMCOUNTER9 0xb09
+#define CSR_MHPMCOUNTER10 0xb0a
+#define CSR_MHPMCOUNTER11 0xb0b
+#define CSR_MHPMCOUNTER12 0xb0c
+#define CSR_MHPMCOUNTER13 0xb0d
+#define CSR_MHPMCOUNTER14 0xb0e
+#define CSR_MHPMCOUNTER15 0xb0f
+#define CSR_MHPMCOUNTER16 0xb10
+#define CSR_MHPMCOUNTER17 0xb11
+#define CSR_MHPMCOUNTER18 0xb12
+#define CSR_MHPMCOUNTER19 0xb13
+#define CSR_MHPMCOUNTER20 0xb14
+#define CSR_MHPMCOUNTER21 0xb15
+#define CSR_MHPMCOUNTER22 0xb16
+#define CSR_MHPMCOUNTER23 0xb17
+#define CSR_MHPMCOUNTER24 0xb18
+#define CSR_MHPMCOUNTER25 0xb19
+#define CSR_MHPMCOUNTER26 0xb1a
+#define CSR_MHPMCOUNTER27 0xb1b
+#define CSR_MHPMCOUNTER28 0xb1c
+#define CSR_MHPMCOUNTER29 0xb1d
+#define CSR_MHPMCOUNTER30 0xb1e
+#define CSR_MHPMCOUNTER31 0xb1f
+#define CSR_MHPMEVENT3 0x323
+#define CSR_MHPMEVENT4 0x324
+#define CSR_MHPMEVENT5 0x325
+#define CSR_MHPMEVENT6 0x326
+#define CSR_MHPMEVENT7 0x327
+#define CSR_MHPMEVENT8 0x328
+#define CSR_MHPMEVENT9 0x329
+#define CSR_MHPMEVENT10 0x32a
+#define CSR_MHPMEVENT11 0x32b
+#define CSR_MHPMEVENT12 0x32c
+#define CSR_MHPMEVENT13 0x32d
+#define CSR_MHPMEVENT14 0x32e
+#define CSR_MHPMEVENT15 0x32f
+#define CSR_MHPMEVENT16 0x330
+#define CSR_MHPMEVENT17 0x331
+#define CSR_MHPMEVENT18 0x332
+#define CSR_MHPMEVENT19 0x333
+#define CSR_MHPMEVENT20 0x334
+#define CSR_MHPMEVENT21 0x335
+#define CSR_MHPMEVENT22 0x336
+#define CSR_MHPMEVENT23 0x337
+#define CSR_MHPMEVENT24 0x338
+#define CSR_MHPMEVENT25 0x339
+#define CSR_MHPMEVENT26 0x33a
+#define CSR_MHPMEVENT27 0x33b
+#define CSR_MHPMEVENT28 0x33c
+#define CSR_MHPMEVENT29 0x33d
+#define CSR_MHPMEVENT30 0x33e
+#define CSR_MHPMEVENT31 0x33f
+#define CSR_MVENDORID 0xf11
+#define CSR_MARCHID 0xf12
+#define CSR_MIMPID 0xf13
+#define CSR_MHARTID 0xf14
+#define CSR_CYCLEH 0xc80
+#define CSR_TIMEH 0xc81
+#define CSR_INSTRETH 0xc82
+#define CSR_HPMCOUNTER3H 0xc83
+#define CSR_HPMCOUNTER4H 0xc84
+#define CSR_HPMCOUNTER5H 0xc85
+#define CSR_HPMCOUNTER6H 0xc86
+#define CSR_HPMCOUNTER7H 0xc87
+#define CSR_HPMCOUNTER8H 0xc88
+#define CSR_HPMCOUNTER9H 0xc89
+#define CSR_HPMCOUNTER10H 0xc8a
+#define CSR_HPMCOUNTER11H 0xc8b
+#define CSR_HPMCOUNTER12H 0xc8c
+#define CSR_HPMCOUNTER13H 0xc8d
+#define CSR_HPMCOUNTER14H 0xc8e
+#define CSR_HPMCOUNTER15H 0xc8f
+#define CSR_HPMCOUNTER16H 0xc90
+#define CSR_HPMCOUNTER17H 0xc91
+#define CSR_HPMCOUNTER18H 0xc92
+#define CSR_HPMCOUNTER19H 0xc93
+#define CSR_HPMCOUNTER20H 0xc94
+#define CSR_HPMCOUNTER21H 0xc95
+#define CSR_HPMCOUNTER22H 0xc96
+#define CSR_HPMCOUNTER23H 0xc97
+#define CSR_HPMCOUNTER24H 0xc98
+#define CSR_HPMCOUNTER25H 0xc99
+#define CSR_HPMCOUNTER26H 0xc9a
+#define CSR_HPMCOUNTER27H 0xc9b
+#define CSR_HPMCOUNTER28H 0xc9c
+#define CSR_HPMCOUNTER29H 0xc9d
+#define CSR_HPMCOUNTER30H 0xc9e
+#define CSR_HPMCOUNTER31H 0xc9f
+#define CSR_MCYCLEH 0xb80
+#define CSR_MINSTRETH 0xb82
+#define CSR_MHPMCOUNTER3H 0xb83
+#define CSR_MHPMCOUNTER4H 0xb84
+#define CSR_MHPMCOUNTER5H 0xb85
+#define CSR_MHPMCOUNTER6H 0xb86
+#define CSR_MHPMCOUNTER7H 0xb87
+#define CSR_MHPMCOUNTER8H 0xb88
+#define CSR_MHPMCOUNTER9H 0xb89
+#define CSR_MHPMCOUNTER10H 0xb8a
+#define CSR_MHPMCOUNTER11H 0xb8b
+#define CSR_MHPMCOUNTER12H 0xb8c
+#define CSR_MHPMCOUNTER13H 0xb8d
+#define CSR_MHPMCOUNTER14H 0xb8e
+#define CSR_MHPMCOUNTER15H 0xb8f
+#define CSR_MHPMCOUNTER16H 0xb90
+#define CSR_MHPMCOUNTER17H 0xb91
+#define CSR_MHPMCOUNTER18H 0xb92
+#define CSR_MHPMCOUNTER19H 0xb93
+#define CSR_MHPMCOUNTER20H 0xb94
+#define CSR_MHPMCOUNTER21H 0xb95
+#define CSR_MHPMCOUNTER22H 0xb96
+#define CSR_MHPMCOUNTER23H 0xb97
+#define CSR_MHPMCOUNTER24H 0xb98
+#define CSR_MHPMCOUNTER25H 0xb99
+#define CSR_MHPMCOUNTER26H 0xb9a
+#define CSR_MHPMCOUNTER27H 0xb9b
+#define CSR_MHPMCOUNTER28H 0xb9c
+#define CSR_MHPMCOUNTER29H 0xb9d
+#define CSR_MHPMCOUNTER30H 0xb9e
+#define CSR_MHPMCOUNTER31H 0xb9f
+#define CAUSE_MISALIGNED_FETCH 0x0
+#define CAUSE_FETCH_ACCESS 0x1
+#define CAUSE_ILLEGAL_INSTRUCTION 0x2
+#define CAUSE_BREAKPOINT 0x3
+#define CAUSE_MISALIGNED_LOAD 0x4
+#define CAUSE_LOAD_ACCESS 0x5
+#define CAUSE_MISALIGNED_STORE 0x6
+#define CAUSE_STORE_ACCESS 0x7
+#define CAUSE_USER_ECALL 0x8
+#define CAUSE_SUPERVISOR_ECALL 0x9
+#define CAUSE_HYPERVISOR_ECALL 0xa
+#define CAUSE_MACHINE_ECALL 0xb
+#define CAUSE_FETCH_PAGE_FAULT 0xc
+#define CAUSE_LOAD_PAGE_FAULT 0xd
+#define CAUSE_STORE_PAGE_FAULT 0xf
+#endif
+#ifdef DECLARE_INSN
+DECLARE_INSN(vsetvli, MATCH_VSETVLI, MASK_VSETVLI)
+DECLARE_INSN(vsetvl, MATCH_VSETVL, MASK_VSETVL)
+DECLARE_INSN(vlb_v, MATCH_VLB_V, MASK_VLB_V)
+DECLARE_INSN(vlh_v, MATCH_VLH_V, MASK_VLH_V)
+DECLARE_INSN(vlw_v, MATCH_VLW_V, MASK_VLW_V)
+DECLARE_INSN(vle_v, MATCH_VLE_V, MASK_VLE_V)
+DECLARE_INSN(vlbu_v, MATCH_VLBU_V, MASK_VLBU_V)
+DECLARE_INSN(vlhu_v, MATCH_VLHU_V, MASK_VLHU_V)
+DECLARE_INSN(vlwu_v, MATCH_VLWU_V, MASK_VLWU_V)
+DECLARE_INSN(vsb_v, MATCH_VSB_V, MASK_VSB_V)
+DECLARE_INSN(vsh_v, MATCH_VSH_V, MASK_VSH_V)
+DECLARE_INSN(vsw_v, MATCH_VSW_V, MASK_VSW_V)
+DECLARE_INSN(vse_v, MATCH_VSE_V, MASK_VSE_V)
+DECLARE_INSN(vlsb_v, MATCH_VLSB_V, MASK_VLSB_V)
+DECLARE_INSN(vlsh_v, MATCH_VLSH_V, MASK_VLSH_V)
+DECLARE_INSN(vlsw_v, MATCH_VLSW_V, MASK_VLSW_V)
+DECLARE_INSN(vlse_v, MATCH_VLSE_V, MASK_VLSE_V)
+DECLARE_INSN(vlsbu_v, MATCH_VLSBU_V, MASK_VLSBU_V)
+DECLARE_INSN(vlshu_v, MATCH_VLSHU_V, MASK_VLSHU_V)
+DECLARE_INSN(vlswu_v, MATCH_VLSWU_V, MASK_VLSWU_V)
+DECLARE_INSN(vssb_v, MATCH_VSSB_V, MASK_VSSB_V)
+DECLARE_INSN(vssh_v, MATCH_VSSH_V, MASK_VSSH_V)
+DECLARE_INSN(vssw_v, MATCH_VSSW_V, MASK_VSSW_V)
+DECLARE_INSN(vsse_v, MATCH_VSSE_V, MASK_VSSE_V)
+DECLARE_INSN(vlxb_v, MATCH_VLXB_V, MASK_VLXB_V)
+DECLARE_INSN(vlxh_v, MATCH_VLXH_V, MASK_VLXH_V)
+DECLARE_INSN(vlxw_v, MATCH_VLXW_V, MASK_VLXW_V)
+DECLARE_INSN(vlxe_v, MATCH_VLXE_V, MASK_VLXE_V)
+DECLARE_INSN(vlxbu_v, MATCH_VLXBU_V, MASK_VLXBU_V)
+DECLARE_INSN(vlxhu_v, MATCH_VLXHU_V, MASK_VLXHU_V)
+DECLARE_INSN(vlxwu_v, MATCH_VLXWU_V, MASK_VLXWU_V)
+DECLARE_INSN(vsxb_v, MATCH_VSXB_V, MASK_VSXB_V)
+DECLARE_INSN(vsxh_v, MATCH_VSXH_V, MASK_VSXH_V)
+DECLARE_INSN(vsxw_v, MATCH_VSXW_V, MASK_VSXW_V)
+DECLARE_INSN(vsxe_v, MATCH_VSXE_V, MASK_VSXE_V)
+DECLARE_INSN(vsuxb_v, MATCH_VSUXB_V, MASK_VSUXB_V)
+DECLARE_INSN(vsuxh_v, MATCH_VSUXH_V, MASK_VSUXH_V)
+DECLARE_INSN(vsuxw_v, MATCH_VSUXW_V, MASK_VSUXW_V)
+DECLARE_INSN(vsuxe_v, MATCH_VSUXE_V, MASK_VSUXE_V)
+DECLARE_INSN(vlbff_v, MATCH_VLBFF_V, MASK_VLBFF_V)
+DECLARE_INSN(vlhff_v, MATCH_VLHFF_V, MASK_VLHFF_V)
+DECLARE_INSN(vlwff_v, MATCH_VLWFF_V, MASK_VLWFF_V)
+DECLARE_INSN(vleff_v, MATCH_VLEFF_V, MASK_VLEFF_V)
+DECLARE_INSN(vlbuff_v, MATCH_VLBUFF_V, MASK_VLBUFF_V)
+DECLARE_INSN(vlhuff_v, MATCH_VLHUFF_V, MASK_VLHUFF_V)
+DECLARE_INSN(vlwuff_v, MATCH_VLWUFF_V, MASK_VLWUFF_V)
+DECLARE_INSN(vfadd_vf, MATCH_VFADD_VF, MASK_VFADD_VF)
+DECLARE_INSN(vfsub_vf, MATCH_VFSUB_VF, MASK_VFSUB_VF)
+DECLARE_INSN(vfmin_vf, MATCH_VFMIN_VF, MASK_VFMIN_VF)
+DECLARE_INSN(vfmax_vf, MATCH_VFMAX_VF, MASK_VFMAX_VF)
+DECLARE_INSN(vfsgnj_vf, MATCH_VFSGNJ_VF, MASK_VFSGNJ_VF)
+DECLARE_INSN(vfsgnjn_vf, MATCH_VFSGNJN_VF, MASK_VFSGNJN_VF)
+DECLARE_INSN(vfsgnjx_vf, MATCH_VFSGNJX_VF, MASK_VFSGNJX_VF)
+DECLARE_INSN(vfmv_s_f, MATCH_VFMV_S_F, MASK_VFMV_S_F)
+DECLARE_INSN(vfmerge_vfm, MATCH_VFMERGE_VFM, MASK_VFMERGE_VFM)
+DECLARE_INSN(vfmv_v_f, MATCH_VFMV_V_F, MASK_VFMV_V_F)
+DECLARE_INSN(vmfeq_vf, MATCH_VMFEQ_VF, MASK_VMFEQ_VF)
+DECLARE_INSN(vmfle_vf, MATCH_VMFLE_VF, MASK_VMFLE_VF)
+DECLARE_INSN(vmford_vf, MATCH_VMFORD_VF, MASK_VMFORD_VF)
+DECLARE_INSN(vmflt_vf, MATCH_VMFLT_VF, MASK_VMFLT_VF)
+DECLARE_INSN(vmfne_vf, MATCH_VMFNE_VF, MASK_VMFNE_VF)
+DECLARE_INSN(vmfgt_vf, MATCH_VMFGT_VF, MASK_VMFGT_VF)
+DECLARE_INSN(vmfge_vf, MATCH_VMFGE_VF, MASK_VMFGE_VF)
+DECLARE_INSN(vfdiv_vf, MATCH_VFDIV_VF, MASK_VFDIV_VF)
+DECLARE_INSN(vfrdiv_vf, MATCH_VFRDIV_VF, MASK_VFRDIV_VF)
+DECLARE_INSN(vfmul_vf, MATCH_VFMUL_VF, MASK_VFMUL_VF)
+DECLARE_INSN(vfrsub_vf, MATCH_VFRSUB_VF, MASK_VFRSUB_VF)
+DECLARE_INSN(vfmadd_vf, MATCH_VFMADD_VF, MASK_VFMADD_VF)
+DECLARE_INSN(vfnmadd_vf, MATCH_VFNMADD_VF, MASK_VFNMADD_VF)
+DECLARE_INSN(vfmsub_vf, MATCH_VFMSUB_VF, MASK_VFMSUB_VF)
+DECLARE_INSN(vfnmsub_vf, MATCH_VFNMSUB_VF, MASK_VFNMSUB_VF)
+DECLARE_INSN(vfmacc_vf, MATCH_VFMACC_VF, MASK_VFMACC_VF)
+DECLARE_INSN(vfnmacc_vf, MATCH_VFNMACC_VF, MASK_VFNMACC_VF)
+DECLARE_INSN(vfmsac_vf, MATCH_VFMSAC_VF, MASK_VFMSAC_VF)
+DECLARE_INSN(vfnmsac_vf, MATCH_VFNMSAC_VF, MASK_VFNMSAC_VF)
+DECLARE_INSN(vfwadd_vf, MATCH_VFWADD_VF, MASK_VFWADD_VF)
+DECLARE_INSN(vfwsub_vf, MATCH_VFWSUB_VF, MASK_VFWSUB_VF)
+DECLARE_INSN(vfwadd_wf, MATCH_VFWADD_WF, MASK_VFWADD_WF)
+DECLARE_INSN(vfwsub_wf, MATCH_VFWSUB_WF, MASK_VFWSUB_WF)
+DECLARE_INSN(vfwmul_vf, MATCH_VFWMUL_VF, MASK_VFWMUL_VF)
+DECLARE_INSN(vfwmacc_vf, MATCH_VFWMACC_VF, MASK_VFWMACC_VF)
+DECLARE_INSN(vfwnmacc_vf, MATCH_VFWNMACC_VF, MASK_VFWNMACC_VF)
+DECLARE_INSN(vfwmsac_vf, MATCH_VFWMSAC_VF, MASK_VFWMSAC_VF)
+DECLARE_INSN(vfwnmsac_vf, MATCH_VFWNMSAC_VF, MASK_VFWNMSAC_VF)
+DECLARE_INSN(vfadd_vv, MATCH_VFADD_VV, MASK_VFADD_VV)
+DECLARE_INSN(vfredsum_vs, MATCH_VFREDSUM_VS, MASK_VFREDSUM_VS)
+DECLARE_INSN(vfsub_vv, MATCH_VFSUB_VV, MASK_VFSUB_VV)
+DECLARE_INSN(vfredosum_vs, MATCH_VFREDOSUM_VS, MASK_VFREDOSUM_VS)
+DECLARE_INSN(vfmin_vv, MATCH_VFMIN_VV, MASK_VFMIN_VV)
+DECLARE_INSN(vfredmin_vs, MATCH_VFREDMIN_VS, MASK_VFREDMIN_VS)
+DECLARE_INSN(vfmax_vv, MATCH_VFMAX_VV, MASK_VFMAX_VV)
+DECLARE_INSN(vfredmax_vs, MATCH_VFREDMAX_VS, MASK_VFREDMAX_VS)
+DECLARE_INSN(vfsgnj_vv, MATCH_VFSGNJ_VV, MASK_VFSGNJ_VV)
+DECLARE_INSN(vfsgnjn_vv, MATCH_VFSGNJN_VV, MASK_VFSGNJN_VV)
+DECLARE_INSN(vfsgnjx_vv, MATCH_VFSGNJX_VV, MASK_VFSGNJX_VV)
+DECLARE_INSN(vfmv_f_s, MATCH_VFMV_F_S, MASK_VFMV_F_S)
+DECLARE_INSN(vmfeq_vv, MATCH_VMFEQ_VV, MASK_VMFEQ_VV)
+DECLARE_INSN(vmfle_vv, MATCH_VMFLE_VV, MASK_VMFLE_VV)
+DECLARE_INSN(vmford_vv, MATCH_VMFORD_VV, MASK_VMFORD_VV)
+DECLARE_INSN(vmflt_vv, MATCH_VMFLT_VV, MASK_VMFLT_VV)
+DECLARE_INSN(vmfne_vv, MATCH_VMFNE_VV, MASK_VMFNE_VV)
+DECLARE_INSN(vfdiv_vv, MATCH_VFDIV_VV, MASK_VFDIV_VV)
+DECLARE_INSN(vfmul_vv, MATCH_VFMUL_VV, MASK_VFMUL_VV)
+DECLARE_INSN(vfmadd_vv, MATCH_VFMADD_VV, MASK_VFMADD_VV)
+DECLARE_INSN(vfnmadd_vv, MATCH_VFNMADD_VV, MASK_VFNMADD_VV)
+DECLARE_INSN(vfmsub_vv, MATCH_VFMSUB_VV, MASK_VFMSUB_VV)
+DECLARE_INSN(vfnmsub_vv, MATCH_VFNMSUB_VV, MASK_VFNMSUB_VV)
+DECLARE_INSN(vfmacc_vv, MATCH_VFMACC_VV, MASK_VFMACC_VV)
+DECLARE_INSN(vfnmacc_vv, MATCH_VFNMACC_VV, MASK_VFNMACC_VV)
+DECLARE_INSN(vfmsac_vv, MATCH_VFMSAC_VV, MASK_VFMSAC_VV)
+DECLARE_INSN(vfnmsac_vv, MATCH_VFNMSAC_VV, MASK_VFNMSAC_VV)
+DECLARE_INSN(vfcvt_xu_f_v, MATCH_VFCVT_XU_F_V, MASK_VFCVT_XU_F_V)
+DECLARE_INSN(vfcvt_x_f_v, MATCH_VFCVT_X_F_V, MASK_VFCVT_X_F_V)
+DECLARE_INSN(vfcvt_f_xu_v, MATCH_VFCVT_F_XU_V, MASK_VFCVT_F_XU_V)
+DECLARE_INSN(vfcvt_f_x_v, MATCH_VFCVT_F_X_V, MASK_VFCVT_F_X_V)
+DECLARE_INSN(vfwcvt_xu_f_v, MATCH_VFWCVT_XU_F_V, MASK_VFWCVT_XU_F_V)
+DECLARE_INSN(vfwcvt_x_f_v, MATCH_VFWCVT_X_F_V, MASK_VFWCVT_X_F_V)
+DECLARE_INSN(vfwcvt_f_xu_v, MATCH_VFWCVT_F_XU_V, MASK_VFWCVT_F_XU_V)
+DECLARE_INSN(vfwcvt_f_x_v, MATCH_VFWCVT_F_X_V, MASK_VFWCVT_F_X_V)
+DECLARE_INSN(vfwcvt_f_f_v, MATCH_VFWCVT_F_F_V, MASK_VFWCVT_F_F_V)
+DECLARE_INSN(vfncvt_xu_f_v, MATCH_VFNCVT_XU_F_V, MASK_VFNCVT_XU_F_V)
+DECLARE_INSN(vfncvt_x_f_v, MATCH_VFNCVT_X_F_V, MASK_VFNCVT_X_F_V)
+DECLARE_INSN(vfncvt_f_xu_v, MATCH_VFNCVT_F_XU_V, MASK_VFNCVT_F_XU_V)
+DECLARE_INSN(vfncvt_f_x_v, MATCH_VFNCVT_F_X_V, MASK_VFNCVT_F_X_V)
+DECLARE_INSN(vfncvt_f_f_v, MATCH_VFNCVT_F_F_V, MASK_VFNCVT_F_F_V)
+DECLARE_INSN(vfsqrt_v, MATCH_VFSQRT_V, MASK_VFSQRT_V)
+DECLARE_INSN(vfclass_v, MATCH_VFCLASS_V, MASK_VFCLASS_V)
+DECLARE_INSN(vfwadd_vv, MATCH_VFWADD_VV, MASK_VFWADD_VV)
+DECLARE_INSN(vfwredsum_vs, MATCH_VFWREDSUM_VS, MASK_VFWREDSUM_VS)
+DECLARE_INSN(vfwsub_vv, MATCH_VFWSUB_VV, MASK_VFWSUB_VV)
+DECLARE_INSN(vfwredosum_vs, MATCH_VFWREDOSUM_VS, MASK_VFWREDOSUM_VS)
+DECLARE_INSN(vfwadd_wv, MATCH_VFWADD_WV, MASK_VFWADD_WV)
+DECLARE_INSN(vfwsub_wv, MATCH_VFWSUB_WV, MASK_VFWSUB_WV)
+DECLARE_INSN(vfwmul_vv, MATCH_VFWMUL_VV, MASK_VFWMUL_VV)
+DECLARE_INSN(vfdot_vv, MATCH_VFDOT_VV, MASK_VFDOT_VV)
+DECLARE_INSN(vfwmacc_vv, MATCH_VFWMACC_VV, MASK_VFWMACC_VV)
+DECLARE_INSN(vfwnmacc_vv, MATCH_VFWNMACC_VV, MASK_VFWNMACC_VV)
+DECLARE_INSN(vfwmsac_vv, MATCH_VFWMSAC_VV, MASK_VFWMSAC_VV)
+DECLARE_INSN(vfwnmsac_vv, MATCH_VFWNMSAC_VV, MASK_VFWNMSAC_VV)
+DECLARE_INSN(vadd_vx, MATCH_VADD_VX, MASK_VADD_VX)
+DECLARE_INSN(vsub_vx, MATCH_VSUB_VX, MASK_VSUB_VX)
+DECLARE_INSN(vrsub_vx, MATCH_VRSUB_VX, MASK_VRSUB_VX)
+DECLARE_INSN(vminu_vx, MATCH_VMINU_VX, MASK_VMINU_VX)
+DECLARE_INSN(vmin_vx, MATCH_VMIN_VX, MASK_VMIN_VX)
+DECLARE_INSN(vmaxu_vx, MATCH_VMAXU_VX, MASK_VMAXU_VX)
+DECLARE_INSN(vmax_vx, MATCH_VMAX_VX, MASK_VMAX_VX)
+DECLARE_INSN(vand_vx, MATCH_VAND_VX, MASK_VAND_VX)
+DECLARE_INSN(vor_vx, MATCH_VOR_VX, MASK_VOR_VX)
+DECLARE_INSN(vxor_vx, MATCH_VXOR_VX, MASK_VXOR_VX)
+DECLARE_INSN(vrgather_vx, MATCH_VRGATHER_VX, MASK_VRGATHER_VX)
+DECLARE_INSN(vslideup_vx, MATCH_VSLIDEUP_VX, MASK_VSLIDEUP_VX)
+DECLARE_INSN(vslidedown_vx, MATCH_VSLIDEDOWN_VX, MASK_VSLIDEDOWN_VX)
+DECLARE_INSN(vadc_vxm, MATCH_VADC_VXM, MASK_VADC_VXM)
+DECLARE_INSN(vmadc_vxm, MATCH_VMADC_VXM, MASK_VMADC_VXM)
+DECLARE_INSN(vsbc_vxm, MATCH_VSBC_VXM, MASK_VSBC_VXM)
+DECLARE_INSN(vmsbc_vxm, MATCH_VMSBC_VXM, MASK_VMSBC_VXM)
+DECLARE_INSN(vmerge_vxm, MATCH_VMERGE_VXM, MASK_VMERGE_VXM)
+DECLARE_INSN(vmv_v_x, MATCH_VMV_V_X, MASK_VMV_V_X)
+DECLARE_INSN(vmseq_vx, MATCH_VMSEQ_VX, MASK_VMSEQ_VX)
+DECLARE_INSN(vmsne_vx, MATCH_VMSNE_VX, MASK_VMSNE_VX)
+DECLARE_INSN(vmsltu_vx, MATCH_VMSLTU_VX, MASK_VMSLTU_VX)
+DECLARE_INSN(vmslt_vx, MATCH_VMSLT_VX, MASK_VMSLT_VX)
+DECLARE_INSN(vmsleu_vx, MATCH_VMSLEU_VX, MASK_VMSLEU_VX)
+DECLARE_INSN(vmsle_vx, MATCH_VMSLE_VX, MASK_VMSLE_VX)
+DECLARE_INSN(vmsgtu_vx, MATCH_VMSGTU_VX, MASK_VMSGTU_VX)
+DECLARE_INSN(vmsgt_vx, MATCH_VMSGT_VX, MASK_VMSGT_VX)
+DECLARE_INSN(vsaddu_vx, MATCH_VSADDU_VX, MASK_VSADDU_VX)
+DECLARE_INSN(vsadd_vx, MATCH_VSADD_VX, MASK_VSADD_VX)
+DECLARE_INSN(vssubu_vx, MATCH_VSSUBU_VX, MASK_VSSUBU_VX)
+DECLARE_INSN(vssub_vx, MATCH_VSSUB_VX, MASK_VSSUB_VX)
+DECLARE_INSN(vaadd_vx, MATCH_VAADD_VX, MASK_VAADD_VX)
+DECLARE_INSN(vsll_vx, MATCH_VSLL_VX, MASK_VSLL_VX)
+DECLARE_INSN(vasub_vx, MATCH_VASUB_VX, MASK_VASUB_VX)
+DECLARE_INSN(vsmul_vx, MATCH_VSMUL_VX, MASK_VSMUL_VX)
+DECLARE_INSN(vsrl_vx, MATCH_VSRL_VX, MASK_VSRL_VX)
+DECLARE_INSN(vsra_vx, MATCH_VSRA_VX, MASK_VSRA_VX)
+DECLARE_INSN(vssrl_vx, MATCH_VSSRL_VX, MASK_VSSRL_VX)
+DECLARE_INSN(vssra_vx, MATCH_VSSRA_VX, MASK_VSSRA_VX)
+DECLARE_INSN(vnsrl_vx, MATCH_VNSRL_VX, MASK_VNSRL_VX)
+DECLARE_INSN(vnsra_vx, MATCH_VNSRA_VX, MASK_VNSRA_VX)
+DECLARE_INSN(vnclipu_vx, MATCH_VNCLIPU_VX, MASK_VNCLIPU_VX)
+DECLARE_INSN(vnclip_vx, MATCH_VNCLIP_VX, MASK_VNCLIP_VX)
+DECLARE_INSN(vwsmaccu_vx, MATCH_VWSMACCU_VX, MASK_VWSMACCU_VX)
+DECLARE_INSN(vwsmacc_vx, MATCH_VWSMACC_VX, MASK_VWSMACC_VX)
+DECLARE_INSN(vwsmaccsu_vx, MATCH_VWSMACCSU_VX, MASK_VWSMACCSU_VX)
+DECLARE_INSN(vwsmaccus_vx, MATCH_VWSMACCUS_VX, MASK_VWSMACCUS_VX)
+DECLARE_INSN(vadd_vv, MATCH_VADD_VV, MASK_VADD_VV)
+DECLARE_INSN(vsub_vv, MATCH_VSUB_VV, MASK_VSUB_VV)
+DECLARE_INSN(vminu_vv, MATCH_VMINU_VV, MASK_VMINU_VV)
+DECLARE_INSN(vmin_vv, MATCH_VMIN_VV, MASK_VMIN_VV)
+DECLARE_INSN(vmaxu_vv, MATCH_VMAXU_VV, MASK_VMAXU_VV)
+DECLARE_INSN(vmax_vv, MATCH_VMAX_VV, MASK_VMAX_VV)
+DECLARE_INSN(vand_vv, MATCH_VAND_VV, MASK_VAND_VV)
+DECLARE_INSN(vor_vv, MATCH_VOR_VV, MASK_VOR_VV)
+DECLARE_INSN(vxor_vv, MATCH_VXOR_VV, MASK_VXOR_VV)
+DECLARE_INSN(vrgather_vv, MATCH_VRGATHER_VV, MASK_VRGATHER_VV)
+DECLARE_INSN(vadc_vvm, MATCH_VADC_VVM, MASK_VADC_VVM)
+DECLARE_INSN(vmadc_vvm, MATCH_VMADC_VVM, MASK_VMADC_VVM)
+DECLARE_INSN(vsbc_vvm, MATCH_VSBC_VVM, MASK_VSBC_VVM)
+DECLARE_INSN(vmsbc_vvm, MATCH_VMSBC_VVM, MASK_VMSBC_VVM)
+DECLARE_INSN(vmerge_vvm, MATCH_VMERGE_VVM, MASK_VMERGE_VVM)
+DECLARE_INSN(vmv_v_v, MATCH_VMV_V_V, MASK_VMV_V_V)
+DECLARE_INSN(vmseq_vv, MATCH_VMSEQ_VV, MASK_VMSEQ_VV)
+DECLARE_INSN(vmsne_vv, MATCH_VMSNE_VV, MASK_VMSNE_VV)
+DECLARE_INSN(vmsltu_vv, MATCH_VMSLTU_VV, MASK_VMSLTU_VV)
+DECLARE_INSN(vmslt_vv, MATCH_VMSLT_VV, MASK_VMSLT_VV)
+DECLARE_INSN(vmsleu_vv, MATCH_VMSLEU_VV, MASK_VMSLEU_VV)
+DECLARE_INSN(vmsle_vv, MATCH_VMSLE_VV, MASK_VMSLE_VV)
+DECLARE_INSN(vsaddu_vv, MATCH_VSADDU_VV, MASK_VSADDU_VV)
+DECLARE_INSN(vsadd_vv, MATCH_VSADD_VV, MASK_VSADD_VV)
+DECLARE_INSN(vssubu_vv, MATCH_VSSUBU_VV, MASK_VSSUBU_VV)
+DECLARE_INSN(vssub_vv, MATCH_VSSUB_VV, MASK_VSSUB_VV)
+DECLARE_INSN(vaadd_vv, MATCH_VAADD_VV, MASK_VAADD_VV)
+DECLARE_INSN(vsll_vv, MATCH_VSLL_VV, MASK_VSLL_VV)
+DECLARE_INSN(vasub_vv, MATCH_VASUB_VV, MASK_VASUB_VV)
+DECLARE_INSN(vsmul_vv, MATCH_VSMUL_VV, MASK_VSMUL_VV)
+DECLARE_INSN(vsrl_vv, MATCH_VSRL_VV, MASK_VSRL_VV)
+DECLARE_INSN(vsra_vv, MATCH_VSRA_VV, MASK_VSRA_VV)
+DECLARE_INSN(vssrl_vv, MATCH_VSSRL_VV, MASK_VSSRL_VV)
+DECLARE_INSN(vssra_vv, MATCH_VSSRA_VV, MASK_VSSRA_VV)
+DECLARE_INSN(vnsrl_vv, MATCH_VNSRL_VV, MASK_VNSRL_VV)
+DECLARE_INSN(vnsra_vv, MATCH_VNSRA_VV, MASK_VNSRA_VV)
+DECLARE_INSN(vnclipu_vv, MATCH_VNCLIPU_VV, MASK_VNCLIPU_VV)
+DECLARE_INSN(vnclip_vv, MATCH_VNCLIP_VV, MASK_VNCLIP_VV)
+DECLARE_INSN(vwredsumu_vs, MATCH_VWREDSUMU_VS, MASK_VWREDSUMU_VS)
+DECLARE_INSN(vwredsum_vs, MATCH_VWREDSUM_VS, MASK_VWREDSUM_VS)
+DECLARE_INSN(vdotu_vv, MATCH_VDOTU_VV, MASK_VDOTU_VV)
+DECLARE_INSN(vdot_vv, MATCH_VDOT_VV, MASK_VDOT_VV)
+DECLARE_INSN(vwsmaccu_vv, MATCH_VWSMACCU_VV, MASK_VWSMACCU_VV)
+DECLARE_INSN(vwsmacc_vv, MATCH_VWSMACC_VV, MASK_VWSMACC_VV)
+DECLARE_INSN(vwsmaccsu_vv, MATCH_VWSMACCSU_VV, MASK_VWSMACCSU_VV)
+DECLARE_INSN(vadd_vi, MATCH_VADD_VI, MASK_VADD_VI)
+DECLARE_INSN(vrsub_vi, MATCH_VRSUB_VI, MASK_VRSUB_VI)
+DECLARE_INSN(vand_vi, MATCH_VAND_VI, MASK_VAND_VI)
+DECLARE_INSN(vor_vi, MATCH_VOR_VI, MASK_VOR_VI)
+DECLARE_INSN(vxor_vi, MATCH_VXOR_VI, MASK_VXOR_VI)
+DECLARE_INSN(vrgather_vi, MATCH_VRGATHER_VI, MASK_VRGATHER_VI)
+DECLARE_INSN(vslideup_vi, MATCH_VSLIDEUP_VI, MASK_VSLIDEUP_VI)
+DECLARE_INSN(vslidedown_vi, MATCH_VSLIDEDOWN_VI, MASK_VSLIDEDOWN_VI)
+DECLARE_INSN(vadc_vim, MATCH_VADC_VIM, MASK_VADC_VIM)
+DECLARE_INSN(vmadc_vim, MATCH_VMADC_VIM, MASK_VMADC_VIM)
+DECLARE_INSN(vmerge_vim, MATCH_VMERGE_VIM, MASK_VMERGE_VIM)
+DECLARE_INSN(vmv_v_i, MATCH_VMV_V_I, MASK_VMV_V_I)
+DECLARE_INSN(vmseq_vi, MATCH_VMSEQ_VI, MASK_VMSEQ_VI)
+DECLARE_INSN(vmsne_vi, MATCH_VMSNE_VI, MASK_VMSNE_VI)
+DECLARE_INSN(vmsleu_vi, MATCH_VMSLEU_VI, MASK_VMSLEU_VI)
+DECLARE_INSN(vmsle_vi, MATCH_VMSLE_VI, MASK_VMSLE_VI)
+DECLARE_INSN(vmsgtu_vi, MATCH_VMSGTU_VI, MASK_VMSGTU_VI)
+DECLARE_INSN(vmsgt_vi, MATCH_VMSGT_VI, MASK_VMSGT_VI)
+DECLARE_INSN(vsaddu_vi, MATCH_VSADDU_VI, MASK_VSADDU_VI)
+DECLARE_INSN(vsadd_vi, MATCH_VSADD_VI, MASK_VSADD_VI)
+DECLARE_INSN(vaadd_vi, MATCH_VAADD_VI, MASK_VAADD_VI)
+DECLARE_INSN(vsll_vi, MATCH_VSLL_VI, MASK_VSLL_VI)
+DECLARE_INSN(vsrl_vi, MATCH_VSRL_VI, MASK_VSRL_VI)
+DECLARE_INSN(vsra_vi, MATCH_VSRA_VI, MASK_VSRA_VI)
+DECLARE_INSN(vssrl_vi, MATCH_VSSRL_VI, MASK_VSSRL_VI)
+DECLARE_INSN(vssra_vi, MATCH_VSSRA_VI, MASK_VSSRA_VI)
+DECLARE_INSN(vnsrl_vi, MATCH_VNSRL_VI, MASK_VNSRL_VI)
+DECLARE_INSN(vnsra_vi, MATCH_VNSRA_VI, MASK_VNSRA_VI)
+DECLARE_INSN(vnclipu_vi, MATCH_VNCLIPU_VI, MASK_VNCLIPU_VI)
+DECLARE_INSN(vnclip_vi, MATCH_VNCLIP_VI, MASK_VNCLIP_VI)
+DECLARE_INSN(vredsum_vs, MATCH_VREDSUM_VS, MASK_VREDSUM_VS)
+DECLARE_INSN(vredand_vs, MATCH_VREDAND_VS, MASK_VREDAND_VS)
+DECLARE_INSN(vredor_vs, MATCH_VREDOR_VS, MASK_VREDOR_VS)
+DECLARE_INSN(vredxor_vs, MATCH_VREDXOR_VS, MASK_VREDXOR_VS)
+DECLARE_INSN(vredminu_vs, MATCH_VREDMINU_VS, MASK_VREDMINU_VS)
+DECLARE_INSN(vredmin_vs, MATCH_VREDMIN_VS, MASK_VREDMIN_VS)
+DECLARE_INSN(vredmaxu_vs, MATCH_VREDMAXU_VS, MASK_VREDMAXU_VS)
+DECLARE_INSN(vredmax_vs, MATCH_VREDMAX_VS, MASK_VREDMAX_VS)
+DECLARE_INSN(vext_x_v, MATCH_VEXT_X_V, MASK_VEXT_X_V)
+DECLARE_INSN(vmpopc_m, MATCH_VMPOPC_M, MASK_VMPOPC_M)
+DECLARE_INSN(vmfirst_m, MATCH_VMFIRST_M, MASK_VMFIRST_M)
+DECLARE_INSN(vcompress_vm, MATCH_VCOMPRESS_VM, MASK_VCOMPRESS_VM)
+DECLARE_INSN(vmandnot_mm, MATCH_VMANDNOT_MM, MASK_VMANDNOT_MM)
+DECLARE_INSN(vmand_mm, MATCH_VMAND_MM, MASK_VMAND_MM)
+DECLARE_INSN(vmor_mm, MATCH_VMOR_MM, MASK_VMOR_MM)
+DECLARE_INSN(vmxor_mm, MATCH_VMXOR_MM, MASK_VMXOR_MM)
+DECLARE_INSN(vmornot_mm, MATCH_VMORNOT_MM, MASK_VMORNOT_MM)
+DECLARE_INSN(vmnand_mm, MATCH_VMNAND_MM, MASK_VMNAND_MM)
+DECLARE_INSN(vmnor_mm, MATCH_VMNOR_MM, MASK_VMNOR_MM)
+DECLARE_INSN(vmxnor_mm, MATCH_VMXNOR_MM, MASK_VMXNOR_MM)
+DECLARE_INSN(vmsbf_m, MATCH_VMSBF_M, MASK_VMSBF_M)
+DECLARE_INSN(vmsof_m, MATCH_VMSOF_M, MASK_VMSOF_M)
+DECLARE_INSN(vmsif_m, MATCH_VMSIF_M, MASK_VMSIF_M)
+DECLARE_INSN(viota_m, MATCH_VIOTA_M, MASK_VIOTA_M)
+DECLARE_INSN(vid_v, MATCH_VID_V, MASK_VID_V)
+DECLARE_INSN(vdivu_vv, MATCH_VDIVU_VV, MASK_VDIVU_VV)
+DECLARE_INSN(vdiv_vv, MATCH_VDIV_VV, MASK_VDIV_VV)
+DECLARE_INSN(vremu_vv, MATCH_VREMU_VV, MASK_VREMU_VV)
+DECLARE_INSN(vrem_vv, MATCH_VREM_VV, MASK_VREM_VV)
+DECLARE_INSN(vmulhu_vv, MATCH_VMULHU_VV, MASK_VMULHU_VV)
+DECLARE_INSN(vmul_vv, MATCH_VMUL_VV, MASK_VMUL_VV)
+DECLARE_INSN(vmulhsu_vv, MATCH_VMULHSU_VV, MASK_VMULHSU_VV)
+DECLARE_INSN(vmulh_vv, MATCH_VMULH_VV, MASK_VMULH_VV)
+DECLARE_INSN(vmadd_vv, MATCH_VMADD_VV, MASK_VMADD_VV)
+DECLARE_INSN(vnmsub_vv, MATCH_VNMSUB_VV, MASK_VNMSUB_VV)
+DECLARE_INSN(vmacc_vv, MATCH_VMACC_VV, MASK_VMACC_VV)
+DECLARE_INSN(vnmsac_vv, MATCH_VNMSAC_VV, MASK_VNMSAC_VV)
+DECLARE_INSN(vwaddu_vv, MATCH_VWADDU_VV, MASK_VWADDU_VV)
+DECLARE_INSN(vwadd_vv, MATCH_VWADD_VV, MASK_VWADD_VV)
+DECLARE_INSN(vwsubu_vv, MATCH_VWSUBU_VV, MASK_VWSUBU_VV)
+DECLARE_INSN(vwsub_vv, MATCH_VWSUB_VV, MASK_VWSUB_VV)
+DECLARE_INSN(vwaddu_wv, MATCH_VWADDU_WV, MASK_VWADDU_WV)
+DECLARE_INSN(vwadd_wv, MATCH_VWADD_WV, MASK_VWADD_WV)
+DECLARE_INSN(vwsubu_wv, MATCH_VWSUBU_WV, MASK_VWSUBU_WV)
+DECLARE_INSN(vwsub_wv, MATCH_VWSUB_WV, MASK_VWSUB_WV)
+DECLARE_INSN(vwmulu_vv, MATCH_VWMULU_VV, MASK_VWMULU_VV)
+DECLARE_INSN(vwmulsu_vv, MATCH_VWMULSU_VV, MASK_VWMULSU_VV)
+DECLARE_INSN(vwmul_vv, MATCH_VWMUL_VV, MASK_VWMUL_VV)
+DECLARE_INSN(vwmaccu_vv, MATCH_VWMACCU_VV, MASK_VWMACCU_VV)
+DECLARE_INSN(vwmacc_vv, MATCH_VWMACC_VV, MASK_VWMACC_VV)
+DECLARE_INSN(vwmaccsu_vv, MATCH_VWMACCSU_VV, MASK_VWMACCSU_VV)
+DECLARE_INSN(vmv_s_x, MATCH_VMV_S_X, MASK_VMV_S_X)
+DECLARE_INSN(vslide1up_vx, MATCH_VSLIDE1UP_VX, MASK_VSLIDE1UP_VX)
+DECLARE_INSN(vslide1down_vx, MATCH_VSLIDE1DOWN_VX, MASK_VSLIDE1DOWN_VX)
+DECLARE_INSN(vdivu_vx, MATCH_VDIVU_VX, MASK_VDIVU_VX)
+DECLARE_INSN(vdiv_vx, MATCH_VDIV_VX, MASK_VDIV_VX)
+DECLARE_INSN(vremu_vx, MATCH_VREMU_VX, MASK_VREMU_VX)
+DECLARE_INSN(vrem_vx, MATCH_VREM_VX, MASK_VREM_VX)
+DECLARE_INSN(vmulhu_vx, MATCH_VMULHU_VX, MASK_VMULHU_VX)
+DECLARE_INSN(vmul_vx, MATCH_VMUL_VX, MASK_VMUL_VX)
+DECLARE_INSN(vmulhsu_vx, MATCH_VMULHSU_VX, MASK_VMULHSU_VX)
+DECLARE_INSN(vmulh_vx, MATCH_VMULH_VX, MASK_VMULH_VX)
+DECLARE_INSN(vmadd_vx, MATCH_VMADD_VX, MASK_VMADD_VX)
+DECLARE_INSN(vnmsub_vx, MATCH_VNMSUB_VX, MASK_VNMSUB_VX)
+DECLARE_INSN(vmacc_vx, MATCH_VMACC_VX, MASK_VMACC_VX)
+DECLARE_INSN(vnmsac_vx, MATCH_VNMSAC_VX, MASK_VNMSAC_VX)
+DECLARE_INSN(vwaddu_vx, MATCH_VWADDU_VX, MASK_VWADDU_VX)
+DECLARE_INSN(vwadd_vx, MATCH_VWADD_VX, MASK_VWADD_VX)
+DECLARE_INSN(vwsubu_vx, MATCH_VWSUBU_VX, MASK_VWSUBU_VX)
+DECLARE_INSN(vwsub_vx, MATCH_VWSUB_VX, MASK_VWSUB_VX)
+DECLARE_INSN(vwaddu_wx, MATCH_VWADDU_WX, MASK_VWADDU_WX)
+DECLARE_INSN(vwadd_wx, MATCH_VWADD_WX, MASK_VWADD_WX)
+DECLARE_INSN(vwsubu_wx, MATCH_VWSUBU_WX, MASK_VWSUBU_WX)
+DECLARE_INSN(vwsub_wx, MATCH_VWSUB_WX, MASK_VWSUB_WX)
+DECLARE_INSN(vwmulu_vx, MATCH_VWMULU_VX, MASK_VWMULU_VX)
+DECLARE_INSN(vwmulsu_vx, MATCH_VWMULSU_VX, MASK_VWMULSU_VX)
+DECLARE_INSN(vwmul_vx, MATCH_VWMUL_VX, MASK_VWMUL_VX)
+DECLARE_INSN(vwmaccu_vx, MATCH_VWMACCU_VX, MASK_VWMACCU_VX)
+DECLARE_INSN(vwmacc_vx, MATCH_VWMACC_VX, MASK_VWMACC_VX)
+DECLARE_INSN(vwmaccsu_vx, MATCH_VWMACCSU_VX, MASK_VWMACCSU_VX)
+DECLARE_INSN(vwmaccus_vx, MATCH_VWMACCUS_VX, MASK_VWMACCUS_VX)
+DECLARE_INSN(vamoswapw_v, MATCH_VAMOSWAPW_V, MASK_VAMOSWAPW_V)
+DECLARE_INSN(vamoaddw_v, MATCH_VAMOADDW_V, MASK_VAMOADDW_V)
+DECLARE_INSN(vamoxorw_v, MATCH_VAMOXORW_V, MASK_VAMOXORW_V)
+DECLARE_INSN(vamoandw_v, MATCH_VAMOANDW_V, MASK_VAMOANDW_V)
+DECLARE_INSN(vamoorw_v, MATCH_VAMOORW_V, MASK_VAMOORW_V)
+DECLARE_INSN(vamominw_v, MATCH_VAMOMINW_V, MASK_VAMOMINW_V)
+DECLARE_INSN(vamomaxw_v, MATCH_VAMOMAXW_V, MASK_VAMOMAXW_V)
+DECLARE_INSN(vamominuw_v, MATCH_VAMOMINUW_V, MASK_VAMOMINUW_V)
+DECLARE_INSN(vamomaxuw_v, MATCH_VAMOMAXUW_V, MASK_VAMOMAXUW_V)
+DECLARE_INSN(vamoswapd_v, MATCH_VAMOSWAPD_V, MASK_VAMOSWAPD_V)
+DECLARE_INSN(vamoaddd_v, MATCH_VAMOADDD_V, MASK_VAMOADDD_V)
+DECLARE_INSN(vamoxord_v, MATCH_VAMOXORD_V, MASK_VAMOXORD_V)
+DECLARE_INSN(vamoandd_v, MATCH_VAMOANDD_V, MASK_VAMOANDD_V)
+DECLARE_INSN(vamoord_v, MATCH_VAMOORD_V, MASK_VAMOORD_V)
+DECLARE_INSN(vamomind_v, MATCH_VAMOMIND_V, MASK_VAMOMIND_V)
+DECLARE_INSN(vamomaxd_v, MATCH_VAMOMAXD_V, MASK_VAMOMAXD_V)
+DECLARE_INSN(vamominud_v, MATCH_VAMOMINUD_V, MASK_VAMOMINUD_V)
+DECLARE_INSN(vamomaxud_v, MATCH_VAMOMAXUD_V, MASK_VAMOMAXUD_V)
+#ifdef ZVAMO
+DECLARE_INSN(vamoswapq_v, MATCH_VAMOSWAPQ_V, MASK_VAMOSWAPQ_V)
+DECLARE_INSN(vamoaddq_v, MATCH_VAMOADDQ_V, MASK_VAMOADDQ_V)
+DECLARE_INSN(vamoxorq_v, MATCH_VAMOXORQ_V, MASK_VAMOXORQ_V)
+DECLARE_INSN(vamoandq_v, MATCH_VAMOANDQ_V, MASK_VAMOANDQ_V)
+DECLARE_INSN(vamoorq_v, MATCH_VAMOORQ_V, MASK_VAMOORQ_V)
+DECLARE_INSN(vamominq_v, MATCH_VAMOMINQ_V, MASK_VAMOMINQ_V)
+DECLARE_INSN(vamomaxq_v, MATCH_VAMOMAXQ_V, MASK_VAMOMAXQ_V)
+DECLARE_INSN(vamominuq_v, MATCH_VAMOMINUQ_V, MASK_VAMOMINUQ_V)
+DECLARE_INSN(vamomaxuq_v, MATCH_VAMOMAXUQ_V, MASK_VAMOMAXUQ_V)
+#endif
+#endif
diff --git a/arch/riscv/kernel/soft_vector/insn_list.h b/arch/riscv/kernel/soft_vector/insn_list.h
new file mode 100644
index 000000000000..173203e3b5e0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insn_list.h
@@ -0,0 +1,361 @@
+/*generated by shell*/
+DEFINE_INSN(vaadd_vi)
+DEFINE_INSN(vaadd_vv)
+DEFINE_INSN(vaadd_vx)
+DEFINE_INSN(vadc_vim)
+DEFINE_INSN(vadc_vvm)
+DEFINE_INSN(vadc_vxm)
+DEFINE_INSN(vadd_vi)
+DEFINE_INSN(vadd_vv)
+DEFINE_INSN(vadd_vx)
+DEFINE_INSN(vand_vi)
+DEFINE_INSN(vand_vv)
+DEFINE_INSN(vand_vx)
+DEFINE_INSN(vasub_vv)
+DEFINE_INSN(vasub_vx)
+DEFINE_INSN(vcompress_vm)
+DEFINE_INSN(vdiv_vv)
+DEFINE_INSN(vdiv_vx)
+DEFINE_INSN(vdivu_vv)
+DEFINE_INSN(vdivu_vx)
+DEFINE_INSN(vdot_vv)
+DEFINE_INSN(vdotu_vv)
+DEFINE_INSN(vext_x_v)
+DEFINE_INSN(vid_v)
+DEFINE_INSN(viota_m)
+DEFINE_INSN(vmacc_vv)
+DEFINE_INSN(vmacc_vx)
+DEFINE_INSN(vmadc_vim)
+DEFINE_INSN(vmadc_vvm)
+DEFINE_INSN(vmadc_vxm)
+DEFINE_INSN(vmadd_vv)
+DEFINE_INSN(vmadd_vx)
+DEFINE_INSN(vmand_mm)
+DEFINE_INSN(vmandnot_mm)
+DEFINE_INSN(vmax_vv)
+DEFINE_INSN(vmax_vx)
+DEFINE_INSN(vmaxu_vv)
+DEFINE_INSN(vmaxu_vx)
+DEFINE_INSN(vmerge_vim)
+DEFINE_INSN(vmerge_vvm)
+DEFINE_INSN(vmerge_vxm)
+DEFINE_INSN(vmfirst_m)
+DEFINE_INSN(vmin_vv)
+DEFINE_INSN(vmin_vx)
+DEFINE_INSN(vminu_vv)
+DEFINE_INSN(vminu_vx)
+DEFINE_INSN(vmnand_mm)
+DEFINE_INSN(vmnor_mm)
+DEFINE_INSN(vmor_mm)
+DEFINE_INSN(vmornot_mm)
+DEFINE_INSN(vmpopc_m)
+DEFINE_INSN(vmsbc_vvm)
+DEFINE_INSN(vmsbc_vxm)
+DEFINE_INSN(vmsbf_m)
+DEFINE_INSN(vmseq_vi)
+DEFINE_INSN(vmseq_vv)
+DEFINE_INSN(vmseq_vx)
+DEFINE_INSN(vmsgt_vi)
+DEFINE_INSN(vmsgt_vx)
+DEFINE_INSN(vmsgtu_vi)
+DEFINE_INSN(vmsgtu_vx)
+DEFINE_INSN(vmsif_m)
+DEFINE_INSN(vmsle_vi)
+DEFINE_INSN(vmsle_vv)
+DEFINE_INSN(vmsle_vx)
+DEFINE_INSN(vmsleu_vi)
+DEFINE_INSN(vmsleu_vv)
+DEFINE_INSN(vmsleu_vx)
+DEFINE_INSN(vmslt_vv)
+DEFINE_INSN(vmslt_vx)
+DEFINE_INSN(vmsltu_vv)
+DEFINE_INSN(vmsltu_vx)
+DEFINE_INSN(vmsne_vi)
+DEFINE_INSN(vmsne_vv)
+DEFINE_INSN(vmsne_vx)
+DEFINE_INSN(vmsof_m)
+DEFINE_INSN(vmul_vv)
+DEFINE_INSN(vmul_vx)
+DEFINE_INSN(vmulh_vv)
+DEFINE_INSN(vmulh_vx)
+DEFINE_INSN(vmulhsu_vv)
+DEFINE_INSN(vmulhsu_vx)
+DEFINE_INSN(vmulhu_vv)
+DEFINE_INSN(vmulhu_vx)
+DEFINE_INSN(vmv_s_x)
+DEFINE_INSN(vmv_v_i)
+DEFINE_INSN(vmv_v_v)
+DEFINE_INSN(vmv_v_x)
+DEFINE_INSN(vmxnor_mm)
+DEFINE_INSN(vmxor_mm)
+DEFINE_INSN(vnclip_vi)
+DEFINE_INSN(vnclip_vv)
+DEFINE_INSN(vnclip_vx)
+DEFINE_INSN(vnclipu_vi)
+DEFINE_INSN(vnclipu_vv)
+DEFINE_INSN(vnclipu_vx)
+DEFINE_INSN(vnmsac_vv)
+DEFINE_INSN(vnmsac_vx)
+DEFINE_INSN(vnmsub_vv)
+DEFINE_INSN(vnmsub_vx)
+DEFINE_INSN(vnsra_vi)
+DEFINE_INSN(vnsra_vv)
+DEFINE_INSN(vnsra_vx)
+DEFINE_INSN(vnsrl_vi)
+DEFINE_INSN(vnsrl_vv)
+DEFINE_INSN(vnsrl_vx)
+DEFINE_INSN(vor_vi)
+DEFINE_INSN(vor_vv)
+DEFINE_INSN(vor_vx)
+DEFINE_INSN(vredand_vs)
+DEFINE_INSN(vredmax_vs)
+DEFINE_INSN(vredmaxu_vs)
+DEFINE_INSN(vredmin_vs)
+DEFINE_INSN(vredminu_vs)
+DEFINE_INSN(vredor_vs)
+DEFINE_INSN(vredsum_vs)
+DEFINE_INSN(vredxor_vs)
+DEFINE_INSN(vrem_vv)
+DEFINE_INSN(vrem_vx)
+DEFINE_INSN(vremu_vv)
+DEFINE_INSN(vremu_vx)
+DEFINE_INSN(vrgather_vi)
+DEFINE_INSN(vrgather_vv)
+DEFINE_INSN(vrgather_vx)
+DEFINE_INSN(vrsub_vi)
+DEFINE_INSN(vrsub_vx)
+DEFINE_INSN(vsadd_vi)
+DEFINE_INSN(vsadd_vv)
+DEFINE_INSN(vsadd_vx)
+DEFINE_INSN(vsaddu_vi)
+DEFINE_INSN(vsaddu_vv)
+DEFINE_INSN(vsaddu_vx)
+DEFINE_INSN(vsbc_vvm)
+DEFINE_INSN(vsbc_vxm)
+DEFINE_INSN(vslide1down_vx)
+DEFINE_INSN(vslide1up_vx)
+DEFINE_INSN(vslidedown_vi)
+DEFINE_INSN(vslidedown_vx)
+DEFINE_INSN(vslideup_vi)
+DEFINE_INSN(vslideup_vx)
+DEFINE_INSN(vsll_vi)
+DEFINE_INSN(vsll_vv)
+DEFINE_INSN(vsll_vx)
+DEFINE_INSN(vsmul_vv)
+DEFINE_INSN(vsmul_vx)
+DEFINE_INSN(vsra_vi)
+DEFINE_INSN(vsra_vv)
+DEFINE_INSN(vsra_vx)
+DEFINE_INSN(vsrl_vi)
+DEFINE_INSN(vsrl_vv)
+DEFINE_INSN(vsrl_vx)
+DEFINE_INSN(vssra_vi)
+DEFINE_INSN(vssra_vv)
+DEFINE_INSN(vssra_vx)
+DEFINE_INSN(vssrl_vi)
+DEFINE_INSN(vssrl_vv)
+DEFINE_INSN(vssrl_vx)
+DEFINE_INSN(vssub_vv)
+DEFINE_INSN(vssub_vx)
+DEFINE_INSN(vssubu_vv)
+DEFINE_INSN(vssubu_vx)
+DEFINE_INSN(vsub_vv)
+DEFINE_INSN(vsub_vx)
+DEFINE_INSN(vwadd_vv)
+DEFINE_INSN(vwadd_vx)
+DEFINE_INSN(vwadd_wv)
+DEFINE_INSN(vwadd_wx)
+DEFINE_INSN(vwaddu_vv)
+DEFINE_INSN(vwaddu_vx)
+DEFINE_INSN(vwaddu_wv)
+DEFINE_INSN(vwaddu_wx)
+DEFINE_INSN(vwmacc_vv)
+DEFINE_INSN(vwmacc_vx)
+DEFINE_INSN(vwmaccsu_vv)
+DEFINE_INSN(vwmaccsu_vx)
+DEFINE_INSN(vwmaccu_vv)
+DEFINE_INSN(vwmaccu_vx)
+DEFINE_INSN(vwmaccus_vx)
+DEFINE_INSN(vwmul_vv)
+DEFINE_INSN(vwmul_vx)
+DEFINE_INSN(vwmulsu_vv)
+DEFINE_INSN(vwmulsu_vx)
+DEFINE_INSN(vwmulu_vv)
+DEFINE_INSN(vwmulu_vx)
+DEFINE_INSN(vwredsum_vs)
+DEFINE_INSN(vwredsumu_vs)
+DEFINE_INSN(vwsmacc_vv)
+DEFINE_INSN(vwsmacc_vx)
+DEFINE_INSN(vwsmaccsu_vv)
+DEFINE_INSN(vwsmaccsu_vx)
+DEFINE_INSN(vwsmaccu_vv)
+DEFINE_INSN(vwsmaccu_vx)
+DEFINE_INSN(vwsmaccus_vx)
+DEFINE_INSN(vwsub_vv)
+DEFINE_INSN(vwsub_vx)
+DEFINE_INSN(vwsub_wv)
+DEFINE_INSN(vwsub_wx)
+DEFINE_INSN(vwsubu_vv)
+DEFINE_INSN(vwsubu_vx)
+DEFINE_INSN(vwsubu_wv)
+DEFINE_INSN(vwsubu_wx)
+DEFINE_INSN(vxor_vi)
+DEFINE_INSN(vxor_vv)
+DEFINE_INSN(vxor_vx)
+DEFINE_INSN(vfadd_vf)
+DEFINE_INSN(vfadd_vv)
+DEFINE_INSN(vfclass_v)
+DEFINE_INSN(vfcvt_f_x_v)
+DEFINE_INSN(vfcvt_f_xu_v)
+DEFINE_INSN(vfcvt_x_f_v)
+DEFINE_INSN(vfcvt_xu_f_v)
+DEFINE_INSN(vfdiv_vf)
+DEFINE_INSN(vfdiv_vv)
+DEFINE_INSN(vfdot_vv)
+DEFINE_INSN(vfmacc_vf)
+DEFINE_INSN(vfmacc_vv)
+DEFINE_INSN(vfmadd_vf)
+DEFINE_INSN(vfmadd_vv)
+DEFINE_INSN(vfmax_vf)
+DEFINE_INSN(vfmax_vv)
+DEFINE_INSN(vfmerge_vfm)
+DEFINE_INSN(vfmin_vf)
+DEFINE_INSN(vfmin_vv)
+DEFINE_INSN(vfmsac_vf)
+DEFINE_INSN(vfmsac_vv)
+DEFINE_INSN(vfmsub_vf)
+DEFINE_INSN(vfmsub_vv)
+DEFINE_INSN(vfmul_vf)
+DEFINE_INSN(vfmul_vv)
+DEFINE_INSN(vfmv_f_s)
+DEFINE_INSN(vfmv_s_f)
+DEFINE_INSN(vfmv_v_f)
+DEFINE_INSN(vfncvt_f_f_v)
+DEFINE_INSN(vfncvt_f_x_v)
+DEFINE_INSN(vfncvt_f_xu_v)
+DEFINE_INSN(vfncvt_x_f_v)
+DEFINE_INSN(vfncvt_xu_f_v)
+DEFINE_INSN(vfnmacc_vf)
+DEFINE_INSN(vfnmacc_vv)
+DEFINE_INSN(vfnmadd_vf)
+DEFINE_INSN(vfnmadd_vv)
+DEFINE_INSN(vfnmsac_vf)
+DEFINE_INSN(vfnmsac_vv)
+DEFINE_INSN(vfnmsub_vf)
+DEFINE_INSN(vfnmsub_vv)
+DEFINE_INSN(vfrdiv_vf)
+DEFINE_INSN(vfredmax_vs)
+DEFINE_INSN(vfredmin_vs)
+DEFINE_INSN(vfredosum_vs)
+DEFINE_INSN(vfredsum_vs)
+DEFINE_INSN(vfrsub_vf)
+DEFINE_INSN(vfsgnj_vf)
+DEFINE_INSN(vfsgnj_vv)
+DEFINE_INSN(vfsgnjn_vf)
+DEFINE_INSN(vfsgnjn_vv)
+DEFINE_INSN(vfsgnjx_vf)
+DEFINE_INSN(vfsgnjx_vv)
+DEFINE_INSN(vfsqrt_v)
+DEFINE_INSN(vfsub_vf)
+DEFINE_INSN(vfsub_vv)
+DEFINE_INSN(vfwadd_vf)
+DEFINE_INSN(vfwadd_vv)
+DEFINE_INSN(vfwadd_wf)
+DEFINE_INSN(vfwadd_wv)
+DEFINE_INSN(vfwcvt_f_f_v)
+DEFINE_INSN(vfwcvt_f_x_v)
+DEFINE_INSN(vfwcvt_f_xu_v)
+DEFINE_INSN(vfwcvt_x_f_v)
+DEFINE_INSN(vfwcvt_xu_f_v)
+DEFINE_INSN(vfwmacc_vf)
+DEFINE_INSN(vfwmacc_vv)
+DEFINE_INSN(vfwmsac_vf)
+DEFINE_INSN(vfwmsac_vv)
+DEFINE_INSN(vfwmul_vf)
+DEFINE_INSN(vfwmul_vv)
+DEFINE_INSN(vfwnmacc_vf)
+DEFINE_INSN(vfwnmacc_vv)
+DEFINE_INSN(vfwnmsac_vf)
+DEFINE_INSN(vfwnmsac_vv)
+DEFINE_INSN(vfwredosum_vs)
+DEFINE_INSN(vfwredsum_vs)
+DEFINE_INSN(vfwsub_vf)
+DEFINE_INSN(vfwsub_vv)
+DEFINE_INSN(vfwsub_wf)
+DEFINE_INSN(vfwsub_wv)
+DEFINE_INSN(vmfeq_vf)
+DEFINE_INSN(vmfeq_vv)
+DEFINE_INSN(vmfge_vf)
+DEFINE_INSN(vmfgt_vf)
+DEFINE_INSN(vmfle_vf)
+DEFINE_INSN(vmfle_vv)
+DEFINE_INSN(vmflt_vf)
+DEFINE_INSN(vmflt_vv)
+DEFINE_INSN(vmfne_vf)
+DEFINE_INSN(vmfne_vv)
+DEFINE_INSN(vmford_vf)
+DEFINE_INSN(vmford_vv)
+DEFINE_INSN(vlb_v)
+DEFINE_INSN(vlh_v)
+DEFINE_INSN(vlw_v)
+DEFINE_INSN(vle_v)
+DEFINE_INSN(vlbu_v)
+DEFINE_INSN(vlhu_v)
+DEFINE_INSN(vlwu_v)
+DEFINE_INSN(vlsb_v)
+DEFINE_INSN(vlsh_v)
+DEFINE_INSN(vlsw_v)
+DEFINE_INSN(vlse_v)
+DEFINE_INSN(vlxb_v)
+DEFINE_INSN(vlxh_v)
+DEFINE_INSN(vlxw_v)
+DEFINE_INSN(vlxe_v)
+DEFINE_INSN(vlsbu_v)
+DEFINE_INSN(vlshu_v)
+DEFINE_INSN(vlswu_v)
+DEFINE_INSN(vlxbu_v)
+DEFINE_INSN(vlxhu_v)
+DEFINE_INSN(vlxwu_v)
+DEFINE_INSN(vlbff_v)
+DEFINE_INSN(vlhff_v)
+DEFINE_INSN(vlwff_v)
+DEFINE_INSN(vleff_v)
+DEFINE_INSN(vlbuff_v)
+DEFINE_INSN(vlhuff_v)
+DEFINE_INSN(vlwuff_v)
+DEFINE_INSN(vsb_v)
+DEFINE_INSN(vsh_v)
+DEFINE_INSN(vsw_v)
+DEFINE_INSN(vse_v)
+DEFINE_INSN(vssb_v)
+DEFINE_INSN(vssh_v)
+DEFINE_INSN(vssw_v)
+DEFINE_INSN(vsse_v)
+DEFINE_INSN(vsxb_v)
+DEFINE_INSN(vsxh_v)
+DEFINE_INSN(vsxw_v)
+DEFINE_INSN(vsxe_v)
+DEFINE_INSN(vsuxb_v)
+DEFINE_INSN(vsuxh_v)
+DEFINE_INSN(vsuxw_v)
+DEFINE_INSN(vsuxe_v)
+DEFINE_INSN(vsetvli)
+DEFINE_INSN(vsetvl)
+DEFINE_INSN(vamoaddd_v)
+DEFINE_INSN(vamoandd_v)
+DEFINE_INSN(vamomaxd_v)
+DEFINE_INSN(vamomaxuw_v)
+DEFINE_INSN(vamomind_v)
+DEFINE_INSN(vamominuw_v)
+DEFINE_INSN(vamoord_v)
+DEFINE_INSN(vamoswapd_v)
+DEFINE_INSN(vamoxord_v)
+DEFINE_INSN(vamoaddw_v)
+DEFINE_INSN(vamoandw_v)
+DEFINE_INSN(vamomaxud_v)
+DEFINE_INSN(vamomaxw_v)
+DEFINE_INSN(vamominud_v)
+DEFINE_INSN(vamominw_v)
+DEFINE_INSN(vamoorw_v)
+DEFINE_INSN(vamoswapw_v)
+DEFINE_INSN(vamoxorw_v)
diff --git a/arch/riscv/kernel/soft_vector/insn_template.c b/arch/riscv/kernel/soft_vector/insn_template.c
new file mode 100644
index 000000000000..b79f1ddaf6f6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insn_template.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_NAME(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(OPCODE);
+  #include "../insns_func/NAME.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_NAME(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(OPCODE);
+  #include "../insns_func/NAME.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insn_template.h b/arch/riscv/kernel/soft_vector/insn_template.h
new file mode 100644
index 000000000000..a6830627d48c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insn_template.h
@@ -0,0 +1,34 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "riscv_decode.h"
+#include "softfloat/softfloat.h"
+#include "softfloat/internals.h"
+#include "softfloat/specialize.h"
+#include <linux/printk.h>
diff --git a/arch/riscv/kernel/soft_vector/insns/Makefile b/arch/riscv/kernel/soft_vector/insns/Makefile
new file mode 100644
index 000000000000..d6cecbe9b6f4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/Makefile
@@ -0,0 +1,365 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the RISC-V Linux kernel
+#
+
+obj-$(CONFIG_VECTOR_EMU)    += vaadd_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vaadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vaadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vadc_vim.o
+obj-$(CONFIG_VECTOR_EMU)    += vadc_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vadc_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vadd_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vand_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vand_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vand_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vasub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vasub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vcompress_vm.o
+obj-$(CONFIG_VECTOR_EMU)    += vdiv_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vdiv_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vdivu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vdivu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vdot_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vdotu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vext_x_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vid_v.o
+obj-$(CONFIG_VECTOR_EMU)    += viota_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmacc_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadc_vim.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadc_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadc_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmand_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmandnot_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmax_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmax_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmaxu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmaxu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmerge_vim.o
+obj-$(CONFIG_VECTOR_EMU)    += vmerge_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmerge_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfirst_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmin_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmin_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vminu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vminu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmnand_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmnor_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmor_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmornot_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmpopc_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsbc_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsbc_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsbf_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmseq_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmseq_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmseq_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsgt_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsgt_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsgtu_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsgtu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsif_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsle_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsle_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsle_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsleu_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsleu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsleu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmslt_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmslt_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsltu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsltu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsne_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsne_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsne_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmsof_m.o
+obj-$(CONFIG_VECTOR_EMU)    += vmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmul_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulh_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulh_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulhsu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulhsu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulhu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmulhu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vmv_s_x.o
+obj-$(CONFIG_VECTOR_EMU)    += vmv_v_i.o
+obj-$(CONFIG_VECTOR_EMU)    += vmv_v_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vmv_v_x.o
+obj-$(CONFIG_VECTOR_EMU)    += vmxnor_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vmxor_mm.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclip_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclip_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclip_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclipu_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclipu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnclipu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnmsac_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnmsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnmsub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsra_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsra_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsra_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsrl_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsrl_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vnsrl_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vor_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vor_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vor_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vredand_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredmax_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredmaxu_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredmin_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredminu_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredor_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredsum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vredxor_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vrem_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vrem_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vremu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vremu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vrgather_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vrgather_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vrgather_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vrsub_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vrsub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsadd_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsaddu_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsaddu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsaddu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsbc_vvm.o
+obj-$(CONFIG_VECTOR_EMU)    += vsbc_vxm.o
+obj-$(CONFIG_VECTOR_EMU)    += vslide1down_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vslide1up_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vslidedown_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vslidedown_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vslideup_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vslideup_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsll_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsll_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsll_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsmul_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsra_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsra_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsra_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsrl_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vsrl_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsrl_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vssra_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vssra_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vssra_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vssrl_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vssrl_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vssrl_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vssub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vssub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vssubu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vssubu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vsub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwadd_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwadd_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwadd_wx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwaddu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwaddu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwaddu_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwaddu_wx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmacc_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccsu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccsu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmaccus_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmul_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmulsu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmulsu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmulu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwmulu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwredsum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vwredsumu_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmacc_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccsu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccsu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsmaccus_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsub_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsub_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsub_wx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsubu_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsubu_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsubu_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vwsubu_wx.o
+obj-$(CONFIG_VECTOR_EMU)    += vxor_vi.o
+obj-$(CONFIG_VECTOR_EMU)    += vxor_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vxor_vx.o
+obj-$(CONFIG_VECTOR_EMU)    += vfadd_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfclass_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfcvt_f_x_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfcvt_f_xu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfcvt_x_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfcvt_xu_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfdiv_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfdiv_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfdot_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmacc_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmadd_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmax_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmax_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmerge_vfm.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmin_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmin_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmsac_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmul_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmv_f_s.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmv_s_f.o
+obj-$(CONFIG_VECTOR_EMU)    += vfmv_v_f.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_f_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_f_x_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_f_xu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_x_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfncvt_xu_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmacc_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmadd_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmsac_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfnmsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfrdiv_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfredmax_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfredmin_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfredosum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfredsum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfrsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnj_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnj_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnjn_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnjn_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnjx_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsgnjx_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsqrt_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwadd_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwadd_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwadd_wf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwadd_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_f_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_f_x_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_f_xu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_x_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwcvt_xu_f_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmacc_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmsac_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmul_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwmul_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwnmacc_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwnmacc_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwnmsac_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwnmsac_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwredosum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwredsum_vs.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwsub_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwsub_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwsub_wf.o
+obj-$(CONFIG_VECTOR_EMU)    += vfwsub_wv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfeq_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfeq_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfge_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfgt_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfle_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfle_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmflt_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmflt_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfne_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmfne_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vmford_vf.o
+obj-$(CONFIG_VECTOR_EMU)    += vmford_vv.o
+obj-$(CONFIG_VECTOR_EMU)    += vlb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vle_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlbu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlhu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlwu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlsb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlsh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlsw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlse_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxe_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlsbu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlshu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlswu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxbu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxhu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlxwu_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlbff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlhff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlwff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vleff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlbuff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlhuff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vlwuff_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vse_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vssb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vssh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vssw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsse_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsxb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsxh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsxw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsxe_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsuxb_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsuxh_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsuxw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsuxe_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vsetvli.o
+obj-$(CONFIG_VECTOR_EMU)    += vsetvl.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoaddd_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoandd_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomaxd_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomaxuw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomind_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamominuw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoord_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoswapd_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoxord_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoaddw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoandw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomaxud_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamomaxw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamominud_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamominw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoorw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoswapw_v.o
+obj-$(CONFIG_VECTOR_EMU)    += vamoxorw_v.o
diff --git a/arch/riscv/kernel/soft_vector/insns/vaadd_vi.c b/arch/riscv/kernel/soft_vector/insns/vaadd_vi.c
new file mode 100644
index 000000000000..c904163d3b0d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vaadd_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vaadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAADD_VI);
+  #include "../insns_func/vaadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vaadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAADD_VI);
+  #include "../insns_func/vaadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vaadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vaadd_vv.c
new file mode 100644
index 000000000000..3a9cb2a5619a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vaadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vaadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAADD_VV);
+  #include "../insns_func/vaadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vaadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAADD_VV);
+  #include "../insns_func/vaadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vaadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vaadd_vx.c
new file mode 100644
index 000000000000..ebed76c6ba98
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vaadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vaadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAADD_VX);
+  #include "../insns_func/vaadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vaadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAADD_VX);
+  #include "../insns_func/vaadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadc_vim.c b/arch/riscv/kernel/soft_vector/insns/vadc_vim.c
new file mode 100644
index 000000000000..d96bcba231b7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadc_vim.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadc_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADC_VIM);
+  #include "../insns_func/vadc_vim.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadc_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADC_VIM);
+  #include "../insns_func/vadc_vim.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadc_vvm.c b/arch/riscv/kernel/soft_vector/insns/vadc_vvm.c
new file mode 100644
index 000000000000..bcbbf90b9c9e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadc_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADC_VVM);
+  #include "../insns_func/vadc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADC_VVM);
+  #include "../insns_func/vadc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadc_vxm.c b/arch/riscv/kernel/soft_vector/insns/vadc_vxm.c
new file mode 100644
index 000000000000..eaf3fd62b080
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadc_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADC_VXM);
+  #include "../insns_func/vadc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADC_VXM);
+  #include "../insns_func/vadc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadd_vi.c b/arch/riscv/kernel/soft_vector/insns/vadd_vi.c
new file mode 100644
index 000000000000..0f047471f20f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadd_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADD_VI);
+  #include "../insns_func/vadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADD_VI);
+  #include "../insns_func/vadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vadd_vv.c
new file mode 100644
index 000000000000..6a66b619a732
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADD_VV);
+  #include "../insns_func/vadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADD_VV);
+  #include "../insns_func/vadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vadd_vx.c
new file mode 100644
index 000000000000..b9d82ec9b62e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VADD_VX);
+  #include "../insns_func/vadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VADD_VX);
+  #include "../insns_func/vadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoaddd_v.c b/arch/riscv/kernel/soft_vector/insns/vamoaddd_v.c
new file mode 100644
index 000000000000..56546cfbf8b8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoaddd_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoaddd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOADDD_V);
+  #include "../insns_func/vamoaddd_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoaddd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOADDD_V);
+  #include "../insns_func/vamoaddd_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoaddw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoaddw_v.c
new file mode 100644
index 000000000000..e744705cecf9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoaddw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoaddw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOADDW_V);
+  #include "../insns_func/vamoaddw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoaddw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOADDW_V);
+  #include "../insns_func/vamoaddw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoandd_v.c b/arch/riscv/kernel/soft_vector/insns/vamoandd_v.c
new file mode 100644
index 000000000000..c48c4b9516fb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoandd_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoandd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOANDD_V);
+  #include "../insns_func/vamoandd_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoandd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOANDD_V);
+  #include "../insns_func/vamoandd_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoandw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoandw_v.c
new file mode 100644
index 000000000000..892b61c56b7c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoandw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoandw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOANDW_V);
+  #include "../insns_func/vamoandw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoandw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOANDW_V);
+  #include "../insns_func/vamoandw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomaxd_v.c b/arch/riscv/kernel/soft_vector/insns/vamomaxd_v.c
new file mode 100644
index 000000000000..bb862afd200c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomaxd_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomaxd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMAXD_V);
+  #include "../insns_func/vamomaxd_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomaxd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMAXD_V);
+  #include "../insns_func/vamomaxd_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomaxud_v.c b/arch/riscv/kernel/soft_vector/insns/vamomaxud_v.c
new file mode 100644
index 000000000000..31032e9402d4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomaxud_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomaxud_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMAXUD_V);
+  #include "../insns_func/vamomaxud_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomaxud_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMAXUD_V);
+  #include "../insns_func/vamomaxud_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomaxuw_v.c b/arch/riscv/kernel/soft_vector/insns/vamomaxuw_v.c
new file mode 100644
index 000000000000..919351ab2211
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomaxuw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomaxuw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMAXUW_V);
+  #include "../insns_func/vamomaxuw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomaxuw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMAXUW_V);
+  #include "../insns_func/vamomaxuw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomaxw_v.c b/arch/riscv/kernel/soft_vector/insns/vamomaxw_v.c
new file mode 100644
index 000000000000..ff434a403045
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomaxw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomaxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMAXW_V);
+  #include "../insns_func/vamomaxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomaxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMAXW_V);
+  #include "../insns_func/vamomaxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamomind_v.c b/arch/riscv/kernel/soft_vector/insns/vamomind_v.c
new file mode 100644
index 000000000000..6b95c1ba231e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamomind_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamomind_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMIND_V);
+  #include "../insns_func/vamomind_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamomind_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMIND_V);
+  #include "../insns_func/vamomind_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamominud_v.c b/arch/riscv/kernel/soft_vector/insns/vamominud_v.c
new file mode 100644
index 000000000000..1f3eb428c3d4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamominud_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamominud_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMINUD_V);
+  #include "../insns_func/vamominud_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamominud_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMINUD_V);
+  #include "../insns_func/vamominud_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamominuw_v.c b/arch/riscv/kernel/soft_vector/insns/vamominuw_v.c
new file mode 100644
index 000000000000..cb3ae8e2a6fd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamominuw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamominuw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMINUW_V);
+  #include "../insns_func/vamominuw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamominuw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMINUW_V);
+  #include "../insns_func/vamominuw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamominw_v.c b/arch/riscv/kernel/soft_vector/insns/vamominw_v.c
new file mode 100644
index 000000000000..cc303d423b6a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamominw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamominw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOMINW_V);
+  #include "../insns_func/vamominw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamominw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOMINW_V);
+  #include "../insns_func/vamominw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoord_v.c b/arch/riscv/kernel/soft_vector/insns/vamoord_v.c
new file mode 100644
index 000000000000..35f840094e7a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoord_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoord_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOORD_V);
+  #include "../insns_func/vamoord_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoord_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOORD_V);
+  #include "../insns_func/vamoord_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoorw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoorw_v.c
new file mode 100644
index 000000000000..c3c87e18f68e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoorw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoorw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOORW_V);
+  #include "../insns_func/vamoorw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoorw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOORW_V);
+  #include "../insns_func/vamoorw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoswapd_v.c b/arch/riscv/kernel/soft_vector/insns/vamoswapd_v.c
new file mode 100644
index 000000000000..237fbfdb92c2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoswapd_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoswapd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOSWAPD_V);
+  #include "../insns_func/vamoswapd_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoswapd_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOSWAPD_V);
+  #include "../insns_func/vamoswapd_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoswapw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoswapw_v.c
new file mode 100644
index 000000000000..667514a408ee
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoswapw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoswapw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOSWAPW_V);
+  #include "../insns_func/vamoswapw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoswapw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOSWAPW_V);
+  #include "../insns_func/vamoswapw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoxord_v.c b/arch/riscv/kernel/soft_vector/insns/vamoxord_v.c
new file mode 100644
index 000000000000..3d3b137e0f1c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoxord_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoxord_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOXORD_V);
+  #include "../insns_func/vamoxord_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoxord_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOXORD_V);
+  #include "../insns_func/vamoxord_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vamoxorw_v.c b/arch/riscv/kernel/soft_vector/insns/vamoxorw_v.c
new file mode 100644
index 000000000000..65a0fc060683
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vamoxorw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vamoxorw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAMOXORW_V);
+  #include "../insns_func/vamoxorw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vamoxorw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAMOXORW_V);
+  #include "../insns_func/vamoxorw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vand_vi.c b/arch/riscv/kernel/soft_vector/insns/vand_vi.c
new file mode 100644
index 000000000000..b49d616785fa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vand_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vand_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAND_VI);
+  #include "../insns_func/vand_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vand_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAND_VI);
+  #include "../insns_func/vand_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vand_vv.c b/arch/riscv/kernel/soft_vector/insns/vand_vv.c
new file mode 100644
index 000000000000..5ddd363e4892
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vand_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vand_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAND_VV);
+  #include "../insns_func/vand_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vand_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAND_VV);
+  #include "../insns_func/vand_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vand_vx.c b/arch/riscv/kernel/soft_vector/insns/vand_vx.c
new file mode 100644
index 000000000000..6faffd079fb2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vand_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vand_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VAND_VX);
+  #include "../insns_func/vand_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vand_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VAND_VX);
+  #include "../insns_func/vand_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vasub_vv.c b/arch/riscv/kernel/soft_vector/insns/vasub_vv.c
new file mode 100644
index 000000000000..658969351231
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vasub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vasub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VASUB_VV);
+  #include "../insns_func/vasub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vasub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VASUB_VV);
+  #include "../insns_func/vasub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vasub_vx.c b/arch/riscv/kernel/soft_vector/insns/vasub_vx.c
new file mode 100644
index 000000000000..7ba745e4fc6a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vasub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vasub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VASUB_VX);
+  #include "../insns_func/vasub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vasub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VASUB_VX);
+  #include "../insns_func/vasub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vcompress_vm.c b/arch/riscv/kernel/soft_vector/insns/vcompress_vm.c
new file mode 100644
index 000000000000..b4364063f932
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vcompress_vm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vcompress_vm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VCOMPRESS_VM);
+  #include "../insns_func/vcompress_vm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vcompress_vm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VCOMPRESS_VM);
+  #include "../insns_func/vcompress_vm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdiv_vv.c b/arch/riscv/kernel/soft_vector/insns/vdiv_vv.c
new file mode 100644
index 000000000000..53fb597b7b8c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdiv_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdiv_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDIV_VV);
+  #include "../insns_func/vdiv_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdiv_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDIV_VV);
+  #include "../insns_func/vdiv_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdiv_vx.c b/arch/riscv/kernel/soft_vector/insns/vdiv_vx.c
new file mode 100644
index 000000000000..6483d857db02
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdiv_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdiv_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDIV_VX);
+  #include "../insns_func/vdiv_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdiv_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDIV_VX);
+  #include "../insns_func/vdiv_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdivu_vv.c b/arch/riscv/kernel/soft_vector/insns/vdivu_vv.c
new file mode 100644
index 000000000000..ed42933a5d3c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdivu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdivu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDIVU_VV);
+  #include "../insns_func/vdivu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdivu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDIVU_VV);
+  #include "../insns_func/vdivu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdivu_vx.c b/arch/riscv/kernel/soft_vector/insns/vdivu_vx.c
new file mode 100644
index 000000000000..d502b5e51f10
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdivu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdivu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDIVU_VX);
+  #include "../insns_func/vdivu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdivu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDIVU_VX);
+  #include "../insns_func/vdivu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdot_vv.c b/arch/riscv/kernel/soft_vector/insns/vdot_vv.c
new file mode 100644
index 000000000000..cb67d3f3f72f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdot_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdot_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDOT_VV);
+  #include "../insns_func/vdot_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdot_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDOT_VV);
+  #include "../insns_func/vdot_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vdotu_vv.c b/arch/riscv/kernel/soft_vector/insns/vdotu_vv.c
new file mode 100644
index 000000000000..87eba04f0634
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vdotu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vdotu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VDOTU_VV);
+  #include "../insns_func/vdotu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vdotu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VDOTU_VV);
+  #include "../insns_func/vdotu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vext_x_v.c b/arch/riscv/kernel/soft_vector/insns/vext_x_v.c
new file mode 100644
index 000000000000..98b37e4b7bd8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vext_x_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vext_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VEXT_X_V);
+  #include "../insns_func/vext_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vext_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VEXT_X_V);
+  #include "../insns_func/vext_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfadd_vf.c b/arch/riscv/kernel/soft_vector/insns/vfadd_vf.c
new file mode 100644
index 000000000000..ca1ee97fe673
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfadd_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFADD_VF);
+  #include "../insns_func/vfadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFADD_VF);
+  #include "../insns_func/vfadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vfadd_vv.c
new file mode 100644
index 000000000000..31ccee558fe8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFADD_VV);
+  #include "../insns_func/vfadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFADD_VV);
+  #include "../insns_func/vfadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfclass_v.c b/arch/riscv/kernel/soft_vector/insns/vfclass_v.c
new file mode 100644
index 000000000000..1b6dff824080
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfclass_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfclass_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCLASS_V);
+  #include "../insns_func/vfclass_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfclass_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCLASS_V);
+  #include "../insns_func/vfclass_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfcvt_f_x_v.c b/arch/riscv/kernel/soft_vector/insns/vfcvt_f_x_v.c
new file mode 100644
index 000000000000..7893b69857e7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfcvt_f_x_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfcvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCVT_F_X_V);
+  #include "../insns_func/vfcvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfcvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCVT_F_X_V);
+  #include "../insns_func/vfcvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfcvt_f_xu_v.c b/arch/riscv/kernel/soft_vector/insns/vfcvt_f_xu_v.c
new file mode 100644
index 000000000000..9bc200d13828
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfcvt_f_xu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfcvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCVT_F_XU_V);
+  #include "../insns_func/vfcvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfcvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCVT_F_XU_V);
+  #include "../insns_func/vfcvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfcvt_x_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfcvt_x_f_v.c
new file mode 100644
index 000000000000..7e63c105a344
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfcvt_x_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfcvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCVT_X_F_V);
+  #include "../insns_func/vfcvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfcvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCVT_X_F_V);
+  #include "../insns_func/vfcvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfcvt_xu_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfcvt_xu_f_v.c
new file mode 100644
index 000000000000..17a129e24a81
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfcvt_xu_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfcvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFCVT_XU_F_V);
+  #include "../insns_func/vfcvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfcvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFCVT_XU_F_V);
+  #include "../insns_func/vfcvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfdiv_vf.c b/arch/riscv/kernel/soft_vector/insns/vfdiv_vf.c
new file mode 100644
index 000000000000..30c36a3f1373
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfdiv_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfdiv_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFDIV_VF);
+  #include "../insns_func/vfdiv_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfdiv_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFDIV_VF);
+  #include "../insns_func/vfdiv_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfdiv_vv.c b/arch/riscv/kernel/soft_vector/insns/vfdiv_vv.c
new file mode 100644
index 000000000000..0fc6172dbd7a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfdiv_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfdiv_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFDIV_VV);
+  #include "../insns_func/vfdiv_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfdiv_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFDIV_VV);
+  #include "../insns_func/vfdiv_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfdot_vv.c b/arch/riscv/kernel/soft_vector/insns/vfdot_vv.c
new file mode 100644
index 000000000000..e2f474e35c94
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfdot_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfdot_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFDOT_VV);
+  #include "../insns_func/vfdot_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfdot_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFDOT_VV);
+  #include "../insns_func/vfdot_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmacc_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmacc_vf.c
new file mode 100644
index 000000000000..dccc0f4019a1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmacc_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMACC_VF);
+  #include "../insns_func/vfmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMACC_VF);
+  #include "../insns_func/vfmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmacc_vv.c
new file mode 100644
index 000000000000..8d168ecd7b81
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMACC_VV);
+  #include "../insns_func/vfmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMACC_VV);
+  #include "../insns_func/vfmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmadd_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmadd_vf.c
new file mode 100644
index 000000000000..92f2688d94c2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmadd_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMADD_VF);
+  #include "../insns_func/vfmadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMADD_VF);
+  #include "../insns_func/vfmadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmadd_vv.c
new file mode 100644
index 000000000000..bc3b9fa2820e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMADD_VV);
+  #include "../insns_func/vfmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMADD_VV);
+  #include "../insns_func/vfmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmax_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmax_vf.c
new file mode 100644
index 000000000000..d12f99cd751e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmax_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmax_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMAX_VF);
+  #include "../insns_func/vfmax_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmax_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMAX_VF);
+  #include "../insns_func/vfmax_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmax_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmax_vv.c
new file mode 100644
index 000000000000..15e4c976d1a9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmax_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmax_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMAX_VV);
+  #include "../insns_func/vfmax_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmax_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMAX_VV);
+  #include "../insns_func/vfmax_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmerge_vfm.c b/arch/riscv/kernel/soft_vector/insns/vfmerge_vfm.c
new file mode 100644
index 000000000000..f2399c61d272
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmerge_vfm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmerge_vfm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMERGE_VFM);
+  #include "../insns_func/vfmerge_vfm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmerge_vfm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMERGE_VFM);
+  #include "../insns_func/vfmerge_vfm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmin_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmin_vf.c
new file mode 100644
index 000000000000..ca2766f986e8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmin_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmin_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMIN_VF);
+  #include "../insns_func/vfmin_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmin_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMIN_VF);
+  #include "../insns_func/vfmin_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmin_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmin_vv.c
new file mode 100644
index 000000000000..e2d26aa74d77
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmin_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmin_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMIN_VV);
+  #include "../insns_func/vfmin_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmin_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMIN_VV);
+  #include "../insns_func/vfmin_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmsac_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmsac_vf.c
new file mode 100644
index 000000000000..822ac1403be1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmsac_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMSAC_VF);
+  #include "../insns_func/vfmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMSAC_VF);
+  #include "../insns_func/vfmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmsac_vv.c
new file mode 100644
index 000000000000..c8b90d0cbac4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMSAC_VV);
+  #include "../insns_func/vfmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMSAC_VV);
+  #include "../insns_func/vfmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmsub_vf.c
new file mode 100644
index 000000000000..5e07cef8943c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMSUB_VF);
+  #include "../insns_func/vfmsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMSUB_VF);
+  #include "../insns_func/vfmsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmsub_vv.c
new file mode 100644
index 000000000000..de079023ea54
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMSUB_VV);
+  #include "../insns_func/vfmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMSUB_VV);
+  #include "../insns_func/vfmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmul_vf.c b/arch/riscv/kernel/soft_vector/insns/vfmul_vf.c
new file mode 100644
index 000000000000..a4cd5ef0300c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmul_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmul_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMUL_VF);
+  #include "../insns_func/vfmul_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmul_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMUL_VF);
+  #include "../insns_func/vfmul_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vfmul_vv.c
new file mode 100644
index 000000000000..d02dc07e6ae0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMUL_VV);
+  #include "../insns_func/vfmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMUL_VV);
+  #include "../insns_func/vfmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmv_f_s.c b/arch/riscv/kernel/soft_vector/insns/vfmv_f_s.c
new file mode 100644
index 000000000000..35951589517f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmv_f_s.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmv_f_s(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMV_F_S);
+  #include "../insns_func/vfmv_f_s.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmv_f_s(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMV_F_S);
+  #include "../insns_func/vfmv_f_s.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmv_s_f.c b/arch/riscv/kernel/soft_vector/insns/vfmv_s_f.c
new file mode 100644
index 000000000000..c0b23e319e5b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmv_s_f.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmv_s_f(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMV_S_F);
+  #include "../insns_func/vfmv_s_f.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmv_s_f(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMV_S_F);
+  #include "../insns_func/vfmv_s_f.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfmv_v_f.c b/arch/riscv/kernel/soft_vector/insns/vfmv_v_f.c
new file mode 100644
index 000000000000..7cd7537fefc3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfmv_v_f.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfmv_v_f(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFMV_V_F);
+  #include "../insns_func/vfmv_v_f.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfmv_v_f(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFMV_V_F);
+  #include "../insns_func/vfmv_v_f.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_f_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_f_v.c
new file mode 100644
index 000000000000..3e49f786240b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_f_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_F_V);
+  #include "../insns_func/vfncvt_f_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_f_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_F_V);
+  #include "../insns_func/vfncvt_f_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_f_x_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_x_v.c
new file mode 100644
index 000000000000..0b421e8bb252
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_x_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_X_V);
+  #include "../insns_func/vfncvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_X_V);
+  #include "../insns_func/vfncvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_f_xu_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_xu_v.c
new file mode 100644
index 000000000000..6d4f412a621d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_f_xu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_XU_V);
+  #include "../insns_func/vfncvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_F_XU_V);
+  #include "../insns_func/vfncvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_x_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_x_f_v.c
new file mode 100644
index 000000000000..5d1f6ee2c842
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_x_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_X_F_V);
+  #include "../insns_func/vfncvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_X_F_V);
+  #include "../insns_func/vfncvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfncvt_xu_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfncvt_xu_f_v.c
new file mode 100644
index 000000000000..897518b082ba
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfncvt_xu_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfncvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNCVT_XU_F_V);
+  #include "../insns_func/vfncvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfncvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNCVT_XU_F_V);
+  #include "../insns_func/vfncvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmacc_vf.c b/arch/riscv/kernel/soft_vector/insns/vfnmacc_vf.c
new file mode 100644
index 000000000000..d678cd2bf8bb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmacc_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMACC_VF);
+  #include "../insns_func/vfnmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMACC_VF);
+  #include "../insns_func/vfnmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vfnmacc_vv.c
new file mode 100644
index 000000000000..550a9e0158c6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMACC_VV);
+  #include "../insns_func/vfnmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMACC_VV);
+  #include "../insns_func/vfnmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmadd_vf.c b/arch/riscv/kernel/soft_vector/insns/vfnmadd_vf.c
new file mode 100644
index 000000000000..b763088597b0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmadd_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMADD_VF);
+  #include "../insns_func/vfnmadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMADD_VF);
+  #include "../insns_func/vfnmadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vfnmadd_vv.c
new file mode 100644
index 000000000000..0bdd694ea417
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMADD_VV);
+  #include "../insns_func/vfnmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMADD_VV);
+  #include "../insns_func/vfnmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmsac_vf.c b/arch/riscv/kernel/soft_vector/insns/vfnmsac_vf.c
new file mode 100644
index 000000000000..727ffe4f4e72
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmsac_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMSAC_VF);
+  #include "../insns_func/vfnmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMSAC_VF);
+  #include "../insns_func/vfnmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vfnmsac_vv.c
new file mode 100644
index 000000000000..b67f67e577a4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMSAC_VV);
+  #include "../insns_func/vfnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMSAC_VV);
+  #include "../insns_func/vfnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfnmsub_vf.c
new file mode 100644
index 000000000000..54b27a819f4c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMSUB_VF);
+  #include "../insns_func/vfnmsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMSUB_VF);
+  #include "../insns_func/vfnmsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfnmsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vfnmsub_vv.c
new file mode 100644
index 000000000000..c20ceddefada
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfnmsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfnmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFNMSUB_VV);
+  #include "../insns_func/vfnmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfnmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFNMSUB_VV);
+  #include "../insns_func/vfnmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfrdiv_vf.c b/arch/riscv/kernel/soft_vector/insns/vfrdiv_vf.c
new file mode 100644
index 000000000000..ec1b12f5d0e8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfrdiv_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfrdiv_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFRDIV_VF);
+  #include "../insns_func/vfrdiv_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfrdiv_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFRDIV_VF);
+  #include "../insns_func/vfrdiv_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfredmax_vs.c b/arch/riscv/kernel/soft_vector/insns/vfredmax_vs.c
new file mode 100644
index 000000000000..2a75b6c41a44
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfredmax_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfredmax_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFREDMAX_VS);
+  #include "../insns_func/vfredmax_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfredmax_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFREDMAX_VS);
+  #include "../insns_func/vfredmax_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfredmin_vs.c b/arch/riscv/kernel/soft_vector/insns/vfredmin_vs.c
new file mode 100644
index 000000000000..91d1cbe5d263
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfredmin_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfredmin_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFREDMIN_VS);
+  #include "../insns_func/vfredmin_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfredmin_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFREDMIN_VS);
+  #include "../insns_func/vfredmin_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfredosum_vs.c b/arch/riscv/kernel/soft_vector/insns/vfredosum_vs.c
new file mode 100644
index 000000000000..013f54e2c6e1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfredosum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfredosum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFREDOSUM_VS);
+  #include "../insns_func/vfredosum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfredosum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFREDOSUM_VS);
+  #include "../insns_func/vfredosum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfredsum_vs.c b/arch/riscv/kernel/soft_vector/insns/vfredsum_vs.c
new file mode 100644
index 000000000000..45fa3217d75d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfredsum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFREDSUM_VS);
+  #include "../insns_func/vfredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFREDSUM_VS);
+  #include "../insns_func/vfredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfrsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfrsub_vf.c
new file mode 100644
index 000000000000..396549126f4a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfrsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfrsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFRSUB_VF);
+  #include "../insns_func/vfrsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfrsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFRSUB_VF);
+  #include "../insns_func/vfrsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnj_vf.c b/arch/riscv/kernel/soft_vector/insns/vfsgnj_vf.c
new file mode 100644
index 000000000000..2c0ea195009f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnj_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnj_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJ_VF);
+  #include "../insns_func/vfsgnj_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnj_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJ_VF);
+  #include "../insns_func/vfsgnj_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnj_vv.c b/arch/riscv/kernel/soft_vector/insns/vfsgnj_vv.c
new file mode 100644
index 000000000000..f6347e8b5644
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnj_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnj_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJ_VV);
+  #include "../insns_func/vfsgnj_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnj_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJ_VV);
+  #include "../insns_func/vfsgnj_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vf.c b/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vf.c
new file mode 100644
index 000000000000..1f816fdbbec9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnjn_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJN_VF);
+  #include "../insns_func/vfsgnjn_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnjn_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJN_VF);
+  #include "../insns_func/vfsgnjn_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vv.c b/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vv.c
new file mode 100644
index 000000000000..9de19b2fa619
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnjn_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnjn_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJN_VV);
+  #include "../insns_func/vfsgnjn_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnjn_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJN_VV);
+  #include "../insns_func/vfsgnjn_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vf.c b/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vf.c
new file mode 100644
index 000000000000..7abac2f38570
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnjx_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJX_VF);
+  #include "../insns_func/vfsgnjx_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnjx_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJX_VF);
+  #include "../insns_func/vfsgnjx_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vv.c b/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vv.c
new file mode 100644
index 000000000000..f305989e29cd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsgnjx_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsgnjx_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSGNJX_VV);
+  #include "../insns_func/vfsgnjx_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsgnjx_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSGNJX_VV);
+  #include "../insns_func/vfsgnjx_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsqrt_v.c b/arch/riscv/kernel/soft_vector/insns/vfsqrt_v.c
new file mode 100644
index 000000000000..260558203554
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsqrt_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsqrt_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSQRT_V);
+  #include "../insns_func/vfsqrt_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsqrt_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSQRT_V);
+  #include "../insns_func/vfsqrt_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfsub_vf.c
new file mode 100644
index 000000000000..398284534b58
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSUB_VF);
+  #include "../insns_func/vfsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSUB_VF);
+  #include "../insns_func/vfsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vfsub_vv.c
new file mode 100644
index 000000000000..325c2605103d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFSUB_VV);
+  #include "../insns_func/vfsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFSUB_VV);
+  #include "../insns_func/vfsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwadd_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwadd_vf.c
new file mode 100644
index 000000000000..e2892d93efc7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwadd_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWADD_VF);
+  #include "../insns_func/vfwadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwadd_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWADD_VF);
+  #include "../insns_func/vfwadd_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwadd_vv.c
new file mode 100644
index 000000000000..250c236d4729
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWADD_VV);
+  #include "../insns_func/vfwadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWADD_VV);
+  #include "../insns_func/vfwadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwadd_wf.c b/arch/riscv/kernel/soft_vector/insns/vfwadd_wf.c
new file mode 100644
index 000000000000..61ce7938929a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwadd_wf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwadd_wf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWADD_WF);
+  #include "../insns_func/vfwadd_wf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwadd_wf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWADD_WF);
+  #include "../insns_func/vfwadd_wf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwadd_wv.c b/arch/riscv/kernel/soft_vector/insns/vfwadd_wv.c
new file mode 100644
index 000000000000..f19583c51a87
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwadd_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwadd_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWADD_WV);
+  #include "../insns_func/vfwadd_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwadd_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWADD_WV);
+  #include "../insns_func/vfwadd_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_f_v.c
new file mode 100644
index 000000000000..0bd1e699fc53
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_f_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_F_V);
+  #include "../insns_func/vfwcvt_f_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_f_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_F_V);
+  #include "../insns_func/vfwcvt_f_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_x_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_x_v.c
new file mode 100644
index 000000000000..bc2569ef7c49
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_x_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_X_V);
+  #include "../insns_func/vfwcvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_f_x_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_X_V);
+  #include "../insns_func/vfwcvt_f_x_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_xu_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_xu_v.c
new file mode 100644
index 000000000000..cb0c96b6089f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_f_xu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_XU_V);
+  #include "../insns_func/vfwcvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_f_xu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_F_XU_V);
+  #include "../insns_func/vfwcvt_f_xu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_x_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_x_f_v.c
new file mode 100644
index 000000000000..590d84ab750e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_x_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_X_F_V);
+  #include "../insns_func/vfwcvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_x_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_X_F_V);
+  #include "../insns_func/vfwcvt_x_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwcvt_xu_f_v.c b/arch/riscv/kernel/soft_vector/insns/vfwcvt_xu_f_v.c
new file mode 100644
index 000000000000..95215748b712
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwcvt_xu_f_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwcvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWCVT_XU_F_V);
+  #include "../insns_func/vfwcvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwcvt_xu_f_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWCVT_XU_F_V);
+  #include "../insns_func/vfwcvt_xu_f_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmacc_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwmacc_vf.c
new file mode 100644
index 000000000000..9052a56895df
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmacc_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMACC_VF);
+  #include "../insns_func/vfwmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMACC_VF);
+  #include "../insns_func/vfwmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwmacc_vv.c
new file mode 100644
index 000000000000..acdd26f56bf3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMACC_VV);
+  #include "../insns_func/vfwmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMACC_VV);
+  #include "../insns_func/vfwmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmsac_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwmsac_vf.c
new file mode 100644
index 000000000000..366a355fb44f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmsac_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMSAC_VF);
+  #include "../insns_func/vfwmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMSAC_VF);
+  #include "../insns_func/vfwmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwmsac_vv.c
new file mode 100644
index 000000000000..928c0c3bd455
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMSAC_VV);
+  #include "../insns_func/vfwmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMSAC_VV);
+  #include "../insns_func/vfwmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmul_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwmul_vf.c
new file mode 100644
index 000000000000..79606eced54d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmul_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmul_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMUL_VF);
+  #include "../insns_func/vfwmul_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmul_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMUL_VF);
+  #include "../insns_func/vfwmul_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwmul_vv.c
new file mode 100644
index 000000000000..1d8aa5b9ac77
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWMUL_VV);
+  #include "../insns_func/vfwmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWMUL_VV);
+  #include "../insns_func/vfwmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vf.c
new file mode 100644
index 000000000000..76be04454e32
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwnmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWNMACC_VF);
+  #include "../insns_func/vfwnmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwnmacc_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWNMACC_VF);
+  #include "../insns_func/vfwnmacc_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vv.c
new file mode 100644
index 000000000000..3c78ef6462dc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwnmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwnmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWNMACC_VV);
+  #include "../insns_func/vfwnmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwnmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWNMACC_VV);
+  #include "../insns_func/vfwnmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vf.c
new file mode 100644
index 000000000000..85f8e28c8c6a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwnmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWNMSAC_VF);
+  #include "../insns_func/vfwnmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwnmsac_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWNMSAC_VF);
+  #include "../insns_func/vfwnmsac_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vv.c
new file mode 100644
index 000000000000..c357fc8df0b6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwnmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWNMSAC_VV);
+  #include "../insns_func/vfwnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWNMSAC_VV);
+  #include "../insns_func/vfwnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwredosum_vs.c b/arch/riscv/kernel/soft_vector/insns/vfwredosum_vs.c
new file mode 100644
index 000000000000..376490d2036d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwredosum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwredosum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWREDOSUM_VS);
+  #include "../insns_func/vfwredosum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwredosum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWREDOSUM_VS);
+  #include "../insns_func/vfwredosum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwredsum_vs.c b/arch/riscv/kernel/soft_vector/insns/vfwredsum_vs.c
new file mode 100644
index 000000000000..a07babc1eb2e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwredsum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWREDSUM_VS);
+  #include "../insns_func/vfwredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWREDSUM_VS);
+  #include "../insns_func/vfwredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwsub_vf.c b/arch/riscv/kernel/soft_vector/insns/vfwsub_vf.c
new file mode 100644
index 000000000000..41465bdbcabc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwsub_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWSUB_VF);
+  #include "../insns_func/vfwsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwsub_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWSUB_VF);
+  #include "../insns_func/vfwsub_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vfwsub_vv.c
new file mode 100644
index 000000000000..2202acd7fa8f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWSUB_VV);
+  #include "../insns_func/vfwsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWSUB_VV);
+  #include "../insns_func/vfwsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwsub_wf.c b/arch/riscv/kernel/soft_vector/insns/vfwsub_wf.c
new file mode 100644
index 000000000000..5b3b56b9bdee
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwsub_wf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwsub_wf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWSUB_WF);
+  #include "../insns_func/vfwsub_wf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwsub_wf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWSUB_WF);
+  #include "../insns_func/vfwsub_wf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vfwsub_wv.c b/arch/riscv/kernel/soft_vector/insns/vfwsub_wv.c
new file mode 100644
index 000000000000..c78d2e2202cf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vfwsub_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vfwsub_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VFWSUB_WV);
+  #include "../insns_func/vfwsub_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vfwsub_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VFWSUB_WV);
+  #include "../insns_func/vfwsub_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vid_v.c b/arch/riscv/kernel/soft_vector/insns/vid_v.c
new file mode 100644
index 000000000000..854988b810f7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vid_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vid_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VID_V);
+  #include "../insns_func/vid_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vid_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VID_V);
+  #include "../insns_func/vid_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/viota_m.c b/arch/riscv/kernel/soft_vector/insns/viota_m.c
new file mode 100644
index 000000000000..d18d30a51460
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/viota_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_viota_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VIOTA_M);
+  #include "../insns_func/viota_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_viota_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VIOTA_M);
+  #include "../insns_func/viota_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlb_v.c b/arch/riscv/kernel/soft_vector/insns/vlb_v.c
new file mode 100644
index 000000000000..ce9776c6e2d2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLB_V);
+  #include "../insns_func/vlb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLB_V);
+  #include "../insns_func/vlb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlbff_v.c b/arch/riscv/kernel/soft_vector/insns/vlbff_v.c
new file mode 100644
index 000000000000..4242ab3d86ae
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlbff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlbff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLBFF_V);
+  #include "../insns_func/vlbff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlbff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLBFF_V);
+  #include "../insns_func/vlbff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlbu_v.c b/arch/riscv/kernel/soft_vector/insns/vlbu_v.c
new file mode 100644
index 000000000000..b5b91d0bfe45
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlbu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLBU_V);
+  #include "../insns_func/vlbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLBU_V);
+  #include "../insns_func/vlbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlbuff_v.c b/arch/riscv/kernel/soft_vector/insns/vlbuff_v.c
new file mode 100644
index 000000000000..b959b6643c4a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlbuff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlbuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLBUFF_V);
+  #include "../insns_func/vlbuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlbuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLBUFF_V);
+  #include "../insns_func/vlbuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vle_v.c b/arch/riscv/kernel/soft_vector/insns/vle_v.c
new file mode 100644
index 000000000000..2cfe3a2d36a6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vle_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vle_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLE_V);
+  #include "../insns_func/vle_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vle_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLE_V);
+  #include "../insns_func/vle_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vleff_v.c b/arch/riscv/kernel/soft_vector/insns/vleff_v.c
new file mode 100644
index 000000000000..ecb868e0282e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vleff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vleff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLEFF_V);
+  #include "../insns_func/vleff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vleff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLEFF_V);
+  #include "../insns_func/vleff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlh_v.c b/arch/riscv/kernel/soft_vector/insns/vlh_v.c
new file mode 100644
index 000000000000..022abcf2bc09
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLH_V);
+  #include "../insns_func/vlh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLH_V);
+  #include "../insns_func/vlh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlhff_v.c b/arch/riscv/kernel/soft_vector/insns/vlhff_v.c
new file mode 100644
index 000000000000..f3defab3c022
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlhff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlhff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLHFF_V);
+  #include "../insns_func/vlhff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlhff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLHFF_V);
+  #include "../insns_func/vlhff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlhu_v.c b/arch/riscv/kernel/soft_vector/insns/vlhu_v.c
new file mode 100644
index 000000000000..8459f2220b81
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlhu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlhu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLHU_V);
+  #include "../insns_func/vlhu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlhu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLHU_V);
+  #include "../insns_func/vlhu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlhuff_v.c b/arch/riscv/kernel/soft_vector/insns/vlhuff_v.c
new file mode 100644
index 000000000000..7f376eb59da4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlhuff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlhuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLHUFF_V);
+  #include "../insns_func/vlhuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlhuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLHUFF_V);
+  #include "../insns_func/vlhuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlsb_v.c b/arch/riscv/kernel/soft_vector/insns/vlsb_v.c
new file mode 100644
index 000000000000..003645e6b0ea
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlsb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlsb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSB_V);
+  #include "../insns_func/vlsb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlsb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSB_V);
+  #include "../insns_func/vlsb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlsbu_v.c b/arch/riscv/kernel/soft_vector/insns/vlsbu_v.c
new file mode 100644
index 000000000000..565a18e8b740
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlsbu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlsbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSBU_V);
+  #include "../insns_func/vlsbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlsbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSBU_V);
+  #include "../insns_func/vlsbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlse_v.c b/arch/riscv/kernel/soft_vector/insns/vlse_v.c
new file mode 100644
index 000000000000..1966162bf852
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlse_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSE_V);
+  #include "../insns_func/vlse_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSE_V);
+  #include "../insns_func/vlse_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlsh_v.c b/arch/riscv/kernel/soft_vector/insns/vlsh_v.c
new file mode 100644
index 000000000000..e2897236f285
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlsh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlsh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSH_V);
+  #include "../insns_func/vlsh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlsh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSH_V);
+  #include "../insns_func/vlsh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlshu_v.c b/arch/riscv/kernel/soft_vector/insns/vlshu_v.c
new file mode 100644
index 000000000000..dcb86faab1eb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlshu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlshu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSHU_V);
+  #include "../insns_func/vlshu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlshu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSHU_V);
+  #include "../insns_func/vlshu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlsw_v.c b/arch/riscv/kernel/soft_vector/insns/vlsw_v.c
new file mode 100644
index 000000000000..4c98914cb2f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlsw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlsw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSW_V);
+  #include "../insns_func/vlsw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlsw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSW_V);
+  #include "../insns_func/vlsw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlswu_v.c b/arch/riscv/kernel/soft_vector/insns/vlswu_v.c
new file mode 100644
index 000000000000..26751462fe79
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlswu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlswu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLSWU_V);
+  #include "../insns_func/vlswu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlswu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLSWU_V);
+  #include "../insns_func/vlswu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlw_v.c b/arch/riscv/kernel/soft_vector/insns/vlw_v.c
new file mode 100644
index 000000000000..b86ce2dd5f88
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLW_V);
+  #include "../insns_func/vlw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLW_V);
+  #include "../insns_func/vlw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlwff_v.c b/arch/riscv/kernel/soft_vector/insns/vlwff_v.c
new file mode 100644
index 000000000000..8c5fb41f6191
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlwff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlwff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLWFF_V);
+  #include "../insns_func/vlwff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlwff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLWFF_V);
+  #include "../insns_func/vlwff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlwu_v.c b/arch/riscv/kernel/soft_vector/insns/vlwu_v.c
new file mode 100644
index 000000000000..aa7151aac33a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlwu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlwu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLWU_V);
+  #include "../insns_func/vlwu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlwu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLWU_V);
+  #include "../insns_func/vlwu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlwuff_v.c b/arch/riscv/kernel/soft_vector/insns/vlwuff_v.c
new file mode 100644
index 000000000000..c9de1b7e72cb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlwuff_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlwuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLWUFF_V);
+  #include "../insns_func/vlwuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlwuff_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLWUFF_V);
+  #include "../insns_func/vlwuff_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxb_v.c b/arch/riscv/kernel/soft_vector/insns/vlxb_v.c
new file mode 100644
index 000000000000..2cb11bf9f82d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXB_V);
+  #include "../insns_func/vlxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXB_V);
+  #include "../insns_func/vlxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxbu_v.c b/arch/riscv/kernel/soft_vector/insns/vlxbu_v.c
new file mode 100644
index 000000000000..508e97bd39f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxbu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXBU_V);
+  #include "../insns_func/vlxbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxbu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXBU_V);
+  #include "../insns_func/vlxbu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxe_v.c b/arch/riscv/kernel/soft_vector/insns/vlxe_v.c
new file mode 100644
index 000000000000..bbea62df3e68
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxe_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXE_V);
+  #include "../insns_func/vlxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXE_V);
+  #include "../insns_func/vlxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxh_v.c b/arch/riscv/kernel/soft_vector/insns/vlxh_v.c
new file mode 100644
index 000000000000..fbdc04d80004
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXH_V);
+  #include "../insns_func/vlxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXH_V);
+  #include "../insns_func/vlxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxhu_v.c b/arch/riscv/kernel/soft_vector/insns/vlxhu_v.c
new file mode 100644
index 000000000000..574c43ccc054
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxhu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxhu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXHU_V);
+  #include "../insns_func/vlxhu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxhu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXHU_V);
+  #include "../insns_func/vlxhu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxw_v.c b/arch/riscv/kernel/soft_vector/insns/vlxw_v.c
new file mode 100644
index 000000000000..bfb117c91977
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXW_V);
+  #include "../insns_func/vlxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXW_V);
+  #include "../insns_func/vlxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vlxwu_v.c b/arch/riscv/kernel/soft_vector/insns/vlxwu_v.c
new file mode 100644
index 000000000000..789774a7ffe0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vlxwu_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vlxwu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VLXWU_V);
+  #include "../insns_func/vlxwu_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vlxwu_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VLXWU_V);
+  #include "../insns_func/vlxwu_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vmacc_vv.c
new file mode 100644
index 000000000000..6b1872b2f75a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMACC_VV);
+  #include "../insns_func/vmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMACC_VV);
+  #include "../insns_func/vmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmacc_vx.c b/arch/riscv/kernel/soft_vector/insns/vmacc_vx.c
new file mode 100644
index 000000000000..5b101f453ddf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmacc_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMACC_VX);
+  #include "../insns_func/vmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMACC_VX);
+  #include "../insns_func/vmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadc_vim.c b/arch/riscv/kernel/soft_vector/insns/vmadc_vim.c
new file mode 100644
index 000000000000..504b700abc70
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadc_vim.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadc_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADC_VIM);
+  #include "../insns_func/vmadc_vim.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadc_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADC_VIM);
+  #include "../insns_func/vmadc_vim.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadc_vvm.c b/arch/riscv/kernel/soft_vector/insns/vmadc_vvm.c
new file mode 100644
index 000000000000..fb38afc540a7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadc_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADC_VVM);
+  #include "../insns_func/vmadc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADC_VVM);
+  #include "../insns_func/vmadc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadc_vxm.c b/arch/riscv/kernel/soft_vector/insns/vmadc_vxm.c
new file mode 100644
index 000000000000..62e98fc3d2cf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadc_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADC_VXM);
+  #include "../insns_func/vmadc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADC_VXM);
+  #include "../insns_func/vmadc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vmadd_vv.c
new file mode 100644
index 000000000000..143db556da9a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADD_VV);
+  #include "../insns_func/vmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADD_VV);
+  #include "../insns_func/vmadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vmadd_vx.c
new file mode 100644
index 000000000000..93c1375937ca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMADD_VX);
+  #include "../insns_func/vmadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMADD_VX);
+  #include "../insns_func/vmadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmand_mm.c b/arch/riscv/kernel/soft_vector/insns/vmand_mm.c
new file mode 100644
index 000000000000..cf3441b5c91e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmand_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmand_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAND_MM);
+  #include "../insns_func/vmand_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmand_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAND_MM);
+  #include "../insns_func/vmand_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmandnot_mm.c b/arch/riscv/kernel/soft_vector/insns/vmandnot_mm.c
new file mode 100644
index 000000000000..004b1da468a3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmandnot_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmandnot_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMANDNOT_MM);
+  #include "../insns_func/vmandnot_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmandnot_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMANDNOT_MM);
+  #include "../insns_func/vmandnot_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmax_vv.c b/arch/riscv/kernel/soft_vector/insns/vmax_vv.c
new file mode 100644
index 000000000000..e4ce31f46cd3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmax_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmax_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAX_VV);
+  #include "../insns_func/vmax_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmax_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAX_VV);
+  #include "../insns_func/vmax_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmax_vx.c b/arch/riscv/kernel/soft_vector/insns/vmax_vx.c
new file mode 100644
index 000000000000..9c5a2385525f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmax_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmax_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAX_VX);
+  #include "../insns_func/vmax_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmax_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAX_VX);
+  #include "../insns_func/vmax_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmaxu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmaxu_vv.c
new file mode 100644
index 000000000000..70884689cb5f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmaxu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmaxu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAXU_VV);
+  #include "../insns_func/vmaxu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmaxu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAXU_VV);
+  #include "../insns_func/vmaxu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmaxu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmaxu_vx.c
new file mode 100644
index 000000000000..b3b662b5f319
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmaxu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmaxu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMAXU_VX);
+  #include "../insns_func/vmaxu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmaxu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMAXU_VX);
+  #include "../insns_func/vmaxu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmerge_vim.c b/arch/riscv/kernel/soft_vector/insns/vmerge_vim.c
new file mode 100644
index 000000000000..84b019567e45
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmerge_vim.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmerge_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMERGE_VIM);
+  #include "../insns_func/vmerge_vim.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmerge_vim(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMERGE_VIM);
+  #include "../insns_func/vmerge_vim.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmerge_vvm.c b/arch/riscv/kernel/soft_vector/insns/vmerge_vvm.c
new file mode 100644
index 000000000000..a72ba4bf7702
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmerge_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmerge_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMERGE_VVM);
+  #include "../insns_func/vmerge_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmerge_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMERGE_VVM);
+  #include "../insns_func/vmerge_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmerge_vxm.c b/arch/riscv/kernel/soft_vector/insns/vmerge_vxm.c
new file mode 100644
index 000000000000..9d02f30b2621
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmerge_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmerge_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMERGE_VXM);
+  #include "../insns_func/vmerge_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmerge_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMERGE_VXM);
+  #include "../insns_func/vmerge_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfeq_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfeq_vf.c
new file mode 100644
index 000000000000..4a76d6fc7a70
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfeq_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfeq_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFEQ_VF);
+  #include "../insns_func/vmfeq_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfeq_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFEQ_VF);
+  #include "../insns_func/vmfeq_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfeq_vv.c b/arch/riscv/kernel/soft_vector/insns/vmfeq_vv.c
new file mode 100644
index 000000000000..d648c390d7a1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfeq_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfeq_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFEQ_VV);
+  #include "../insns_func/vmfeq_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfeq_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFEQ_VV);
+  #include "../insns_func/vmfeq_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfge_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfge_vf.c
new file mode 100644
index 000000000000..52f585c9ee15
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfge_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfge_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFGE_VF);
+  #include "../insns_func/vmfge_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfge_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFGE_VF);
+  #include "../insns_func/vmfge_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfgt_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfgt_vf.c
new file mode 100644
index 000000000000..489b35234f10
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfgt_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfgt_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFGT_VF);
+  #include "../insns_func/vmfgt_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfgt_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFGT_VF);
+  #include "../insns_func/vmfgt_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfirst_m.c b/arch/riscv/kernel/soft_vector/insns/vmfirst_m.c
new file mode 100644
index 000000000000..b4ca73a90136
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfirst_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfirst_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFIRST_M);
+  #include "../insns_func/vmfirst_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfirst_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFIRST_M);
+  #include "../insns_func/vmfirst_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfle_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfle_vf.c
new file mode 100644
index 000000000000..ff31d3d72bfe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfle_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfle_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFLE_VF);
+  #include "../insns_func/vmfle_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfle_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFLE_VF);
+  #include "../insns_func/vmfle_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfle_vv.c b/arch/riscv/kernel/soft_vector/insns/vmfle_vv.c
new file mode 100644
index 000000000000..732b20fbb34c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfle_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfle_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFLE_VV);
+  #include "../insns_func/vmfle_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfle_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFLE_VV);
+  #include "../insns_func/vmfle_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmflt_vf.c b/arch/riscv/kernel/soft_vector/insns/vmflt_vf.c
new file mode 100644
index 000000000000..8470f2e8c116
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmflt_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmflt_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFLT_VF);
+  #include "../insns_func/vmflt_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmflt_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFLT_VF);
+  #include "../insns_func/vmflt_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmflt_vv.c b/arch/riscv/kernel/soft_vector/insns/vmflt_vv.c
new file mode 100644
index 000000000000..9efde0c3899f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmflt_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmflt_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFLT_VV);
+  #include "../insns_func/vmflt_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmflt_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFLT_VV);
+  #include "../insns_func/vmflt_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfne_vf.c b/arch/riscv/kernel/soft_vector/insns/vmfne_vf.c
new file mode 100644
index 000000000000..7f2a497f6f42
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfne_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfne_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFNE_VF);
+  #include "../insns_func/vmfne_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfne_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFNE_VF);
+  #include "../insns_func/vmfne_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmfne_vv.c b/arch/riscv/kernel/soft_vector/insns/vmfne_vv.c
new file mode 100644
index 000000000000..9e1f826cebc6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmfne_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmfne_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFNE_VV);
+  #include "../insns_func/vmfne_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmfne_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFNE_VV);
+  #include "../insns_func/vmfne_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmford_vf.c b/arch/riscv/kernel/soft_vector/insns/vmford_vf.c
new file mode 100644
index 000000000000..f8e1a8f290ed
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmford_vf.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmford_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFORD_VF);
+  #include "../insns_func/vmford_vf.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmford_vf(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFORD_VF);
+  #include "../insns_func/vmford_vf.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmford_vv.c b/arch/riscv/kernel/soft_vector/insns/vmford_vv.c
new file mode 100644
index 000000000000..0f8de741e10d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmford_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmford_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMFORD_VV);
+  #include "../insns_func/vmford_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmford_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMFORD_VV);
+  #include "../insns_func/vmford_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmin_vv.c b/arch/riscv/kernel/soft_vector/insns/vmin_vv.c
new file mode 100644
index 000000000000..d93b6e91cc55
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmin_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmin_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMIN_VV);
+  #include "../insns_func/vmin_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmin_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMIN_VV);
+  #include "../insns_func/vmin_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmin_vx.c b/arch/riscv/kernel/soft_vector/insns/vmin_vx.c
new file mode 100644
index 000000000000..9c0c2d2c6010
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmin_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmin_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMIN_VX);
+  #include "../insns_func/vmin_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmin_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMIN_VX);
+  #include "../insns_func/vmin_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vminu_vv.c b/arch/riscv/kernel/soft_vector/insns/vminu_vv.c
new file mode 100644
index 000000000000..ce2499f4abcc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vminu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vminu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMINU_VV);
+  #include "../insns_func/vminu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vminu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMINU_VV);
+  #include "../insns_func/vminu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vminu_vx.c b/arch/riscv/kernel/soft_vector/insns/vminu_vx.c
new file mode 100644
index 000000000000..6a074ac24091
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vminu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vminu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMINU_VX);
+  #include "../insns_func/vminu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vminu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMINU_VX);
+  #include "../insns_func/vminu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmnand_mm.c b/arch/riscv/kernel/soft_vector/insns/vmnand_mm.c
new file mode 100644
index 000000000000..844a9f38a52e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmnand_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmnand_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMNAND_MM);
+  #include "../insns_func/vmnand_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmnand_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMNAND_MM);
+  #include "../insns_func/vmnand_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmnor_mm.c b/arch/riscv/kernel/soft_vector/insns/vmnor_mm.c
new file mode 100644
index 000000000000..d106daf72db4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmnor_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmnor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMNOR_MM);
+  #include "../insns_func/vmnor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmnor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMNOR_MM);
+  #include "../insns_func/vmnor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmor_mm.c b/arch/riscv/kernel/soft_vector/insns/vmor_mm.c
new file mode 100644
index 000000000000..c7e31a9d086d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmor_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMOR_MM);
+  #include "../insns_func/vmor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMOR_MM);
+  #include "../insns_func/vmor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmornot_mm.c b/arch/riscv/kernel/soft_vector/insns/vmornot_mm.c
new file mode 100644
index 000000000000..ed4323524ae8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmornot_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmornot_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMORNOT_MM);
+  #include "../insns_func/vmornot_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmornot_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMORNOT_MM);
+  #include "../insns_func/vmornot_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmpopc_m.c b/arch/riscv/kernel/soft_vector/insns/vmpopc_m.c
new file mode 100644
index 000000000000..74eff3d98f8d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmpopc_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmpopc_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMPOPC_M);
+  #include "../insns_func/vmpopc_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmpopc_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMPOPC_M);
+  #include "../insns_func/vmpopc_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsbc_vvm.c b/arch/riscv/kernel/soft_vector/insns/vmsbc_vvm.c
new file mode 100644
index 000000000000..e64e16171336
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsbc_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsbc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSBC_VVM);
+  #include "../insns_func/vmsbc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsbc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSBC_VVM);
+  #include "../insns_func/vmsbc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsbc_vxm.c b/arch/riscv/kernel/soft_vector/insns/vmsbc_vxm.c
new file mode 100644
index 000000000000..2fcf72a7bdb3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsbc_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsbc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSBC_VXM);
+  #include "../insns_func/vmsbc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsbc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSBC_VXM);
+  #include "../insns_func/vmsbc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsbf_m.c b/arch/riscv/kernel/soft_vector/insns/vmsbf_m.c
new file mode 100644
index 000000000000..1900dba9ef5c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsbf_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsbf_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSBF_M);
+  #include "../insns_func/vmsbf_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsbf_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSBF_M);
+  #include "../insns_func/vmsbf_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmseq_vi.c b/arch/riscv/kernel/soft_vector/insns/vmseq_vi.c
new file mode 100644
index 000000000000..ebe43137aabd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmseq_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmseq_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSEQ_VI);
+  #include "../insns_func/vmseq_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmseq_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSEQ_VI);
+  #include "../insns_func/vmseq_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmseq_vv.c b/arch/riscv/kernel/soft_vector/insns/vmseq_vv.c
new file mode 100644
index 000000000000..c910cd329bf0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmseq_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmseq_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSEQ_VV);
+  #include "../insns_func/vmseq_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmseq_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSEQ_VV);
+  #include "../insns_func/vmseq_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmseq_vx.c b/arch/riscv/kernel/soft_vector/insns/vmseq_vx.c
new file mode 100644
index 000000000000..8271a19274d6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmseq_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmseq_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSEQ_VX);
+  #include "../insns_func/vmseq_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmseq_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSEQ_VX);
+  #include "../insns_func/vmseq_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsgt_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsgt_vi.c
new file mode 100644
index 000000000000..9a7ce33a9b9f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsgt_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsgt_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSGT_VI);
+  #include "../insns_func/vmsgt_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsgt_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSGT_VI);
+  #include "../insns_func/vmsgt_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsgt_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsgt_vx.c
new file mode 100644
index 000000000000..4757ddba7193
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsgt_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsgt_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSGT_VX);
+  #include "../insns_func/vmsgt_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsgt_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSGT_VX);
+  #include "../insns_func/vmsgt_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsgtu_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsgtu_vi.c
new file mode 100644
index 000000000000..883867575cb0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsgtu_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsgtu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSGTU_VI);
+  #include "../insns_func/vmsgtu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsgtu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSGTU_VI);
+  #include "../insns_func/vmsgtu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsgtu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsgtu_vx.c
new file mode 100644
index 000000000000..b6e9814fa21e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsgtu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsgtu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSGTU_VX);
+  #include "../insns_func/vmsgtu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsgtu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSGTU_VX);
+  #include "../insns_func/vmsgtu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsif_m.c b/arch/riscv/kernel/soft_vector/insns/vmsif_m.c
new file mode 100644
index 000000000000..2406bc9017c6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsif_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsif_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSIF_M);
+  #include "../insns_func/vmsif_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsif_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSIF_M);
+  #include "../insns_func/vmsif_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsle_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsle_vi.c
new file mode 100644
index 000000000000..365f948c7868
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsle_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsle_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLE_VI);
+  #include "../insns_func/vmsle_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsle_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLE_VI);
+  #include "../insns_func/vmsle_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsle_vv.c b/arch/riscv/kernel/soft_vector/insns/vmsle_vv.c
new file mode 100644
index 000000000000..414e4d87f0e9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsle_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsle_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLE_VV);
+  #include "../insns_func/vmsle_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsle_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLE_VV);
+  #include "../insns_func/vmsle_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsle_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsle_vx.c
new file mode 100644
index 000000000000..b84151d31a3c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsle_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsle_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLE_VX);
+  #include "../insns_func/vmsle_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsle_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLE_VX);
+  #include "../insns_func/vmsle_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsleu_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsleu_vi.c
new file mode 100644
index 000000000000..d3fd9f2465b9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsleu_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsleu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLEU_VI);
+  #include "../insns_func/vmsleu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsleu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLEU_VI);
+  #include "../insns_func/vmsleu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsleu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmsleu_vv.c
new file mode 100644
index 000000000000..e4eb56abe8c8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsleu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsleu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLEU_VV);
+  #include "../insns_func/vmsleu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsleu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLEU_VV);
+  #include "../insns_func/vmsleu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsleu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsleu_vx.c
new file mode 100644
index 000000000000..47877380a94b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsleu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsleu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLEU_VX);
+  #include "../insns_func/vmsleu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsleu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLEU_VX);
+  #include "../insns_func/vmsleu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmslt_vv.c b/arch/riscv/kernel/soft_vector/insns/vmslt_vv.c
new file mode 100644
index 000000000000..433730bb2c49
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmslt_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmslt_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLT_VV);
+  #include "../insns_func/vmslt_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmslt_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLT_VV);
+  #include "../insns_func/vmslt_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmslt_vx.c b/arch/riscv/kernel/soft_vector/insns/vmslt_vx.c
new file mode 100644
index 000000000000..03d23d8564a0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmslt_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmslt_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLT_VX);
+  #include "../insns_func/vmslt_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmslt_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLT_VX);
+  #include "../insns_func/vmslt_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsltu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmsltu_vv.c
new file mode 100644
index 000000000000..ab1493fc6b02
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsltu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsltu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLTU_VV);
+  #include "../insns_func/vmsltu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsltu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLTU_VV);
+  #include "../insns_func/vmsltu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsltu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsltu_vx.c
new file mode 100644
index 000000000000..addd3ecc69d7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsltu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsltu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSLTU_VX);
+  #include "../insns_func/vmsltu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsltu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSLTU_VX);
+  #include "../insns_func/vmsltu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsne_vi.c b/arch/riscv/kernel/soft_vector/insns/vmsne_vi.c
new file mode 100644
index 000000000000..96516a7aad73
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsne_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsne_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSNE_VI);
+  #include "../insns_func/vmsne_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsne_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSNE_VI);
+  #include "../insns_func/vmsne_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsne_vv.c b/arch/riscv/kernel/soft_vector/insns/vmsne_vv.c
new file mode 100644
index 000000000000..a0c852b3df79
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsne_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsne_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSNE_VV);
+  #include "../insns_func/vmsne_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsne_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSNE_VV);
+  #include "../insns_func/vmsne_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsne_vx.c b/arch/riscv/kernel/soft_vector/insns/vmsne_vx.c
new file mode 100644
index 000000000000..6d0b93b16aa9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsne_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsne_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSNE_VX);
+  #include "../insns_func/vmsne_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsne_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSNE_VX);
+  #include "../insns_func/vmsne_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmsof_m.c b/arch/riscv/kernel/soft_vector/insns/vmsof_m.c
new file mode 100644
index 000000000000..0bae2b7957d2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmsof_m.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmsof_m(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMSOF_M);
+  #include "../insns_func/vmsof_m.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmsof_m(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMSOF_M);
+  #include "../insns_func/vmsof_m.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vmul_vv.c
new file mode 100644
index 000000000000..6cff5c8810a1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMUL_VV);
+  #include "../insns_func/vmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMUL_VV);
+  #include "../insns_func/vmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmul_vx.c b/arch/riscv/kernel/soft_vector/insns/vmul_vx.c
new file mode 100644
index 000000000000..46860112b869
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmul_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMUL_VX);
+  #include "../insns_func/vmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMUL_VX);
+  #include "../insns_func/vmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulh_vv.c b/arch/riscv/kernel/soft_vector/insns/vmulh_vv.c
new file mode 100644
index 000000000000..75334c0bb234
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulh_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulh_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULH_VV);
+  #include "../insns_func/vmulh_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulh_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULH_VV);
+  #include "../insns_func/vmulh_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulh_vx.c b/arch/riscv/kernel/soft_vector/insns/vmulh_vx.c
new file mode 100644
index 000000000000..6e1ee9d4ee00
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulh_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulh_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULH_VX);
+  #include "../insns_func/vmulh_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulh_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULH_VX);
+  #include "../insns_func/vmulh_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulhsu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmulhsu_vv.c
new file mode 100644
index 000000000000..4b87d6e8f275
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulhsu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulhsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULHSU_VV);
+  #include "../insns_func/vmulhsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulhsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULHSU_VV);
+  #include "../insns_func/vmulhsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulhsu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmulhsu_vx.c
new file mode 100644
index 000000000000..506bd0cb9eeb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulhsu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulhsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULHSU_VX);
+  #include "../insns_func/vmulhsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulhsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULHSU_VX);
+  #include "../insns_func/vmulhsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulhu_vv.c b/arch/riscv/kernel/soft_vector/insns/vmulhu_vv.c
new file mode 100644
index 000000000000..d440613f8258
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulhu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulhu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULHU_VV);
+  #include "../insns_func/vmulhu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulhu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULHU_VV);
+  #include "../insns_func/vmulhu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmulhu_vx.c b/arch/riscv/kernel/soft_vector/insns/vmulhu_vx.c
new file mode 100644
index 000000000000..c9f01b0246f5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmulhu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmulhu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMULHU_VX);
+  #include "../insns_func/vmulhu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmulhu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMULHU_VX);
+  #include "../insns_func/vmulhu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmv_s_x.c b/arch/riscv/kernel/soft_vector/insns/vmv_s_x.c
new file mode 100644
index 000000000000..e322a2c87637
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmv_s_x.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmv_s_x(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMV_S_X);
+  #include "../insns_func/vmv_s_x.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmv_s_x(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMV_S_X);
+  #include "../insns_func/vmv_s_x.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmv_v_i.c b/arch/riscv/kernel/soft_vector/insns/vmv_v_i.c
new file mode 100644
index 000000000000..b707150375e1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmv_v_i.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmv_v_i(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMV_V_I);
+  #include "../insns_func/vmv_v_i.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmv_v_i(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMV_V_I);
+  #include "../insns_func/vmv_v_i.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmv_v_v.c b/arch/riscv/kernel/soft_vector/insns/vmv_v_v.c
new file mode 100644
index 000000000000..e6808297ec3f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmv_v_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmv_v_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMV_V_V);
+  #include "../insns_func/vmv_v_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmv_v_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMV_V_V);
+  #include "../insns_func/vmv_v_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmv_v_x.c b/arch/riscv/kernel/soft_vector/insns/vmv_v_x.c
new file mode 100644
index 000000000000..19c99057d84d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmv_v_x.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmv_v_x(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMV_V_X);
+  #include "../insns_func/vmv_v_x.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmv_v_x(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMV_V_X);
+  #include "../insns_func/vmv_v_x.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmxnor_mm.c b/arch/riscv/kernel/soft_vector/insns/vmxnor_mm.c
new file mode 100644
index 000000000000..2d4161d9f27c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmxnor_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmxnor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMXNOR_MM);
+  #include "../insns_func/vmxnor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmxnor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMXNOR_MM);
+  #include "../insns_func/vmxnor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vmxor_mm.c b/arch/riscv/kernel/soft_vector/insns/vmxor_mm.c
new file mode 100644
index 000000000000..d1de833f43ae
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vmxor_mm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vmxor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VMXOR_MM);
+  #include "../insns_func/vmxor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vmxor_mm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VMXOR_MM);
+  #include "../insns_func/vmxor_mm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclip_vi.c b/arch/riscv/kernel/soft_vector/insns/vnclip_vi.c
new file mode 100644
index 000000000000..c77909e8c20f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclip_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclip_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIP_VI);
+  #include "../insns_func/vnclip_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclip_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIP_VI);
+  #include "../insns_func/vnclip_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclip_vv.c b/arch/riscv/kernel/soft_vector/insns/vnclip_vv.c
new file mode 100644
index 000000000000..8f19fb9eff5b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclip_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclip_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIP_VV);
+  #include "../insns_func/vnclip_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclip_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIP_VV);
+  #include "../insns_func/vnclip_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclip_vx.c b/arch/riscv/kernel/soft_vector/insns/vnclip_vx.c
new file mode 100644
index 000000000000..74be2cc29973
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclip_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclip_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIP_VX);
+  #include "../insns_func/vnclip_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclip_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIP_VX);
+  #include "../insns_func/vnclip_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclipu_vi.c b/arch/riscv/kernel/soft_vector/insns/vnclipu_vi.c
new file mode 100644
index 000000000000..240ff439b690
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclipu_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclipu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VI);
+  #include "../insns_func/vnclipu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclipu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VI);
+  #include "../insns_func/vnclipu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclipu_vv.c b/arch/riscv/kernel/soft_vector/insns/vnclipu_vv.c
new file mode 100644
index 000000000000..a1127eab7f97
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclipu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclipu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VV);
+  #include "../insns_func/vnclipu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclipu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VV);
+  #include "../insns_func/vnclipu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnclipu_vx.c b/arch/riscv/kernel/soft_vector/insns/vnclipu_vx.c
new file mode 100644
index 000000000000..2a2ea2a2a7f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnclipu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnclipu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VX);
+  #include "../insns_func/vnclipu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnclipu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNCLIPU_VX);
+  #include "../insns_func/vnclipu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnmsac_vv.c b/arch/riscv/kernel/soft_vector/insns/vnmsac_vv.c
new file mode 100644
index 000000000000..dff71a748bf6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnmsac_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNMSAC_VV);
+  #include "../insns_func/vnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnmsac_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNMSAC_VV);
+  #include "../insns_func/vnmsac_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnmsac_vx.c b/arch/riscv/kernel/soft_vector/insns/vnmsac_vx.c
new file mode 100644
index 000000000000..9d25188cfb2a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnmsac_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnmsac_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNMSAC_VX);
+  #include "../insns_func/vnmsac_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnmsac_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNMSAC_VX);
+  #include "../insns_func/vnmsac_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnmsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vnmsub_vv.c
new file mode 100644
index 000000000000..47edf3cdec4d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnmsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNMSUB_VV);
+  #include "../insns_func/vnmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnmsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNMSUB_VV);
+  #include "../insns_func/vnmsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnmsub_vx.c b/arch/riscv/kernel/soft_vector/insns/vnmsub_vx.c
new file mode 100644
index 000000000000..4e4664f6db47
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnmsub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnmsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNMSUB_VX);
+  #include "../insns_func/vnmsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnmsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNMSUB_VX);
+  #include "../insns_func/vnmsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsra_vi.c b/arch/riscv/kernel/soft_vector/insns/vnsra_vi.c
new file mode 100644
index 000000000000..8d67a3d064ae
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsra_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRA_VI);
+  #include "../insns_func/vnsra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRA_VI);
+  #include "../insns_func/vnsra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsra_vv.c b/arch/riscv/kernel/soft_vector/insns/vnsra_vv.c
new file mode 100644
index 000000000000..719f08102bb1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsra_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRA_VV);
+  #include "../insns_func/vnsra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRA_VV);
+  #include "../insns_func/vnsra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsra_vx.c b/arch/riscv/kernel/soft_vector/insns/vnsra_vx.c
new file mode 100644
index 000000000000..f5c1149082c4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsra_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRA_VX);
+  #include "../insns_func/vnsra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRA_VX);
+  #include "../insns_func/vnsra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsrl_vi.c b/arch/riscv/kernel/soft_vector/insns/vnsrl_vi.c
new file mode 100644
index 000000000000..613c32d5e3eb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsrl_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRL_VI);
+  #include "../insns_func/vnsrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRL_VI);
+  #include "../insns_func/vnsrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsrl_vv.c b/arch/riscv/kernel/soft_vector/insns/vnsrl_vv.c
new file mode 100644
index 000000000000..a71137dee043
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsrl_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRL_VV);
+  #include "../insns_func/vnsrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRL_VV);
+  #include "../insns_func/vnsrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vnsrl_vx.c b/arch/riscv/kernel/soft_vector/insns/vnsrl_vx.c
new file mode 100644
index 000000000000..51057f152fdb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vnsrl_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vnsrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VNSRL_VX);
+  #include "../insns_func/vnsrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vnsrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VNSRL_VX);
+  #include "../insns_func/vnsrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vor_vi.c b/arch/riscv/kernel/soft_vector/insns/vor_vi.c
new file mode 100644
index 000000000000..964ec9624f02
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vor_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vor_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VOR_VI);
+  #include "../insns_func/vor_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vor_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VOR_VI);
+  #include "../insns_func/vor_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vor_vv.c b/arch/riscv/kernel/soft_vector/insns/vor_vv.c
new file mode 100644
index 000000000000..1a63b7eabeea
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vor_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vor_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VOR_VV);
+  #include "../insns_func/vor_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vor_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VOR_VV);
+  #include "../insns_func/vor_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vor_vx.c b/arch/riscv/kernel/soft_vector/insns/vor_vx.c
new file mode 100644
index 000000000000..4d30b520027c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vor_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vor_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VOR_VX);
+  #include "../insns_func/vor_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vor_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VOR_VX);
+  #include "../insns_func/vor_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredand_vs.c b/arch/riscv/kernel/soft_vector/insns/vredand_vs.c
new file mode 100644
index 000000000000..5109ce25f308
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredand_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredand_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDAND_VS);
+  #include "../insns_func/vredand_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredand_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDAND_VS);
+  #include "../insns_func/vredand_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredmax_vs.c b/arch/riscv/kernel/soft_vector/insns/vredmax_vs.c
new file mode 100644
index 000000000000..5990ffedac0d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredmax_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredmax_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDMAX_VS);
+  #include "../insns_func/vredmax_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredmax_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDMAX_VS);
+  #include "../insns_func/vredmax_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredmaxu_vs.c b/arch/riscv/kernel/soft_vector/insns/vredmaxu_vs.c
new file mode 100644
index 000000000000..1d6507f72025
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredmaxu_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredmaxu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDMAXU_VS);
+  #include "../insns_func/vredmaxu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredmaxu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDMAXU_VS);
+  #include "../insns_func/vredmaxu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredmin_vs.c b/arch/riscv/kernel/soft_vector/insns/vredmin_vs.c
new file mode 100644
index 000000000000..3fc5b2485fa9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredmin_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredmin_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDMIN_VS);
+  #include "../insns_func/vredmin_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredmin_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDMIN_VS);
+  #include "../insns_func/vredmin_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredminu_vs.c b/arch/riscv/kernel/soft_vector/insns/vredminu_vs.c
new file mode 100644
index 000000000000..0646ba453632
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredminu_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredminu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDMINU_VS);
+  #include "../insns_func/vredminu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredminu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDMINU_VS);
+  #include "../insns_func/vredminu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredor_vs.c b/arch/riscv/kernel/soft_vector/insns/vredor_vs.c
new file mode 100644
index 000000000000..85469f39e7a7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredor_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredor_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDOR_VS);
+  #include "../insns_func/vredor_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredor_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDOR_VS);
+  #include "../insns_func/vredor_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredsum_vs.c b/arch/riscv/kernel/soft_vector/insns/vredsum_vs.c
new file mode 100644
index 000000000000..21557895af42
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredsum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDSUM_VS);
+  #include "../insns_func/vredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDSUM_VS);
+  #include "../insns_func/vredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vredxor_vs.c b/arch/riscv/kernel/soft_vector/insns/vredxor_vs.c
new file mode 100644
index 000000000000..add3322c046a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vredxor_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vredxor_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREDXOR_VS);
+  #include "../insns_func/vredxor_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vredxor_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREDXOR_VS);
+  #include "../insns_func/vredxor_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrem_vv.c b/arch/riscv/kernel/soft_vector/insns/vrem_vv.c
new file mode 100644
index 000000000000..b2c0230437c4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrem_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrem_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREM_VV);
+  #include "../insns_func/vrem_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrem_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREM_VV);
+  #include "../insns_func/vrem_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrem_vx.c b/arch/riscv/kernel/soft_vector/insns/vrem_vx.c
new file mode 100644
index 000000000000..f7a6fa28c02f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrem_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrem_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREM_VX);
+  #include "../insns_func/vrem_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrem_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREM_VX);
+  #include "../insns_func/vrem_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vremu_vv.c b/arch/riscv/kernel/soft_vector/insns/vremu_vv.c
new file mode 100644
index 000000000000..66fca3e664c4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vremu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vremu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREMU_VV);
+  #include "../insns_func/vremu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vremu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREMU_VV);
+  #include "../insns_func/vremu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vremu_vx.c b/arch/riscv/kernel/soft_vector/insns/vremu_vx.c
new file mode 100644
index 000000000000..efaa37cd2d1a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vremu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vremu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VREMU_VX);
+  #include "../insns_func/vremu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vremu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VREMU_VX);
+  #include "../insns_func/vremu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrgather_vi.c b/arch/riscv/kernel/soft_vector/insns/vrgather_vi.c
new file mode 100644
index 000000000000..e025d62bdc80
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrgather_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrgather_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRGATHER_VI);
+  #include "../insns_func/vrgather_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrgather_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRGATHER_VI);
+  #include "../insns_func/vrgather_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrgather_vv.c b/arch/riscv/kernel/soft_vector/insns/vrgather_vv.c
new file mode 100644
index 000000000000..c7ccb3c19433
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrgather_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrgather_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRGATHER_VV);
+  #include "../insns_func/vrgather_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrgather_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRGATHER_VV);
+  #include "../insns_func/vrgather_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrgather_vx.c b/arch/riscv/kernel/soft_vector/insns/vrgather_vx.c
new file mode 100644
index 000000000000..d7c4c9ecc07f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrgather_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrgather_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRGATHER_VX);
+  #include "../insns_func/vrgather_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrgather_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRGATHER_VX);
+  #include "../insns_func/vrgather_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrsub_vi.c b/arch/riscv/kernel/soft_vector/insns/vrsub_vi.c
new file mode 100644
index 000000000000..11e8338d792d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrsub_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrsub_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRSUB_VI);
+  #include "../insns_func/vrsub_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrsub_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRSUB_VI);
+  #include "../insns_func/vrsub_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vrsub_vx.c b/arch/riscv/kernel/soft_vector/insns/vrsub_vx.c
new file mode 100644
index 000000000000..4a4277941237
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vrsub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vrsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VRSUB_VX);
+  #include "../insns_func/vrsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vrsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VRSUB_VX);
+  #include "../insns_func/vrsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsadd_vi.c b/arch/riscv/kernel/soft_vector/insns/vsadd_vi.c
new file mode 100644
index 000000000000..9534d00a55eb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsadd_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADD_VI);
+  #include "../insns_func/vsadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsadd_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADD_VI);
+  #include "../insns_func/vsadd_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vsadd_vv.c
new file mode 100644
index 000000000000..fa754a1c0090
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADD_VV);
+  #include "../insns_func/vsadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADD_VV);
+  #include "../insns_func/vsadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vsadd_vx.c
new file mode 100644
index 000000000000..5f64d4e599b0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADD_VX);
+  #include "../insns_func/vsadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADD_VX);
+  #include "../insns_func/vsadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsaddu_vi.c b/arch/riscv/kernel/soft_vector/insns/vsaddu_vi.c
new file mode 100644
index 000000000000..10db7813001b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsaddu_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsaddu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADDU_VI);
+  #include "../insns_func/vsaddu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsaddu_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADDU_VI);
+  #include "../insns_func/vsaddu_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsaddu_vv.c b/arch/riscv/kernel/soft_vector/insns/vsaddu_vv.c
new file mode 100644
index 000000000000..a3400f69d816
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsaddu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsaddu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADDU_VV);
+  #include "../insns_func/vsaddu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsaddu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADDU_VV);
+  #include "../insns_func/vsaddu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsaddu_vx.c b/arch/riscv/kernel/soft_vector/insns/vsaddu_vx.c
new file mode 100644
index 000000000000..0b5eace61b12
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsaddu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsaddu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSADDU_VX);
+  #include "../insns_func/vsaddu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsaddu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSADDU_VX);
+  #include "../insns_func/vsaddu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsb_v.c b/arch/riscv/kernel/soft_vector/insns/vsb_v.c
new file mode 100644
index 000000000000..74d633726b82
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSB_V);
+  #include "../insns_func/vsb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSB_V);
+  #include "../insns_func/vsb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsbc_vvm.c b/arch/riscv/kernel/soft_vector/insns/vsbc_vvm.c
new file mode 100644
index 000000000000..cd64a5e539d0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsbc_vvm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsbc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSBC_VVM);
+  #include "../insns_func/vsbc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsbc_vvm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSBC_VVM);
+  #include "../insns_func/vsbc_vvm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsbc_vxm.c b/arch/riscv/kernel/soft_vector/insns/vsbc_vxm.c
new file mode 100644
index 000000000000..61754d1bc884
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsbc_vxm.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsbc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSBC_VXM);
+  #include "../insns_func/vsbc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsbc_vxm(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSBC_VXM);
+  #include "../insns_func/vsbc_vxm.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vse_v.c b/arch/riscv/kernel/soft_vector/insns/vse_v.c
new file mode 100644
index 000000000000..f1f7f91f8505
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vse_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSE_V);
+  #include "../insns_func/vse_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSE_V);
+  #include "../insns_func/vse_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsetvl.c b/arch/riscv/kernel/soft_vector/insns/vsetvl.c
new file mode 100644
index 000000000000..c3073779a999
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsetvl.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsetvl(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSETVL);
+  #include "../insns_func/vsetvl.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsetvl(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSETVL);
+  #include "../insns_func/vsetvl.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsetvli.c b/arch/riscv/kernel/soft_vector/insns/vsetvli.c
new file mode 100644
index 000000000000..f4f9d6da20f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsetvli.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsetvli(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSETVLI);
+  #include "../insns_func/vsetvli.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsetvli(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSETVLI);
+  #include "../insns_func/vsetvli.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsh_v.c b/arch/riscv/kernel/soft_vector/insns/vsh_v.c
new file mode 100644
index 000000000000..fb4b832fb937
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSH_V);
+  #include "../insns_func/vsh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSH_V);
+  #include "../insns_func/vsh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslide1down_vx.c b/arch/riscv/kernel/soft_vector/insns/vslide1down_vx.c
new file mode 100644
index 000000000000..a8a45488eca6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslide1down_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslide1down_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDE1DOWN_VX);
+  #include "../insns_func/vslide1down_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslide1down_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDE1DOWN_VX);
+  #include "../insns_func/vslide1down_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslide1up_vx.c b/arch/riscv/kernel/soft_vector/insns/vslide1up_vx.c
new file mode 100644
index 000000000000..066d5d0d4a80
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslide1up_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslide1up_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDE1UP_VX);
+  #include "../insns_func/vslide1up_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslide1up_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDE1UP_VX);
+  #include "../insns_func/vslide1up_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslidedown_vi.c b/arch/riscv/kernel/soft_vector/insns/vslidedown_vi.c
new file mode 100644
index 000000000000..0646d7deb69d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslidedown_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslidedown_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDEDOWN_VI);
+  #include "../insns_func/vslidedown_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslidedown_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDEDOWN_VI);
+  #include "../insns_func/vslidedown_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslidedown_vx.c b/arch/riscv/kernel/soft_vector/insns/vslidedown_vx.c
new file mode 100644
index 000000000000..d53609f599a7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslidedown_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslidedown_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDEDOWN_VX);
+  #include "../insns_func/vslidedown_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslidedown_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDEDOWN_VX);
+  #include "../insns_func/vslidedown_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslideup_vi.c b/arch/riscv/kernel/soft_vector/insns/vslideup_vi.c
new file mode 100644
index 000000000000..29b673e46fde
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslideup_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslideup_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDEUP_VI);
+  #include "../insns_func/vslideup_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslideup_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDEUP_VI);
+  #include "../insns_func/vslideup_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vslideup_vx.c b/arch/riscv/kernel/soft_vector/insns/vslideup_vx.c
new file mode 100644
index 000000000000..612afd688656
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vslideup_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vslideup_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLIDEUP_VX);
+  #include "../insns_func/vslideup_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vslideup_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLIDEUP_VX);
+  #include "../insns_func/vslideup_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsll_vi.c b/arch/riscv/kernel/soft_vector/insns/vsll_vi.c
new file mode 100644
index 000000000000..211e331dd072
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsll_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsll_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLL_VI);
+  #include "../insns_func/vsll_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsll_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLL_VI);
+  #include "../insns_func/vsll_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsll_vv.c b/arch/riscv/kernel/soft_vector/insns/vsll_vv.c
new file mode 100644
index 000000000000..3541c425cd3a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsll_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsll_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLL_VV);
+  #include "../insns_func/vsll_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsll_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLL_VV);
+  #include "../insns_func/vsll_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsll_vx.c b/arch/riscv/kernel/soft_vector/insns/vsll_vx.c
new file mode 100644
index 000000000000..3f4352099b20
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsll_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsll_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSLL_VX);
+  #include "../insns_func/vsll_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsll_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSLL_VX);
+  #include "../insns_func/vsll_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vsmul_vv.c
new file mode 100644
index 000000000000..13e91dab1f90
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSMUL_VV);
+  #include "../insns_func/vsmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSMUL_VV);
+  #include "../insns_func/vsmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsmul_vx.c b/arch/riscv/kernel/soft_vector/insns/vsmul_vx.c
new file mode 100644
index 000000000000..b119dfe9a10b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsmul_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSMUL_VX);
+  #include "../insns_func/vsmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSMUL_VX);
+  #include "../insns_func/vsmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsra_vi.c b/arch/riscv/kernel/soft_vector/insns/vsra_vi.c
new file mode 100644
index 000000000000..b01eb734b1dc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsra_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRA_VI);
+  #include "../insns_func/vsra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRA_VI);
+  #include "../insns_func/vsra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsra_vv.c b/arch/riscv/kernel/soft_vector/insns/vsra_vv.c
new file mode 100644
index 000000000000..c7ded9ee87f0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsra_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRA_VV);
+  #include "../insns_func/vsra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRA_VV);
+  #include "../insns_func/vsra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsra_vx.c b/arch/riscv/kernel/soft_vector/insns/vsra_vx.c
new file mode 100644
index 000000000000..508832ee72da
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsra_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRA_VX);
+  #include "../insns_func/vsra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRA_VX);
+  #include "../insns_func/vsra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsrl_vi.c b/arch/riscv/kernel/soft_vector/insns/vsrl_vi.c
new file mode 100644
index 000000000000..3542fa853db9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsrl_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRL_VI);
+  #include "../insns_func/vsrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRL_VI);
+  #include "../insns_func/vsrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsrl_vv.c b/arch/riscv/kernel/soft_vector/insns/vsrl_vv.c
new file mode 100644
index 000000000000..579aa19201c9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsrl_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRL_VV);
+  #include "../insns_func/vsrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRL_VV);
+  #include "../insns_func/vsrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsrl_vx.c b/arch/riscv/kernel/soft_vector/insns/vsrl_vx.c
new file mode 100644
index 000000000000..7d83b7884ea4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsrl_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSRL_VX);
+  #include "../insns_func/vsrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSRL_VX);
+  #include "../insns_func/vsrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssb_v.c b/arch/riscv/kernel/soft_vector/insns/vssb_v.c
new file mode 100644
index 000000000000..e91cad1e0fce
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSB_V);
+  #include "../insns_func/vssb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSB_V);
+  #include "../insns_func/vssb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsse_v.c b/arch/riscv/kernel/soft_vector/insns/vsse_v.c
new file mode 100644
index 000000000000..dcd4fb19fb9a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsse_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSE_V);
+  #include "../insns_func/vsse_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsse_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSE_V);
+  #include "../insns_func/vsse_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssh_v.c b/arch/riscv/kernel/soft_vector/insns/vssh_v.c
new file mode 100644
index 000000000000..abeb9fcb32cb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSH_V);
+  #include "../insns_func/vssh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSH_V);
+  #include "../insns_func/vssh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssra_vi.c b/arch/riscv/kernel/soft_vector/insns/vssra_vi.c
new file mode 100644
index 000000000000..5695e58e2869
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssra_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRA_VI);
+  #include "../insns_func/vssra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssra_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRA_VI);
+  #include "../insns_func/vssra_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssra_vv.c b/arch/riscv/kernel/soft_vector/insns/vssra_vv.c
new file mode 100644
index 000000000000..a190e65008b7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssra_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRA_VV);
+  #include "../insns_func/vssra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssra_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRA_VV);
+  #include "../insns_func/vssra_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssra_vx.c b/arch/riscv/kernel/soft_vector/insns/vssra_vx.c
new file mode 100644
index 000000000000..05fee81aaccc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssra_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRA_VX);
+  #include "../insns_func/vssra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssra_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRA_VX);
+  #include "../insns_func/vssra_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssrl_vi.c b/arch/riscv/kernel/soft_vector/insns/vssrl_vi.c
new file mode 100644
index 000000000000..1d47d00810f0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssrl_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRL_VI);
+  #include "../insns_func/vssrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssrl_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRL_VI);
+  #include "../insns_func/vssrl_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssrl_vv.c b/arch/riscv/kernel/soft_vector/insns/vssrl_vv.c
new file mode 100644
index 000000000000..6d4b6e2ea7b0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssrl_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRL_VV);
+  #include "../insns_func/vssrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssrl_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRL_VV);
+  #include "../insns_func/vssrl_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssrl_vx.c b/arch/riscv/kernel/soft_vector/insns/vssrl_vx.c
new file mode 100644
index 000000000000..c1cb906228b5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssrl_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSRL_VX);
+  #include "../insns_func/vssrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssrl_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSRL_VX);
+  #include "../insns_func/vssrl_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssub_vv.c b/arch/riscv/kernel/soft_vector/insns/vssub_vv.c
new file mode 100644
index 000000000000..eb15318ba217
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSUB_VV);
+  #include "../insns_func/vssub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSUB_VV);
+  #include "../insns_func/vssub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssub_vx.c b/arch/riscv/kernel/soft_vector/insns/vssub_vx.c
new file mode 100644
index 000000000000..3af83aac4780
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSUB_VX);
+  #include "../insns_func/vssub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSUB_VX);
+  #include "../insns_func/vssub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssubu_vv.c b/arch/riscv/kernel/soft_vector/insns/vssubu_vv.c
new file mode 100644
index 000000000000..28c20583e5c9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssubu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssubu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSUBU_VV);
+  #include "../insns_func/vssubu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssubu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSUBU_VV);
+  #include "../insns_func/vssubu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssubu_vx.c b/arch/riscv/kernel/soft_vector/insns/vssubu_vx.c
new file mode 100644
index 000000000000..5b0d3e071534
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssubu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssubu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSUBU_VX);
+  #include "../insns_func/vssubu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssubu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSUBU_VX);
+  #include "../insns_func/vssubu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vssw_v.c b/arch/riscv/kernel/soft_vector/insns/vssw_v.c
new file mode 100644
index 000000000000..90c3243ad3d9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vssw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vssw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSSW_V);
+  #include "../insns_func/vssw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vssw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSSW_V);
+  #include "../insns_func/vssw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vsub_vv.c
new file mode 100644
index 000000000000..9b290fde3059
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUB_VV);
+  #include "../insns_func/vsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUB_VV);
+  #include "../insns_func/vsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsub_vx.c b/arch/riscv/kernel/soft_vector/insns/vsub_vx.c
new file mode 100644
index 000000000000..5876fbf0874b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUB_VX);
+  #include "../insns_func/vsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUB_VX);
+  #include "../insns_func/vsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsuxb_v.c b/arch/riscv/kernel/soft_vector/insns/vsuxb_v.c
new file mode 100644
index 000000000000..77f32bd84d55
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsuxb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsuxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUXB_V);
+  #include "../insns_func/vsuxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsuxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUXB_V);
+  #include "../insns_func/vsuxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsuxe_v.c b/arch/riscv/kernel/soft_vector/insns/vsuxe_v.c
new file mode 100644
index 000000000000..134d7a17cf52
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsuxe_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsuxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUXE_V);
+  #include "../insns_func/vsuxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsuxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUXE_V);
+  #include "../insns_func/vsuxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsuxh_v.c b/arch/riscv/kernel/soft_vector/insns/vsuxh_v.c
new file mode 100644
index 000000000000..d6611986482d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsuxh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsuxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUXH_V);
+  #include "../insns_func/vsuxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsuxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUXH_V);
+  #include "../insns_func/vsuxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsuxw_v.c b/arch/riscv/kernel/soft_vector/insns/vsuxw_v.c
new file mode 100644
index 000000000000..e774c9fb0292
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsuxw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsuxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSUXW_V);
+  #include "../insns_func/vsuxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsuxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSUXW_V);
+  #include "../insns_func/vsuxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsw_v.c b/arch/riscv/kernel/soft_vector/insns/vsw_v.c
new file mode 100644
index 000000000000..bc8c83e6bddd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSW_V);
+  #include "../insns_func/vsw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSW_V);
+  #include "../insns_func/vsw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsxb_v.c b/arch/riscv/kernel/soft_vector/insns/vsxb_v.c
new file mode 100644
index 000000000000..0be0652ecd86
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsxb_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSXB_V);
+  #include "../insns_func/vsxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsxb_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSXB_V);
+  #include "../insns_func/vsxb_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsxe_v.c b/arch/riscv/kernel/soft_vector/insns/vsxe_v.c
new file mode 100644
index 000000000000..78359bf49a3c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsxe_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSXE_V);
+  #include "../insns_func/vsxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsxe_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSXE_V);
+  #include "../insns_func/vsxe_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsxh_v.c b/arch/riscv/kernel/soft_vector/insns/vsxh_v.c
new file mode 100644
index 000000000000..1fd137b79888
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsxh_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSXH_V);
+  #include "../insns_func/vsxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsxh_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSXH_V);
+  #include "../insns_func/vsxh_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vsxw_v.c b/arch/riscv/kernel/soft_vector/insns/vsxw_v.c
new file mode 100644
index 000000000000..110d99012207
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vsxw_v.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vsxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VSXW_V);
+  #include "../insns_func/vsxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vsxw_v(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VSXW_V);
+  #include "../insns_func/vsxw_v.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwadd_vv.c b/arch/riscv/kernel/soft_vector/insns/vwadd_vv.c
new file mode 100644
index 000000000000..8693958e0307
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwadd_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADD_VV);
+  #include "../insns_func/vwadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwadd_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADD_VV);
+  #include "../insns_func/vwadd_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwadd_vx.c b/arch/riscv/kernel/soft_vector/insns/vwadd_vx.c
new file mode 100644
index 000000000000..44eb79160a5a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwadd_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADD_VX);
+  #include "../insns_func/vwadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwadd_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADD_VX);
+  #include "../insns_func/vwadd_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwadd_wv.c b/arch/riscv/kernel/soft_vector/insns/vwadd_wv.c
new file mode 100644
index 000000000000..148f24bd9b48
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwadd_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwadd_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADD_WV);
+  #include "../insns_func/vwadd_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwadd_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADD_WV);
+  #include "../insns_func/vwadd_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwadd_wx.c b/arch/riscv/kernel/soft_vector/insns/vwadd_wx.c
new file mode 100644
index 000000000000..abe840fb0421
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwadd_wx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwadd_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADD_WX);
+  #include "../insns_func/vwadd_wx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwadd_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADD_WX);
+  #include "../insns_func/vwadd_wx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwaddu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwaddu_vv.c
new file mode 100644
index 000000000000..934147bbcd59
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwaddu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwaddu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADDU_VV);
+  #include "../insns_func/vwaddu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwaddu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADDU_VV);
+  #include "../insns_func/vwaddu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwaddu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwaddu_vx.c
new file mode 100644
index 000000000000..89cf4add0420
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwaddu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwaddu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADDU_VX);
+  #include "../insns_func/vwaddu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwaddu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADDU_VX);
+  #include "../insns_func/vwaddu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwaddu_wv.c b/arch/riscv/kernel/soft_vector/insns/vwaddu_wv.c
new file mode 100644
index 000000000000..a7aa3f049aa8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwaddu_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwaddu_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADDU_WV);
+  #include "../insns_func/vwaddu_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwaddu_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADDU_WV);
+  #include "../insns_func/vwaddu_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwaddu_wx.c b/arch/riscv/kernel/soft_vector/insns/vwaddu_wx.c
new file mode 100644
index 000000000000..a3b27e55e507
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwaddu_wx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwaddu_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWADDU_WX);
+  #include "../insns_func/vwaddu_wx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwaddu_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWADDU_WX);
+  #include "../insns_func/vwaddu_wx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmacc_vv.c
new file mode 100644
index 000000000000..1787b0b3515d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACC_VV);
+  #include "../insns_func/vwmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACC_VV);
+  #include "../insns_func/vwmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmacc_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmacc_vx.c
new file mode 100644
index 000000000000..7e1b1a219626
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmacc_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACC_VX);
+  #include "../insns_func/vwmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACC_VX);
+  #include "../insns_func/vwmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vv.c
new file mode 100644
index 000000000000..8ef59be97dca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCSU_VV);
+  #include "../insns_func/vwmaccsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCSU_VV);
+  #include "../insns_func/vwmaccsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vx.c
new file mode 100644
index 000000000000..4fe95db85a4a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccsu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCSU_VX);
+  #include "../insns_func/vwmaccsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCSU_VX);
+  #include "../insns_func/vwmaccsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmaccu_vv.c
new file mode 100644
index 000000000000..2384eae09181
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCU_VV);
+  #include "../insns_func/vwmaccu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCU_VV);
+  #include "../insns_func/vwmaccu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmaccu_vx.c
new file mode 100644
index 000000000000..7f62d36ab4de
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCU_VX);
+  #include "../insns_func/vwmaccu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCU_VX);
+  #include "../insns_func/vwmaccu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmaccus_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmaccus_vx.c
new file mode 100644
index 000000000000..3b586482c565
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmaccus_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmaccus_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMACCUS_VX);
+  #include "../insns_func/vwmaccus_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmaccus_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMACCUS_VX);
+  #include "../insns_func/vwmaccus_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmul_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmul_vv.c
new file mode 100644
index 000000000000..8e59408e0d47
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmul_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMUL_VV);
+  #include "../insns_func/vwmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmul_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMUL_VV);
+  #include "../insns_func/vwmul_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmul_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmul_vx.c
new file mode 100644
index 000000000000..38f9bd0f0f85
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmul_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMUL_VX);
+  #include "../insns_func/vwmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmul_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMUL_VX);
+  #include "../insns_func/vwmul_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmulsu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmulsu_vv.c
new file mode 100644
index 000000000000..eb6a05a73527
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmulsu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmulsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMULSU_VV);
+  #include "../insns_func/vwmulsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmulsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMULSU_VV);
+  #include "../insns_func/vwmulsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmulsu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmulsu_vx.c
new file mode 100644
index 000000000000..8a327e27a037
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmulsu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmulsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMULSU_VX);
+  #include "../insns_func/vwmulsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmulsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMULSU_VX);
+  #include "../insns_func/vwmulsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmulu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwmulu_vv.c
new file mode 100644
index 000000000000..4b5c933c1bee
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmulu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmulu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMULU_VV);
+  #include "../insns_func/vwmulu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmulu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMULU_VV);
+  #include "../insns_func/vwmulu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwmulu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwmulu_vx.c
new file mode 100644
index 000000000000..4fb56216553b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwmulu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwmulu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWMULU_VX);
+  #include "../insns_func/vwmulu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwmulu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWMULU_VX);
+  #include "../insns_func/vwmulu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwredsum_vs.c b/arch/riscv/kernel/soft_vector/insns/vwredsum_vs.c
new file mode 100644
index 000000000000..6706f6c55124
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwredsum_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWREDSUM_VS);
+  #include "../insns_func/vwredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwredsum_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWREDSUM_VS);
+  #include "../insns_func/vwredsum_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwredsumu_vs.c b/arch/riscv/kernel/soft_vector/insns/vwredsumu_vs.c
new file mode 100644
index 000000000000..6f2d87d3d235
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwredsumu_vs.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwredsumu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWREDSUMU_VS);
+  #include "../insns_func/vwredsumu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwredsumu_vs(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWREDSUMU_VS);
+  #include "../insns_func/vwredsumu_vs.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmacc_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsmacc_vv.c
new file mode 100644
index 000000000000..4df4c08b0cbd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmacc_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACC_VV);
+  #include "../insns_func/vwsmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmacc_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACC_VV);
+  #include "../insns_func/vwsmacc_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmacc_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsmacc_vx.c
new file mode 100644
index 000000000000..b8ab4771547e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmacc_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACC_VX);
+  #include "../insns_func/vwsmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmacc_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACC_VX);
+  #include "../insns_func/vwsmacc_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vv.c
new file mode 100644
index 000000000000..053a9b1f32c9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCSU_VV);
+  #include "../insns_func/vwsmaccsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccsu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCSU_VV);
+  #include "../insns_func/vwsmaccsu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vx.c
new file mode 100644
index 000000000000..89bba0be58ee
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccsu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCSU_VX);
+  #include "../insns_func/vwsmaccsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccsu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCSU_VX);
+  #include "../insns_func/vwsmaccsu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vv.c
new file mode 100644
index 000000000000..b68aaa29af6c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCU_VV);
+  #include "../insns_func/vwsmaccu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCU_VV);
+  #include "../insns_func/vwsmaccu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vx.c
new file mode 100644
index 000000000000..96620aafdc41
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCU_VX);
+  #include "../insns_func/vwsmaccu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCU_VX);
+  #include "../insns_func/vwsmaccu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsmaccus_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsmaccus_vx.c
new file mode 100644
index 000000000000..21ee05b5aa0c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsmaccus_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsmaccus_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSMACCUS_VX);
+  #include "../insns_func/vwsmaccus_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsmaccus_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSMACCUS_VX);
+  #include "../insns_func/vwsmaccus_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsub_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsub_vv.c
new file mode 100644
index 000000000000..dd07ae4e7442
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsub_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUB_VV);
+  #include "../insns_func/vwsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsub_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUB_VV);
+  #include "../insns_func/vwsub_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsub_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsub_vx.c
new file mode 100644
index 000000000000..427278b278ab
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsub_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUB_VX);
+  #include "../insns_func/vwsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsub_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUB_VX);
+  #include "../insns_func/vwsub_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsub_wv.c b/arch/riscv/kernel/soft_vector/insns/vwsub_wv.c
new file mode 100644
index 000000000000..d8c8e10fcfee
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsub_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsub_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUB_WV);
+  #include "../insns_func/vwsub_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsub_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUB_WV);
+  #include "../insns_func/vwsub_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsub_wx.c b/arch/riscv/kernel/soft_vector/insns/vwsub_wx.c
new file mode 100644
index 000000000000..8240cdbe8e5b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsub_wx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsub_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUB_WX);
+  #include "../insns_func/vwsub_wx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsub_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUB_WX);
+  #include "../insns_func/vwsub_wx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsubu_vv.c b/arch/riscv/kernel/soft_vector/insns/vwsubu_vv.c
new file mode 100644
index 000000000000..6e3b6142648f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsubu_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsubu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUBU_VV);
+  #include "../insns_func/vwsubu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsubu_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUBU_VV);
+  #include "../insns_func/vwsubu_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsubu_vx.c b/arch/riscv/kernel/soft_vector/insns/vwsubu_vx.c
new file mode 100644
index 000000000000..5216c41b03db
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsubu_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsubu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUBU_VX);
+  #include "../insns_func/vwsubu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsubu_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUBU_VX);
+  #include "../insns_func/vwsubu_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsubu_wv.c b/arch/riscv/kernel/soft_vector/insns/vwsubu_wv.c
new file mode 100644
index 000000000000..da2343972efb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsubu_wv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsubu_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUBU_WV);
+  #include "../insns_func/vwsubu_wv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsubu_wv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUBU_WV);
+  #include "../insns_func/vwsubu_wv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vwsubu_wx.c b/arch/riscv/kernel/soft_vector/insns/vwsubu_wx.c
new file mode 100644
index 000000000000..48657a7368d0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vwsubu_wx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vwsubu_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VWSUBU_WX);
+  #include "../insns_func/vwsubu_wx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vwsubu_wx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VWSUBU_WX);
+  #include "../insns_func/vwsubu_wx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vxor_vi.c b/arch/riscv/kernel/soft_vector/insns/vxor_vi.c
new file mode 100644
index 000000000000..371bdcb89469
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vxor_vi.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vxor_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VXOR_VI);
+  #include "../insns_func/vxor_vi.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vxor_vi(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VXOR_VI);
+  #include "../insns_func/vxor_vi.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vxor_vv.c b/arch/riscv/kernel/soft_vector/insns/vxor_vv.c
new file mode 100644
index 000000000000..170f68759897
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vxor_vv.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vxor_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VXOR_VV);
+  #include "../insns_func/vxor_vv.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vxor_vv(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VXOR_VV);
+  #include "../insns_func/vxor_vv.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns/vxor_vx.c b/arch/riscv/kernel/soft_vector/insns/vxor_vx.c
new file mode 100644
index 000000000000..ea54a83dc6f6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns/vxor_vx.c
@@ -0,0 +1,49 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#include "../insn_template.h"
+
+reg_t rv32_vxor_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 32;
+  reg_t npc = insn_length(MATCH_VXOR_VX);
+  #include "../insns_func/vxor_vx.h"
+  xlen = 0;
+  return npc;
+}
+
+reg_t rv64_vxor_vx(processor_t* p, insn_t insn)
+{
+  int xlen = 64;
+  reg_t npc = insn_length(MATCH_VXOR_VX);
+  #include "../insns_func/vxor_vx.h"
+  xlen = 0;
+  return npc;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vaadd_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vi.h
new file mode 100644
index 000000000000..e1823ffd96ae
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vi.h
@@ -0,0 +1,9 @@
+// vaadd: Averaging adds of integers
+VRM xrm = VECTOR->vxrm;
+VI_VI_LOOP
+({
+  int64_t result = simm5 + vs2;
+  INT_ROUNDING(result, xrm, 1);
+  result = vzext(result >> 1, sew);
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vaadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vv.h
new file mode 100644
index 000000000000..26c4011b5179
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vv.h
@@ -0,0 +1,2 @@
+// vaadd.vv *vd, vs2, vs1
+VI_VVX_LOOP_AVG(vs1, +);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vaadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vx.h
new file mode 100644
index 000000000000..f418b9736216
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vaadd_vx.h
@@ -0,0 +1,2 @@
+// vaadd.vx *vd, vs2, rs1
+VI_VVX_LOOP_AVG(rs1, +);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadc_vim.h b/arch/riscv/kernel/soft_vector/insns_func/vadc_vim.h
new file mode 100644
index 000000000000..b3db303f70fd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadc_vim.h
@@ -0,0 +1,11 @@
+// vadc.vim *vd, vs2, simm5
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VI_LOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & simm5) + (op_mask & vs2) + carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadc_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vadc_vvm.h
new file mode 100644
index 000000000000..d594dc9cc176
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadc_vvm.h
@@ -0,0 +1,11 @@
+// vadc.vvm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VV_LOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs1) + (op_mask & vs2) + carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadc_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vadc_vxm.h
new file mode 100644
index 000000000000..06d2048eeb5f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadc_vxm.h
@@ -0,0 +1,11 @@
+// vadc.vxm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VX_LOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & rs1) + (op_mask & vs2) + carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadd_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vadd_vi.h
new file mode 100644
index 000000000000..92cc91251152
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadd_vi.h
@@ -0,0 +1,5 @@
+// vadd.vi *vd, simm5, vs2, vm
+VI_VI_LOOP
+({
+  *vd =simm5 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vadd_vv.h
new file mode 100644
index 000000000000..a88ee781ab6a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadd_vv.h
@@ -0,0 +1,5 @@
+// vadd.vv *vd, vs1, vs2, vm
+VI_VV_LOOP
+({
+  *vd =vs1 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vadd_vx.h
new file mode 100644
index 000000000000..538d5d4719e7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vadd_vx.h
@@ -0,0 +1,5 @@
+// vadd.vx *vd, rs1, vs2, vm
+VI_VX_LOOP
+({
+  *vd =rs1 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoaddd_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoaddd_v.h
new file mode 100644
index 000000000000..53b0aa74fdf9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoaddd_v.h
@@ -0,0 +1,2 @@
+//vamoaddd.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs + vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoaddw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoaddw_v.h
new file mode 100644
index 000000000000..0a94a8670aa3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoaddw_v.h
@@ -0,0 +1,2 @@
+//vamoaddw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs + vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoandd_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoandd_v.h
new file mode 100644
index 000000000000..8834d131ace3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoandd_v.h
@@ -0,0 +1,2 @@
+//vamoandd.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs & vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoandw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoandw_v.h
new file mode 100644
index 000000000000..11162036adc7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoandw_v.h
@@ -0,0 +1,2 @@
+//vamoandw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs & vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomaxd_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomaxd_v.h
new file mode 100644
index 000000000000..ad6f5d7da4e6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomaxd_v.h
@@ -0,0 +1,2 @@
+//vamomaxd.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs >= vs3 ? lhs : vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomaxud_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomaxud_v.h
new file mode 100644
index 000000000000..8a46f3d00b3c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomaxud_v.h
@@ -0,0 +1,2 @@
+//vamomaxud.v vd, (rs1), vs2, vd
+VI_AMO({ val = (uint64_t)lhs >= (uint64_t)vs3 ? lhs : vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomaxuw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomaxuw_v.h
new file mode 100644
index 000000000000..18d63e40bafe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomaxuw_v.h
@@ -0,0 +1,2 @@
+//vamomaxuw.v vd, (rs1), vs2, vd
+VI_AMO({ val = (uint64_t)lhs >= (uint64_t)vs3 ? lhs : vs3;}, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomaxw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomaxw_v.h
new file mode 100644
index 000000000000..2b9a83af4b6c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomaxw_v.h
@@ -0,0 +1,2 @@
+//vamomaxw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs >= vs3 ? lhs : vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamomind_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamomind_v.h
new file mode 100644
index 000000000000..9bcdd867f4eb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamomind_v.h
@@ -0,0 +1,2 @@
+//vamomind.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs < vs3 ? lhs : vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamominud_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamominud_v.h
new file mode 100644
index 000000000000..848d68262947
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamominud_v.h
@@ -0,0 +1,2 @@
+//vamominue.v vd, (rs1), vs2, vd
+VI_AMO({ val = (uint64_t)lhs < (uint64_t)vs3 ? lhs : vs3;}, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamominuw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamominuw_v.h
new file mode 100644
index 000000000000..6818caed26c8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamominuw_v.h
@@ -0,0 +1,2 @@
+//vamominuw.v vd, (rs1), vs2, vd
+VI_AMO({ val = (uint64_t)lhs < (uint64_t)vs3 ? lhs : vs3;; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamominw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamominw_v.h
new file mode 100644
index 000000000000..f583790bc71e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamominw_v.h
@@ -0,0 +1,2 @@
+//vamomine.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs < vs3 ? lhs : vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoord_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoord_v.h
new file mode 100644
index 000000000000..fd15529e85f6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoord_v.h
@@ -0,0 +1,2 @@
+//vamoord.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs | vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoorw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoorw_v.h
new file mode 100644
index 000000000000..050c110a6844
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoorw_v.h
@@ -0,0 +1,2 @@
+//vamoorw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs | vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoswapd_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoswapd_v.h
new file mode 100644
index 000000000000..1ef371b6bf61
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoswapd_v.h
@@ -0,0 +1,2 @@
+//vamoswapd.v vd, (rs1), vs2, vd
+VI_AMO({ val = vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoswapw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoswapw_v.h
new file mode 100644
index 000000000000..ede53890b264
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoswapw_v.h
@@ -0,0 +1,2 @@
+//vamoswapw.v vd, (rs1), vs2, vd
+VI_AMO({ val = vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoxord_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoxord_v.h
new file mode 100644
index 000000000000..fdf5f7a518bc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoxord_v.h
@@ -0,0 +1,2 @@
+//vamoord.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs ^ vs3; }, 64);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vamoxorw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vamoxorw_v.h
new file mode 100644
index 000000000000..48a302a849e6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vamoxorw_v.h
@@ -0,0 +1,2 @@
+//vamoxorw.v vd, (rs1), vs2, vd
+VI_AMO({ val = lhs ^ vs3; }, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vand_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vand_vi.h
new file mode 100644
index 000000000000..f3a8ef1c31e4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vand_vi.h
@@ -0,0 +1,5 @@
+// vand.vi *vd, simm5, vs2, vm
+VI_VI_LOOP
+({
+  *vd =simm5 & vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vand_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vand_vv.h
new file mode 100644
index 000000000000..e026eab9fa7c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vand_vv.h
@@ -0,0 +1,5 @@
+// vand.vv *vd, vs1, vs2, vm
+VI_VV_LOOP
+({
+  *vd =vs1 & vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vand_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vand_vx.h
new file mode 100644
index 000000000000..294d6a14b9ca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vand_vx.h
@@ -0,0 +1,5 @@
+// vand.vx *vd, rs1, vs2, vm
+VI_VX_LOOP
+({
+  *vd =rs1 & vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vasub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vasub_vv.h
new file mode 100644
index 000000000000..97c0b4d1a475
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vasub_vv.h
@@ -0,0 +1,2 @@
+// vasub.vv *vd, vs2, vs1
+VI_VVX_LOOP_AVG(vs1, -);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vasub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vasub_vx.h
new file mode 100644
index 000000000000..f1597ee43230
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vasub_vx.h
@@ -0,0 +1,2 @@
+// vasub.vx *vd, vs2, rs1
+VI_VVX_LOOP_AVG(rs1, -);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vcompress_vm.h b/arch/riscv/kernel/soft_vector/insns_func/vcompress_vm.h
new file mode 100644
index 000000000000..1b85ab5e098c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vcompress_vm.h
@@ -0,0 +1,44 @@
+// vcompress *vd, vs2, vs1
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+require(VECTOR->vstart == 0);
+{
+reg_t sew = VECTOR->vsew;
+reg_t vl = VECTOR->vl;
+reg_t rd_num = rd(insn);
+reg_t rs1_num = insn_rs1(insn);
+reg_t rs2_num = rs2(insn);
+reg_t pos = 0;
+reg_t i;
+for (i = VECTOR->vstart ; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, rs1_num, midx) >> mpos) & 0x1;
+  if (do_mask) {
+    switch (sew) {
+    case e8:
+      *vector_elt_uint8_t(VECTOR, rd_num, pos) = *vector_elt_uint8_t(VECTOR, rs2_num, i);
+      break;
+    case e16:
+      *vector_elt_uint16_t(VECTOR, rd_num, pos) = *vector_elt_uint16_t(VECTOR, rs2_num, i);
+      break;
+    case e32:
+      *vector_elt_uint32_t(VECTOR, rd_num, pos) = *vector_elt_uint32_t(VECTOR, rs2_num, i);
+      break;
+    default:
+      *vector_elt_uint64_t(VECTOR, rd_num, pos) = *vector_elt_uint64_t(VECTOR, rs2_num, i);
+      break;
+    }
+
+    ++pos;
+  }
+}
+
+if (vl > 0 && TAIL_ZEROING) {
+  uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, pos * ((sew >> 3) * 1));
+  memset(tail, 0, (VECTOR->vlmax - pos) * ((sew >> 3) * 1));
+}
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdiv_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vdiv_vv.h
new file mode 100644
index 000000000000..ee8eab44fc01
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdiv_vv.h
@@ -0,0 +1,10 @@
+// *vdiv.vv *vd, vs2, vs1
+VI_VV_LOOP
+({
+  if (vs1 == 0)
+    *vd =-1;
+  else if (vs2 == -(1 << (sew - 1)) && vs1 == -1)
+    *vd =vs2;
+  else
+    *vd =vs2 / vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdiv_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vdiv_vx.h
new file mode 100644
index 000000000000..338b5e720f35
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdiv_vx.h
@@ -0,0 +1,10 @@
+// *vdiv.vx *vd, vs2, rs1
+VI_VX_LOOP
+({
+  if(rs1 == 0)
+    *vd =-1;
+  else if(vs2 == -(1 << (sew - 1)) && rs1 == -1)
+    *vd =vs2;
+  else
+    *vd =vs2 / rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdivu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vdivu_vv.h
new file mode 100644
index 000000000000..ad0e4dac8387
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdivu_vv.h
@@ -0,0 +1,8 @@
+// *vdivu.vv *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  if(vs1 == 0)
+    *vd =-1;
+  else
+    *vd =vs2 / vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdivu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vdivu_vx.h
new file mode 100644
index 000000000000..16f4c9d416f7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdivu_vx.h
@@ -0,0 +1,8 @@
+// *vdivu.vx *vd, vs2, rs1
+VI_VX_ULOOP
+({
+  if(rs1 == 0)
+    *vd =-1;
+  else
+    *vd =vs2 / rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdot_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vdot_vv.h
new file mode 100644
index 000000000000..3af6b17792be
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdot_vv.h
@@ -0,0 +1,5 @@
+// *vdot *vd, vs2, vs1
+VI_VV_LOOP
+({
+  *vd += vs2 * vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vdotu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vdotu_vv.h
new file mode 100644
index 000000000000..b02d8d9e812f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vdotu_vv.h
@@ -0,0 +1,5 @@
+// *vdotu *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  *vd += vs2 * vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vext_x_v.h b/arch/riscv/kernel/soft_vector/insns_func/vext_x_v.h
new file mode 100644
index 000000000000..5f7d61958d6d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vext_x_v.h
@@ -0,0 +1,32 @@
+// vext_x_v: rd = vs2[rs1]
+require(v_vm(insn) == 1);
+{
+uint64_t xmask = UINT64_MAX >> (64 - get_max_xlen());
+reg_t rs1 = RS1;
+VI_LOOP_BASE
+VI_LOOP_END_NO_TAIL_ZERO
+if (!(rs1 >= 0 && rs1 < (VECTOR->VLEN/sew))) {
+  WRITE_RD(0);
+} else {
+  switch(sew) {
+  case e8:
+    WRITE_RD(*vector_elt_uint8_t(VECTOR, rs2_num, rs1));
+    break;
+  case e16:
+    WRITE_RD(*vector_elt_uint16_t(VECTOR, rs2_num, rs1));
+    break;
+  case e32:
+    if (get_max_xlen() == 32)
+      WRITE_RD(*vector_elt_int32_t(VECTOR, rs2_num, rs1));
+    else
+      WRITE_RD(*vector_elt_uint32_t(VECTOR, rs2_num, rs1));
+    break;
+  case e64:
+    if (get_max_xlen() <= sew)
+      WRITE_RD(*vector_elt_uint64_t(VECTOR, rs2_num, rs1) & xmask);
+    else
+      WRITE_RD(*vector_elt_uint64_t(VECTOR, rs2_num, rs1));
+    break;
+  }
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfadd_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfadd_vf.h
new file mode 100644
index 000000000000..345b33575a36
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfadd_vf.h
@@ -0,0 +1,8 @@
+// vfadd.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+    *vd =f32_add(rs1, vs2);
+},
+{
+    *vd =f64_add(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfadd_vv.h
new file mode 100644
index 000000000000..f5cd57f12f52
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfadd_vv.h
@@ -0,0 +1,8 @@
+// vfadd.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_add(vs1, vs2);
+},
+{
+  *vd =f64_add(vs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfclass_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfclass_v.h
new file mode 100644
index 000000000000..fc1153eea016
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfclass_v.h
@@ -0,0 +1,8 @@
+// vfclass.v *vd, vs2, vm
+VI_VFP_VV_LOOP
+({
+  vd->v = f32_classify(vs2);
+},
+{
+  vd->v = f64_classify(vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_x_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_x_v.h
new file mode 100644
index 000000000000..ead30589b7ba
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_x_v.h
@@ -0,0 +1,10 @@
+// vfcvt.f.x.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  int32_t vs2_i = *vector_elt_int32_t(VECTOR, rs2_num, i);
+  *vd =i32_to_f32(vs2_i);
+},
+{
+  int64_t vs2_i = *vector_elt_int64_t(VECTOR, rs2_num, i);
+  *vd =i64_to_f64(vs2_i);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_xu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_xu_v.h
new file mode 100644
index 000000000000..36d6a235463b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_f_xu_v.h
@@ -0,0 +1,10 @@
+// vfcvt.f.xu.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  uint32_t vs2_u = *vector_elt_uint32_t(VECTOR, rs2_num, i);
+  *vd =ui32_to_f32(vs2_u);
+},
+{
+  uint64_t vs2_u = *vector_elt_uint64_t(VECTOR, rs2_num, i);
+  *vd =ui64_to_f64(vs2_u);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfcvt_x_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_x_f_v.h
new file mode 100644
index 000000000000..6f481e5bb9de
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_x_f_v.h
@@ -0,0 +1,7 @@
+// vfcvt.x.f.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  *vector_elt_int32_t(VECTOR, rd_num, i) = f32_to_i32(vs2, STATE.frm, true);
+},{
+  *vector_elt_int64_t(VECTOR, rd_num, i) = f64_to_i64(vs2, STATE.frm, true);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfcvt_xu_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_xu_f_v.h
new file mode 100644
index 000000000000..938ddd555e6c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfcvt_xu_f_v.h
@@ -0,0 +1,8 @@
+// vfcvt.xu.f.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  *vector_elt_uint32_t(VECTOR, rd_num, i) = f32_to_ui32(vs2, STATE.frm, true);
+},
+{
+  *vector_elt_uint64_t(VECTOR, rd_num, i) = f64_to_ui64(vs2, STATE.frm, true);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vf.h
new file mode 100644
index 000000000000..8666d5f6a809
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vf.h
@@ -0,0 +1,8 @@
+// vfdiv.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+  *vd =f32_div(vs2, rs1);
+},
+{
+  *vd =f64_div(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vv.h
new file mode 100644
index 000000000000..9da9a00daeaa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfdiv_vv.h
@@ -0,0 +1,8 @@
+// vfdiv.vv  *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_div(vs2, vs1);
+},
+{
+  *vd =f64_div(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfdot_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfdot_vv.h
new file mode 100644
index 000000000000..7736994d486e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfdot_vv.h
@@ -0,0 +1,8 @@
+// vfdot.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_add(*vd, f32_mul(vs2, vs1));
+},
+{
+  *vd =f64_add(*vd, f64_mul(vs2, vs1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vf.h
new file mode 100644
index 000000000000..86790ab6f040
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vf.h
@@ -0,0 +1,8 @@
+// vfmacc.vf *vd, rs1, vs2, vm    # *vd[i] = +(vs2[i] * x[rs1]) + *vd[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(rs1, vs2, *vd);
+},
+{
+  *vd =f64_mulAdd(rs1, vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vv.h
new file mode 100644
index 000000000000..e2c38451a412
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmacc_vv.h
@@ -0,0 +1,8 @@
+// vfmacc.vv *vd, rs1, vs2, vm    # *vd[i] = +(vs2[i] * vs1[i]) + *vd[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(vs1, vs2, *vd);
+},
+{
+  *vd =f64_mulAdd(vs1, vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vf.h
new file mode 100644
index 000000000000..8109d0fac400
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vf.h
@@ -0,0 +1,8 @@
+// vfmadd: *vd[i] = +(*vd[i] * f[rs1]) + vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(*vd, rs1, vs2);
+},
+{
+  *vd =f64_mulAdd(*vd, rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vv.h
new file mode 100644
index 000000000000..0a17bbe29311
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmadd_vv.h
@@ -0,0 +1,8 @@
+// vfmadd: *vd[i] = +(*vd[i] * vs1[i]) + vs2[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(*vd, vs1, vs2);
+},
+{
+  *vd =f64_mulAdd(*vd, vs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmax_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmax_vf.h
new file mode 100644
index 000000000000..71f851c95a45
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmax_vf.h
@@ -0,0 +1,8 @@
+// vfmax
+VI_VFP_VF_LOOP
+({
+  *vd =f32_max(vs2, rs1);
+},
+{
+  *vd =f64_max(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmax_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmax_vv.h
new file mode 100644
index 000000000000..4d63da38e1e0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmax_vv.h
@@ -0,0 +1,8 @@
+// vfmax
+VI_VFP_VV_LOOP
+({
+  *vd =f32_max(vs2, vs1);
+},
+{
+  *vd =f64_max(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmerge_vfm.h b/arch/riscv/kernel/soft_vector/insns_func/vfmerge_vfm.h
new file mode 100644
index 000000000000..e104fdfd3eab
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmerge_vfm.h
@@ -0,0 +1,21 @@
+// vfmerge_vf *vd, vs2, vs1, vm
+VI_VFP_COMMON;
+{
+reg_t sew = VECTOR->vsew;
+reg_t i;
+for (i=VECTOR->vstart; i<vl; ++i) {
+  float64_t *vd =vector_elt_float64_t(VECTOR, rd_num, i);
+  float64_t rs1 = f64_f(READ_FREG(rs1_num));
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i);
+
+  int midx = (VECTOR->vmlen * i) / 64;
+  int mpos = (VECTOR->vmlen * i) % 64;
+  bool use_first = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  *vd =use_first ? rs1 : vs2;
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
+set_fp_exceptions;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmin_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmin_vf.h
new file mode 100644
index 000000000000..2682e5c86c32
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmin_vf.h
@@ -0,0 +1,8 @@
+// vfmin *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+  *vd =f32_min(vs2, rs1);
+},
+{
+  *vd =f64_min(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmin_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmin_vv.h
new file mode 100644
index 000000000000..57e75fa22124
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmin_vv.h
@@ -0,0 +1,8 @@
+// vfmin *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_min(vs2, vs1);
+},
+{
+  *vd =f64_min(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vf.h
new file mode 100644
index 000000000000..9f40071f8314
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vf.h
@@ -0,0 +1,8 @@
+// vfmsac: *vd[i] = +(f[rs1] * vs2[i]) - *vd[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(rs1, vs2, f32(vd->v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(rs1, vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vv.h
new file mode 100644
index 000000000000..e6af0f47e101
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmsac_vv.h
@@ -0,0 +1,8 @@
+// vfmsac: *vd[i] = +(vs1[i] * vs2[i]) - *vd[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(vs1, vs2, f32(vd->v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(vs1, vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vf.h
new file mode 100644
index 000000000000..be64d9a4cb02
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vf.h
@@ -0,0 +1,8 @@
+// vfmsub: *vd[i] = +(*vd[i] * f[rs1]) - vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(*vd, rs1, f32(vs2.v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(*vd, rs1, f64(vs2.v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vv.h
new file mode 100644
index 000000000000..4d454df20a0d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmsub_vv.h
@@ -0,0 +1,8 @@
+// vfmsub: *vd[i] = +(*vd[i] * vs1[i]) - vs2[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(*vd, vs1, f32(vs2.v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(*vd, vs1, f64(vs2.v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmul_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfmul_vf.h
new file mode 100644
index 000000000000..bea3c046d843
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmul_vf.h
@@ -0,0 +1,8 @@
+// vfmul.vf *vd, vs2, rs1, vm
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mul(vs2, rs1);
+},
+{
+  *vd =f64_mul(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfmul_vv.h
new file mode 100644
index 000000000000..94e81e190baf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmul_vv.h
@@ -0,0 +1,8 @@
+// vfmul.vv *vd, vs1, vs2, vm
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mul(vs1, vs2);
+},
+{
+  *vd =f64_mul(vs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmv_f_s.h b/arch/riscv/kernel/soft_vector/insns_func/vfmv_f_s.h
new file mode 100644
index 000000000000..bf75fa977257
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmv_f_s.h
@@ -0,0 +1,35 @@
+// vfmv_f_s: rd = vs2[0] (rs1=0)
+require(v_vm(insn) == 1);
+require_fp;
+require(VECTOR->vsew == e8 || VECTOR->vsew == e16 || VECTOR->vsew == e32 || VECTOR->vsew == e64);
+
+{
+reg_t rs2_num = rs2(insn);
+uint64_t vs2_0 = 0;
+const reg_t sew = VECTOR->vsew;
+switch(sew) {
+case e8:
+  vs2_0 = *vector_elt_uint8_t(VECTOR, rs2_num, 0);
+  break;
+case e16:
+  vs2_0 = *vector_elt_uint16_t(VECTOR, rs2_num, 0);
+  break;
+case e32:
+  vs2_0 = *vector_elt_uint32_t(VECTOR, rs2_num, 0);
+  break;
+default:
+  vs2_0 = *vector_elt_uint64_t(VECTOR, rs2_num, 0);
+  break;
+}
+
+// nan_extened
+if (FLEN > sew) {
+  vs2_0 = vs2_0 | ~((1ul << sew) - 1);
+}
+
+if (FLEN == 64) {
+  WRITE_FRD(f64(vs2_0), 64);
+} else {
+  WRITE_FRD(f32(vs2_0), 32);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmv_s_f.h b/arch/riscv/kernel/soft_vector/insns_func/vfmv_s_f.h
new file mode 100644
index 000000000000..c9c1152e1206
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmv_s_f.h
@@ -0,0 +1,29 @@
+// vfmv_s_f: *vd[0] = rs1 (vs2=0)
+reg_t vl = VECTOR->vl;
+require(v_vm(insn) == 1);
+require_fp;
+
+if (vl > 0) {
+  reg_t i;
+  reg_t rd_num = rd(insn);
+  reg_t sew = VECTOR->vsew;
+
+  if (FLEN == 64)
+    *vector_elt_uint64_t(VECTOR, rd_num, 0) = f64_f(FRS1).v;
+  else
+    *vector_elt_uint64_t(VECTOR, rd_num, 0) = f32_f(FRS1).v;
+  {
+  const reg_t max_len = VECTOR->VLEN / sew;
+  for (i = 1; i < max_len; ++i) {
+    switch(sew) {
+    case e64:
+      *vector_elt_uint64_t(VECTOR, rd_num, i) = 0;
+      break;
+    default:
+      require(false);
+      break;
+    }
+  }
+  }
+  vl = 0;
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfmv_v_f.h b/arch/riscv/kernel/soft_vector/insns_func/vfmv_v_f.h
new file mode 100644
index 000000000000..1d824d767482
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfmv_v_f.h
@@ -0,0 +1,16 @@
+// vfmerge_vf *vd, vs2, vs1, vm
+VI_VFP_COMMON;
+{
+reg_t sew = VECTOR->vsew;
+reg_t i;
+for (i=VECTOR->vstart; i<vl; ++i) {
+  float64_t *vd =vector_elt_float64_t(VECTOR, rd_num, i);
+  float64_t rs1 = f64_f(READ_FREG(rs1_num));
+
+  *vd =rs1;
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
+set_fp_exceptions;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_f_v.h
new file mode 100644
index 000000000000..9d2065cede91
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_f_v.h
@@ -0,0 +1,8 @@
+// vfncvt.f.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+  {
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i);
+  *vector_elt_float32_t(VECTOR, rd_num, i) = f64_to_f32(vs2);
+  }
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_x_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_x_v.h
new file mode 100644
index 000000000000..25679d3d8609
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_x_v.h
@@ -0,0 +1,8 @@
+// vfncvt.f.x.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+{
+  int64_t vs2 = *vector_elt_int64_t(VECTOR, rs2_num, i);
+  *vector_elt_float32_t(VECTOR, rd_num, i) = i64_to_f32(vs2);
+}
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_xu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_xu_v.h
new file mode 100644
index 000000000000..8b44de85597d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_f_xu_v.h
@@ -0,0 +1,8 @@
+// vfncvt.f.xu.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+{
+  uint64_t vs2 = *vector_elt_uint64_t(VECTOR, rs2_num, i);
+  *vector_elt_float32_t(VECTOR, rd_num, i) = ui64_to_f32(vs2);
+}
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_x_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_x_f_v.h
new file mode 100644
index 000000000000..e08c7b0a9123
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_x_f_v.h
@@ -0,0 +1,8 @@
+// vfncvt.x.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+{
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i);
+  *vector_elt_int32_t(VECTOR, rd_num, i) = f64_to_i32(vs2, STATE.frm, true);
+}
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfncvt_xu_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_xu_f_v.h
new file mode 100644
index 000000000000..88c9f35f22ca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfncvt_xu_f_v.h
@@ -0,0 +1,8 @@
+// vfncvt.xu.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_SD;
+{
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i);
+  *vector_elt_uint32_t(VECTOR, rd_num, i) = f64_to_ui32(vs2, STATE.frm, true);
+}
+VI_VFP_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vf.h
new file mode 100644
index 000000000000..97082b71f000
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vf.h
@@ -0,0 +1,8 @@
+// vfnmacc: *vd[i] = -(f[rs1] * vs2[i]) - *vd[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(rs1, f32(vs2.v ^ F32_SIGN), f32(vd->v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(rs1, f64(vs2.v ^ F64_SIGN), f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vv.h
new file mode 100644
index 000000000000..2749b66db09e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmacc_vv.h
@@ -0,0 +1,8 @@
+// vfnmacc: *vd[i] = -(vs1[i] * vs2[i]) - *vd[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(f32(vs2.v ^ F32_SIGN), vs1, f32(vd->v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(f64(vs2.v ^ F64_SIGN), vs1, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vf.h
new file mode 100644
index 000000000000..e9a88e8c9403
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vf.h
@@ -0,0 +1,8 @@
+// vfnmadd: *vd[i] = -(*vd[i] * f[rs1]) - vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(f32(vd->v ^ F32_SIGN), rs1, f32(vs2.v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(f64(vd->v ^ F64_SIGN), rs1, f64(vs2.v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vv.h
new file mode 100644
index 000000000000..40e0632f2806
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmadd_vv.h
@@ -0,0 +1,8 @@
+// vfnmadd: *vd[i] = -(*vd[i] * vs1[i]) - vs2[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(f32(vd->v ^ F32_SIGN), vs1, f32(vs2.v ^ F32_SIGN));
+},
+{
+  *vd =f64_mulAdd(f64(vd->v ^ F64_SIGN), vs1, f64(vs2.v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vf.h
new file mode 100644
index 000000000000..cfd7fd159e91
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vf.h
@@ -0,0 +1,8 @@
+// vfnmsac: *vd[i] = -(f[rs1] * vs2[i]) + *vd[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(rs1, f32(vs2.v ^ F32_SIGN), *vd);
+},
+{
+  *vd =f64_mulAdd(rs1, f64(vs2.v ^ F64_SIGN), *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vv.h
new file mode 100644
index 000000000000..b1c457ba06b7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmsac_vv.h
@@ -0,0 +1,8 @@
+// vfnmsac.vv *vd, vs1, vs2, vm   # *vd[i] = -(vs2[i] * vs1[i]) + *vd[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(f32(vs1.v ^ F32_SIGN), vs2, *vd);
+},
+{
+  *vd =f64_mulAdd(f64(vs1.v ^ F64_SIGN), vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vf.h
new file mode 100644
index 000000000000..e641890391ca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vf.h
@@ -0,0 +1,8 @@
+// vfnmsub: *vd[i] = -(*vd[i] * f[rs1]) + vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_mulAdd(f32(vd->v ^ F32_SIGN), rs1, vs2);
+},
+{
+  *vd =f64_mulAdd(f64(vd->v ^ F64_SIGN), rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vv.h
new file mode 100644
index 000000000000..6bab3f417c38
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfnmsub_vv.h
@@ -0,0 +1,8 @@
+// vfnmsub: *vd[i] = -(*vd[i] * vs1[i]) + vs2[i]
+VI_VFP_VV_LOOP
+({
+  *vd =f32_mulAdd(f32(vd->v ^ F32_SIGN), vs1, vs2);
+},
+{
+  *vd =f64_mulAdd(f64(vd->v ^ F64_SIGN), vs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfrdiv_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfrdiv_vf.h
new file mode 100644
index 000000000000..c6296d550def
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfrdiv_vf.h
@@ -0,0 +1,8 @@
+// vfrdiv.vf *vd, vs2, rs1, vm  # scalar-vector, *vd[i] = f[rs1]/vs2[i]
+VI_VFP_VF_LOOP
+({
+  *vd =f32_div(rs1, vs2);
+},
+{
+  *vd =f64_div(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfredmax_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfredmax_vs.h
new file mode 100644
index 000000000000..7aeb773e23f5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfredmax_vs.h
@@ -0,0 +1,5 @@
+// vfredmax *vd, vs2, vs1
+VI_VFP_VV_LOOP_REDUCTION
+({
+  vd_0 = f64_max(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfredmin_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfredmin_vs.h
new file mode 100644
index 000000000000..5eecefe1e8e2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfredmin_vs.h
@@ -0,0 +1,5 @@
+// vfredmin *vd, vs2, vs1
+VI_VFP_VV_LOOP_REDUCTION
+({
+  vd_0 = f64_min(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfredosum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfredosum_vs.h
new file mode 100644
index 000000000000..6eeb7b5e2ea7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfredosum_vs.h
@@ -0,0 +1,5 @@
+// vfredosum: *vd[0] =  sum( vs2[*] , vs1[0] )
+VI_VFP_VV_LOOP_REDUCTION
+({
+  vd_0 = f64_add(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfredsum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfredsum_vs.h
new file mode 100644
index 000000000000..189b4d211ef1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfredsum_vs.h
@@ -0,0 +1,5 @@
+// vfredsum: *vd[0] =  sum( vs2[*] , vs1[0] )
+VI_VFP_VV_LOOP_REDUCTION
+({
+  vd_0 = f64_add(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfrsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfrsub_vf.h
new file mode 100644
index 000000000000..03d25bd41147
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfrsub_vf.h
@@ -0,0 +1,8 @@
+// vfsub.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+  *vd =f32_sub(rs1, vs2);
+},
+{
+  *vd =f64_sub(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vf.h
new file mode 100644
index 000000000000..5bb49ecf25d5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vf.h
@@ -0,0 +1,8 @@
+// vfsgnj *vd, vs2, vs1
+VI_VFP_VF_LOOP
+({
+  *vd =fsgnj32(vs2.v, rs1.v, false, false);
+},
+{
+  *vd =fsgnj64(vs2.v, rs1.v, false, false);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vv.h
new file mode 100644
index 000000000000..8a6565d3045c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnj_vv.h
@@ -0,0 +1,8 @@
+// vfsgnj
+VI_VFP_VV_LOOP
+({
+  *vd =fsgnj32(vs2.v, vs1.v, false, false);
+},
+{
+  *vd =fsgnj64(vs2.v, vs1.v, false, false);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vf.h
new file mode 100644
index 000000000000..9843748cbd3a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vf.h
@@ -0,0 +1,8 @@
+// vfsgnn
+VI_VFP_VF_LOOP
+({
+  *vd =fsgnj32(vs2.v, rs1.v, true, false);
+},
+{
+  *vd =fsgnj64(vs2.v, rs1.v, true, false);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vv.h
new file mode 100644
index 000000000000..4b2189087c52
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjn_vv.h
@@ -0,0 +1,8 @@
+// vfsgnn
+VI_VFP_VV_LOOP
+({
+  *vd =fsgnj32(vs2.v, vs1.v, true, false);
+},
+{
+  *vd =fsgnj64(vs2.v, vs1.v, true, false);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vf.h
new file mode 100644
index 000000000000..ad5466bf157d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vf.h
@@ -0,0 +1,8 @@
+// vfsgnx
+VI_VFP_VF_LOOP
+({
+  *vd =fsgnj32(vs2.v, rs1.v, false, true);
+},
+{
+  *vd =fsgnj64(vs2.v, rs1.v, false, true);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vv.h
new file mode 100644
index 000000000000..409cbef9f591
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsgnjx_vv.h
@@ -0,0 +1,8 @@
+// vfsgnx
+VI_VFP_VV_LOOP
+({
+  *vd =fsgnj32(vs2.v, vs1.v, false, true);
+},
+{
+  *vd =fsgnj64(vs2.v, vs1.v, false, true);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsqrt_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfsqrt_v.h
new file mode 100644
index 000000000000..8b50cc079d54
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsqrt_v.h
@@ -0,0 +1,8 @@
+// vsqrt.v *vd, *vd2, vm
+VI_VFP_VV_LOOP
+({
+  *vd =f32_sqrt(vs2);
+},
+{
+  *vd =f64_sqrt(vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfsub_vf.h
new file mode 100644
index 000000000000..be191ef61655
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsub_vf.h
@@ -0,0 +1,8 @@
+// vfsub.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP
+({
+  *vd =f32_sub(vs2, rs1);
+},
+{
+  *vd =f64_sub(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfsub_vv.h
new file mode 100644
index 000000000000..9bae3349b531
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfsub_vv.h
@@ -0,0 +1,8 @@
+// vfsub.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP
+({
+  *vd =f32_sub(vs2, vs1);
+},
+{
+  *vd =f64_sub(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vf.h
new file mode 100644
index 000000000000..56ee79598697
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vf.h
@@ -0,0 +1,5 @@
+// vfwadd.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_add(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vv.h
new file mode 100644
index 000000000000..11c5612cc3e1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_vv.h
@@ -0,0 +1,5 @@
+// vfwadd.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_add(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wf.h
new file mode 100644
index 000000000000..2cad4c1a1756
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wf.h
@@ -0,0 +1,5 @@
+// vfwadd.wf *vd, vs2, vs1
+VI_VFP_WF_LOOP_WIDE
+({
+  *vd =f64_add(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wv.h
new file mode 100644
index 000000000000..a7761584059c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwadd_wv.h
@@ -0,0 +1,5 @@
+// vfwadd.wv *vd, vs2, vs1
+VI_VFP_WV_LOOP_WIDE
+({
+  *vd =f64_add(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_f_v.h
new file mode 100644
index 000000000000..c7f22aef5638
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_f_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.f.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  float32_t vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i);
+  *vector_elt_float64_t(VECTOR, rd_num, i) = f32_to_f64(vs2);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_x_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_x_v.h
new file mode 100644
index 000000000000..b4cfabc73583
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_x_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.f.x.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  int32_t vs2 = *vector_elt_int32_t(VECTOR, rs2_num, i);
+  *vector_elt_float64_t(VECTOR, rd_num, i) = i32_to_f64(vs2);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_xu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_xu_v.h
new file mode 100644
index 000000000000..a1dbf1ff5d57
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_f_xu_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.f.xu.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  uint32_t vs2 = *vector_elt_uint32_t(VECTOR, rs2_num, i);
+  *vector_elt_float64_t(VECTOR, rd_num, i) = ui32_to_f64(vs2);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_x_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_x_f_v.h
new file mode 100644
index 000000000000..81dafb583487
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_x_f_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.x.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  float32_t vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i);
+  *vector_elt_int64_t(VECTOR, rd_num, i) = f32_to_i64(vs2, STATE.frm, true);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_xu_f_v.h b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_xu_f_v.h
new file mode 100644
index 000000000000..f368e7b615c9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwcvt_xu_f_v.h
@@ -0,0 +1,9 @@
+// vfwcvt.xu.f.v *vd, vs2, vm
+VI_VFP_LOOP_BASE
+  VI_CHECK_DSS(false);
+  {
+  float32_t vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i);
+  *vector_elt_uint64_t(VECTOR, rd_num, i) = f32_to_ui64(vs2, STATE.frm, true);
+  }
+  set_fp_exceptions;
+VI_VFP_LOOP_WIDE_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vf.h
new file mode 100644
index 000000000000..b4576514a7ac
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vf.h
@@ -0,0 +1,5 @@
+// vfwmacc.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mulAdd(rs1, vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vv.h
new file mode 100644
index 000000000000..f54a075e937b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmacc_vv.h
@@ -0,0 +1,5 @@
+// vfwmacc.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mulAdd(vs1, vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vf.h
new file mode 100644
index 000000000000..fe96edfc64c1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vf.h
@@ -0,0 +1,5 @@
+// vfwmsac.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mulAdd(rs1, vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vv.h
new file mode 100644
index 000000000000..42973911259a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmsac_vv.h
@@ -0,0 +1,5 @@
+// vfwmsac.vv  *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mulAdd(vs1, vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vf.h
new file mode 100644
index 000000000000..0581b3b04f7d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vf.h
@@ -0,0 +1,5 @@
+// vfwmul.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mul(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vv.h
new file mode 100644
index 000000000000..7f6939d13c75
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwmul_vv.h
@@ -0,0 +1,5 @@
+// vfwmul.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mul(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vf.h
new file mode 100644
index 000000000000..09bd6e24d933
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vf.h
@@ -0,0 +1,5 @@
+// vfwnmacc.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mulAdd(f64(rs1.v ^ F64_SIGN), vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vv.h
new file mode 100644
index 000000000000..4695d749ab4f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwnmacc_vv.h
@@ -0,0 +1,5 @@
+// vfwnmacc.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mulAdd(f64(vs1.v ^ F64_SIGN), vs2, f64(vd->v ^ F64_SIGN));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vf.h
new file mode 100644
index 000000000000..344aae1a5dd0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vf.h
@@ -0,0 +1,5 @@
+// vfwnmacc.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_mulAdd(f64(rs1.v ^ F64_SIGN), vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vv.h
new file mode 100644
index 000000000000..cd858a7838bd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwnmsac_vv.h
@@ -0,0 +1,5 @@
+// vfwnmsac.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_mulAdd(f64(vs1.v ^ F64_SIGN), vs2, *vd);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwredosum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfwredosum_vs.h
new file mode 100644
index 000000000000..377df8842dac
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwredosum_vs.h
@@ -0,0 +1,5 @@
+// vfwredosum.vs *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE_REDUCTION
+({
+  vd_0 = f64_add(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwredsum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vfwredsum_vs.h
new file mode 100644
index 000000000000..ae857bc30487
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwredsum_vs.h
@@ -0,0 +1,5 @@
+// vfwredsum.vs *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE_REDUCTION
+({
+  vd_0 = f64_add(vd_0, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vf.h
new file mode 100644
index 000000000000..50d8b86df0e1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vf.h
@@ -0,0 +1,5 @@
+// vfwsub.vf *vd, vs2, rs1
+VI_VFP_VF_LOOP_WIDE
+({
+  *vd =f64_sub(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vv.h
new file mode 100644
index 000000000000..680f6a45c8cf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_vv.h
@@ -0,0 +1,5 @@
+// vfwsub.vv *vd, vs2, vs1
+VI_VFP_VV_LOOP_WIDE
+({
+  *vd =f64_sub(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wf.h b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wf.h
new file mode 100644
index 000000000000..829076a2a229
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wf.h
@@ -0,0 +1,5 @@
+// vfwsub.wf *vd, vs2, rs1
+VI_VFP_WF_LOOP_WIDE
+({
+  *vd =f64_sub(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wv.h
new file mode 100644
index 000000000000..5d62b8ba6da0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vfwsub_wv.h
@@ -0,0 +1,5 @@
+// vfwsub.wv *vd, vs2, vs1
+VI_VFP_WV_LOOP_WIDE
+({
+  *vd =f64_sub(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vid_v.h b/arch/riscv/kernel/soft_vector/insns_func/vid_v.h
new file mode 100644
index 000000000000..3c270e8d94d2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vid_v.h
@@ -0,0 +1,31 @@
+// vmpopc rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+
+reg_t i;
+for (i = VECTOR->vstart ; i < VECTOR->vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP();
+
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = i;
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = i;
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = i;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = i;
+    break;
+  }
+}
+
+VI_TAIL_ZERO(1);
+VECTOR->vstart = 0;
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/viota_m.h b/arch/riscv/kernel/soft_vector/insns_func/viota_m.h
new file mode 100644
index 000000000000..9b0312a7a95d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/viota_m.h
@@ -0,0 +1,54 @@
+// vmpopc rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+require(VECTOR->vstart == 0);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+
+int cnt = 0;
+reg_t i;
+for (i = 0; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR, rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  bool has_one = false;
+  bool use_ori = (v_vm(insn) == 0) && !do_mask;
+  if (v_vm(insn) == 1 || (v_vm(insn) == 0 && do_mask)) {
+    if (vs2_lsb) {
+      has_one = true;
+    }
+  }
+
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = use_ori ?
+                                   *vector_elt_uint8_t(VECTOR, rd_num, i) : cnt;
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = use_ori ?
+                                    *vector_elt_uint16_t(VECTOR, rd_num, i) : cnt;
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = use_ori ?
+                                    *vector_elt_uint32_t(VECTOR, rd_num, i) : cnt;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = use_ori ?
+                                    *vector_elt_uint64_t(VECTOR, rd_num, i) : cnt;
+    break;
+  }
+
+  if (has_one) {
+    cnt++;
+  }
+}
+
+VI_TAIL_ZERO(1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlb_v.h
new file mode 100644
index 000000000000..cac7a0e8b3c6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlb_v.h
@@ -0,0 +1,5 @@
+// vlb.v and vlseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_LD(0, i * nf + fn, int8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlbff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlbff_v.h
new file mode 100644
index 000000000000..6517315b5c40
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlbff_v.h
@@ -0,0 +1,2 @@
+// vlbff.v and vlseg[2-8]bff.v
+VI_LDST_FF(int, 8);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlbu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlbu_v.h
new file mode 100644
index 000000000000..d4f7ef62a1e6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlbu_v.h
@@ -0,0 +1,5 @@
+// vlbu.v and vlseg[2-8]bu.v
+require(VECTOR->vsew >= e8);
+{
+VI_LD(0, i * nf + fn, uint8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlbuff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlbuff_v.h
new file mode 100644
index 000000000000..53a0685135a1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlbuff_v.h
@@ -0,0 +1,2 @@
+// vlbuff.v and vlseg[2-8]buff.v
+VI_LDST_FF(uint, 8);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vle_v.h b/arch/riscv/kernel/soft_vector/insns_func/vle_v.h
new file mode 100644
index 000000000000..dab7f12031b7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vle_v.h
@@ -0,0 +1,12 @@
+// vle.v and vlseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+if (sew == e8) {
+  VI_LD(0, (i * nf + fn), int8, 1);
+} else if (sew == e16) {
+  VI_LD(0, (i * nf + fn), int16, 2);
+} else if (sew == e32) {
+  VI_LD(0, (i * nf + fn), int32, 4);
+} else if (sew == e64) {
+  VI_LD(0, (i * nf + fn), int64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vleff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vleff_v.h
new file mode 100644
index 000000000000..00c5288f7335
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vleff_v.h
@@ -0,0 +1,58 @@
+
+const reg_t nf = v_nf(insn) + 1;
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require((nf * VECTOR->vlmul) <= (NVPR / 4));
+{
+const reg_t sew = VECTOR->vsew;
+const reg_t vl = VECTOR->vl;
+const reg_t baseAddr = RS1;
+const reg_t rd_num = rd(insn);
+bool early_stop = false;
+const reg_t vlmul = VECTOR->vlmul;
+reg_t i;
+for (i = 0; i < VECTOR->vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  bool is_zero = false;
+  reg_t fn;
+  VI_STRIP(i);
+  VI_ELEMENT_SKIP(i);
+
+for (fn = 0; fn < nf; ++fn) {
+    load_uint8(baseAddr + (i * nf + fn) * 1);
+
+    switch (sew) {
+    case e8:
+      *vector_elt_uint8_t(VECTOR, rd_num + fn * vlmul, vreg_inx) =
+        is_valid ? load_uint8(baseAddr + (i * nf + fn) * 1) : 0;
+      is_zero = is_valid && *vector_elt_uint8_t(VECTOR, rd_num + fn * vlmul, vreg_inx) == 0;
+      break;
+    case e16:
+      *vector_elt_uint16_t(VECTOR, rd_num + fn * vlmul, vreg_inx) =
+        is_valid ? load_uint16(baseAddr + (i * nf + fn) * 2) : 0;
+      is_zero = is_valid && *vector_elt_uint16_t(VECTOR, rd_num + fn * vlmul, vreg_inx) == 0;
+      break;
+    case e32:
+      *vector_elt_uint32_t(VECTOR, rd_num + fn * vlmul, vreg_inx) =
+        is_valid ? load_uint32(baseAddr + (i * nf + fn) * 4) : 0;
+      is_zero = is_valid && *vector_elt_uint32_t(VECTOR, rd_num + fn * vlmul, vreg_inx) == 0;
+      break;
+    case e64:
+      *vector_elt_uint64_t(VECTOR, rd_num + fn * vlmul, vreg_inx) =
+        is_valid ? load_uint64(baseAddr + (i * nf + fn) * 8) : 0;
+      is_zero = is_valid && *vector_elt_uint64_t(VECTOR, rd_num + fn * vlmul, vreg_inx) == 0;
+      break;
+    }
+
+    if (is_zero) {
+      VECTOR->vl = i;
+      early_stop = true;
+      break;
+    }
+  }
+
+  if (early_stop) {
+    break;
+  }
+}
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlh_v.h
new file mode 100644
index 000000000000..690ca02cf967
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlh_v.h
@@ -0,0 +1,5 @@
+// vlh.v and vlseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_LD(0, i * nf + fn, int16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlhff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlhff_v.h
new file mode 100644
index 000000000000..c4c2d8ea3fa4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlhff_v.h
@@ -0,0 +1,2 @@
+// vlh.v and vlseg[2-8]hff.v
+VI_LDST_FF(int, 16);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlhu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlhu_v.h
new file mode 100644
index 000000000000..5d87a82fed6c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlhu_v.h
@@ -0,0 +1,5 @@
+// vlhu.v and vlseg[2-8]hu.v
+require(VECTOR->vsew >= e16);
+{
+VI_LD(0, i * nf + fn, uint16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlhuff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlhuff_v.h
new file mode 100644
index 000000000000..f23f82db6df7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlhuff_v.h
@@ -0,0 +1,2 @@
+// vlhuff.v and vlseg[2-8]huff.v
+VI_LDST_FF(uint, 16);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlsb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlsb_v.h
new file mode 100644
index 000000000000..dabb453ca355
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlsb_v.h
@@ -0,0 +1,5 @@
+// vlsb.v and vlsseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_LD(i * RS2, fn, int8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlsbu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlsbu_v.h
new file mode 100644
index 000000000000..23f162f66972
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlsbu_v.h
@@ -0,0 +1,5 @@
+// vlsb.v and vlsseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_LD(i * RS2, fn, uint8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlse_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlse_v.h
new file mode 100644
index 000000000000..7967ea169b7a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlse_v.h
@@ -0,0 +1,13 @@
+// vlse.v and vlsseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+
+if (sew == e8) {
+  VI_LD(i * RS2, fn, int8, 1);
+} else if (sew == e16) {
+  VI_LD(i * RS2, fn, int16, 2);
+} else if (sew == e32) {
+  VI_LD(i * RS2, fn, int32, 4);
+} else if (sew == e64) {
+  VI_LD(i * RS2, fn, int64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlsh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlsh_v.h
new file mode 100644
index 000000000000..d4289ae42fcd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlsh_v.h
@@ -0,0 +1,5 @@
+// vlsh.v and vlsseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_LD(i * RS2, fn, int16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlshu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlshu_v.h
new file mode 100644
index 000000000000..a7017698dc42
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlshu_v.h
@@ -0,0 +1,5 @@
+// vlsh.v and vlsseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_LD(i * RS2, fn, uint16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlsw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlsw_v.h
new file mode 100644
index 000000000000..3647e9f1b6e3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlsw_v.h
@@ -0,0 +1,5 @@
+// vlsw.v and vlsseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_LD(i * RS2, fn, int32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlswu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlswu_v.h
new file mode 100644
index 000000000000..8f48eaa62019
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlswu_v.h
@@ -0,0 +1,5 @@
+// vlsw.v and vlsseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_LD(i * RS2, fn, uint32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlw_v.h
new file mode 100644
index 000000000000..447da4938293
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlw_v.h
@@ -0,0 +1,5 @@
+// vlw.v and vlseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_LD(0, i * nf + fn, int32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlwff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlwff_v.h
new file mode 100644
index 000000000000..b671b01be18a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlwff_v.h
@@ -0,0 +1,3 @@
+// vlwff.v
+// vlw.v and vlseg[2-8]wff.v
+VI_LDST_FF(int, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlwu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlwu_v.h
new file mode 100644
index 000000000000..476f55c593d4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlwu_v.h
@@ -0,0 +1,5 @@
+// vlwu.v and vlseg[2-8]wu.v
+require(VECTOR->vsew >= e32);
+{
+VI_LD(0, i * nf + fn, uint32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlwuff_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlwuff_v.h
new file mode 100644
index 000000000000..d50cb6960caa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlwuff_v.h
@@ -0,0 +1,2 @@
+// vlwuff.v and vlseg[2-8]wuff.v
+VI_LDST_FF(uint, 32);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxb_v.h
new file mode 100644
index 000000000000..e4a548f55ff7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxb_v.h
@@ -0,0 +1,8 @@
+// vlxb.v and vlsseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, int8, 1);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxbu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxbu_v.h
new file mode 100644
index 000000000000..4018e724cb41
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxbu_v.h
@@ -0,0 +1,8 @@
+// vlxbu.v and vlxseg[2-8]bu.v
+require(VECTOR->vsew >= e8);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, uint8, 1);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxe_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxe_v.h
new file mode 100644
index 000000000000..683b50cb7f30
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxe_v.h
@@ -0,0 +1,13 @@
+// vlxe.v and vlxseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+if (sew == e8) {
+  VI_LD_WITH_I(index[i], fn, int8, 1);
+} else if (sew == e16) {
+  VI_LD_WITH_I(index[i], fn, int16, 2);
+} else if (sew == e32) {
+  VI_LD_WITH_I(index[i], fn, int32, 4);
+} else if (sew == e64) {
+  VI_LD_WITH_I(index[i], fn, int64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxh_v.h
new file mode 100644
index 000000000000..9da2f767b4b7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxh_v.h
@@ -0,0 +1,8 @@
+// vlxh.v and vlxseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, int16, 2);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxhu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxhu_v.h
new file mode 100644
index 000000000000..82a503086f73
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxhu_v.h
@@ -0,0 +1,8 @@
+// vlxh.v and vlxseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, uint16, 2);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxw_v.h
new file mode 100644
index 000000000000..78306853fc04
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxw_v.h
@@ -0,0 +1,8 @@
+// vlxw.v and vlxseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, int32, 4);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vlxwu_v.h b/arch/riscv/kernel/soft_vector/insns_func/vlxwu_v.h
new file mode 100644
index 000000000000..9920d1bdd8f1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vlxwu_v.h
@@ -0,0 +1,8 @@
+// vlxwu.v and vlxseg[2-8]wu.v
+require(VECTOR->vsew >= e32);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_LD_WITH_I(index[i], fn, uint32, 4);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmacc_vv.h
new file mode 100644
index 000000000000..461eabf38a7b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmacc_vv.h
@@ -0,0 +1,5 @@
+// vmacc.vv: *vd[i] = +(vs1[i] * vs2[i]) + *vd[i]
+VI_VV_LOOP
+({
+  *vd =vs1 * vs2 + *vd;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmacc_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmacc_vx.h
new file mode 100644
index 000000000000..ca1bc044da44
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmacc_vx.h
@@ -0,0 +1,5 @@
+// vmacc.vx: *vd[i] = +(x[rs1] * vs2[i]) + *vd[i]
+VI_VX_LOOP
+({
+  *vd =rs1 * vs2 + *vd;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadc_vim.h b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vim.h
new file mode 100644
index 000000000000..e016fda83e7c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vim.h
@@ -0,0 +1,16 @@
+// vmadc.vim *vd, vs2, simm5
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_XI_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & simm5) + (op_mask & vs2) + carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadc_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vvm.h
new file mode 100644
index 000000000000..c9780bd93ae2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vvm.h
@@ -0,0 +1,16 @@
+// vmadc.vvm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_VV_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs1) + (op_mask & vs2) + carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadc_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vxm.h
new file mode 100644
index 000000000000..17bec47d5a5e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadc_vxm.h
@@ -0,0 +1,16 @@
+// vadc.vx *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_XI_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & rs1) + (op_mask & vs2) + carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmadd_vv.h
new file mode 100644
index 000000000000..978c46e553c4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadd_vv.h
@@ -0,0 +1,5 @@
+// vmadd: *vd[i] = (*vd[i] * vs1[i]) + vs2[i]
+VI_VV_LOOP
+({
+  *vd =*vd * vs1 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmadd_vx.h
new file mode 100644
index 000000000000..1d4becf1780b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmadd_vx.h
@@ -0,0 +1,5 @@
+// vmadd: *vd[i] = (*vd[i] * x[rs1]) + vs2[i]
+VI_VX_LOOP
+({
+  *vd =*vd * rs1 + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmand_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmand_mm.h
new file mode 100644
index 000000000000..d7e931519195
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmand_mm.h
@@ -0,0 +1,2 @@
+// vmand.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 & vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmandnot_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmandnot_mm.h
new file mode 100644
index 000000000000..6d86f9cfa89a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmandnot_mm.h
@@ -0,0 +1,2 @@
+// vmandnot.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 & ~vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmax_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmax_vv.h
new file mode 100644
index 000000000000..b4682809fb31
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmax_vv.h
@@ -0,0 +1,10 @@
+// vmax.vv *vd, vs2, vs1, vm   # Vector-vector
+VI_VV_LOOP
+({
+  if (vs1 >= vs2) {
+    *vd =vs1;
+  } else {
+    *vd =vs2;
+  }
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmax_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmax_vx.h
new file mode 100644
index 000000000000..8b75d7648a36
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmax_vx.h
@@ -0,0 +1,10 @@
+// vmax.vx *vd, vs2, rs1, vm   # vector-scalar
+VI_VX_LOOP
+({
+  if (rs1 >= vs2) {
+    *vd =rs1;
+  } else {
+    *vd =vs2;
+  }
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vv.h
new file mode 100644
index 000000000000..d65f4a81f93d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vv.h
@@ -0,0 +1,9 @@
+// vmaxu.vv *vd, vs2, vs1, vm   # Vector-vector
+VI_VV_ULOOP
+({
+  if (vs1 >= vs2) {
+    *vd =vs1;
+  } else {
+    *vd =vs2;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vx.h
new file mode 100644
index 000000000000..68fe2f3bb1a1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmaxu_vx.h
@@ -0,0 +1,9 @@
+// vmaxu.vx *vd, vs2, rs1, vm   # vector-scalar
+VI_VX_ULOOP
+({
+  if (rs1 >= vs2) {
+    *vd =rs1;
+  } else {
+    *vd =vs2;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmerge_vim.h b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vim.h
new file mode 100644
index 000000000000..7ea0d0502886
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vim.h
@@ -0,0 +1,9 @@
+// vmerge.vim *vd, vs2, simm5
+VI_VVXI_MERGE_LOOP
+({
+  int midx = (VECTOR->vmlen * i) / 64;
+  int mpos = (VECTOR->vmlen * i) % 64;
+  bool use_first = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  *vd =use_first ? simm5 : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmerge_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vvm.h
new file mode 100644
index 000000000000..4f0e95c78b36
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vvm.h
@@ -0,0 +1,9 @@
+// vmerge.vvm *vd, vs2, vs1
+VI_VVXI_MERGE_LOOP
+({
+  int midx = (VECTOR->vmlen * i) / 64;
+  int mpos = (VECTOR->vmlen * i) % 64;
+  bool use_first = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  *vd =use_first ? vs1 : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmerge_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vxm.h
new file mode 100644
index 000000000000..64a3f9b932fe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmerge_vxm.h
@@ -0,0 +1,9 @@
+// vmerge.vxm *vd, vs2, rs1
+VI_VVXI_MERGE_LOOP
+({
+  int midx = (VECTOR->vmlen * i) / 64;
+  int mpos = (VECTOR->vmlen * i) % 64;
+  bool use_first = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+
+  *vd =use_first ? rs1 : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vf.h
new file mode 100644
index 000000000000..6d2a4e896919
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vf.h
@@ -0,0 +1,5 @@
+// vfeq.vf *vd, vs2, fs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_eq(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vv.h
new file mode 100644
index 000000000000..1e5ec2404813
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfeq_vv.h
@@ -0,0 +1,5 @@
+// vfeq.vv *vd, vs2, vs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_eq(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfge_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfge_vf.h
new file mode 100644
index 000000000000..58535446e3e3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfge_vf.h
@@ -0,0 +1,5 @@
+// vfge.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_le_quiet(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfgt_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfgt_vf.h
new file mode 100644
index 000000000000..153a526e52b4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfgt_vf.h
@@ -0,0 +1,5 @@
+// vfgt.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_lt_quiet(rs1, vs2);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfirst_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmfirst_m.h
new file mode 100644
index 000000000000..67d08ca2cbf6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfirst_m.h
@@ -0,0 +1,22 @@
+// vmfirst rd, vs2
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+require(VECTOR->vstart == 0);
+{
+reg_t vl = VECTOR->vl;
+reg_t rs2_num = rs2(insn);
+reg_t pos = -1;
+reg_t i;
+for (i=VECTOR->vstart; i < vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP()
+  {
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  if (vs2_lsb) {
+    pos = i;
+    break;
+  }
+  }
+}
+VECTOR->vstart = 0;
+WRITE_RD(pos);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfle_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfle_vf.h
new file mode 100644
index 000000000000..41f7b55fb870
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfle_vf.h
@@ -0,0 +1,5 @@
+// vfle.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_le(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfle_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmfle_vv.h
new file mode 100644
index 000000000000..08a43a172d87
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfle_vv.h
@@ -0,0 +1,5 @@
+// vfle.vv *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_le_quiet(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmflt_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmflt_vf.h
new file mode 100644
index 000000000000..51684537a19f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmflt_vf.h
@@ -0,0 +1,5 @@
+// vflt.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_lt_quiet(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmflt_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmflt_vv.h
new file mode 100644
index 000000000000..795a4f3cf6a8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmflt_vv.h
@@ -0,0 +1,5 @@
+// vflt.vv *vd, vs2, vs1
+VI_VFP_LOOP_CMP
+({
+  res = f64_lt_quiet(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfne_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmfne_vf.h
new file mode 100644
index 000000000000..82d202446f53
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfne_vf.h
@@ -0,0 +1,5 @@
+// vfne.vf *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = !f64_eq(vs2, rs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmfne_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmfne_vv.h
new file mode 100644
index 000000000000..8f3a5861d769
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmfne_vv.h
@@ -0,0 +1,5 @@
+// vfne.vv *vd, vs2, rs1
+VI_VFP_LOOP_CMP
+({
+  res = !f64_eq(vs2, vs1);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmford_vf.h b/arch/riscv/kernel/soft_vector/insns_func/vmford_vf.h
new file mode 100644
index 000000000000..02a89ad90eef
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmford_vf.h
@@ -0,0 +1,5 @@
+// vford.vf *vd, vs2, rs1, vm
+VI_VFP_LOOP_CMP
+({
+  res = !(f64_isSignalingNaN(vs2) || f64_isSignalingNaN(rs1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmford_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmford_vv.h
new file mode 100644
index 000000000000..0422469b83a0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmford_vv.h
@@ -0,0 +1,5 @@
+// vford.vv *vd, vs2, vs1, vm
+VI_VFP_LOOP_CMP
+({
+  res = !(f64_isSignalingNaN(vs2) || f64_isSignalingNaN(vs1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmin_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmin_vv.h
new file mode 100644
index 000000000000..d44465982eca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmin_vv.h
@@ -0,0 +1,11 @@
+// vmin.vv *vd, vs2, vs1, vm   # Vector-vector
+VI_VV_LOOP
+({
+  if (vs1 <= vs2) {
+    *vd =vs1;
+  } else {
+    *vd =vs2;
+  }
+
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmin_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmin_vx.h
new file mode 100644
index 000000000000..ba0d122de9a0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmin_vx.h
@@ -0,0 +1,11 @@
+// vminx.vx *vd, vs2, rs1, vm   # vector-scalar
+VI_VX_LOOP
+({
+  if (rs1 <= vs2) {
+    *vd =rs1;
+  } else {
+    *vd =vs2;
+  }
+
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vminu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vminu_vv.h
new file mode 100644
index 000000000000..5629d7846049
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vminu_vv.h
@@ -0,0 +1,9 @@
+// vminu.vv *vd, vs2, vs1, vm   # Vector-vector
+VI_VV_ULOOP
+({
+  if (vs1 <= vs2) {
+    *vd =vs1;
+  } else {
+    *vd =vs2;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vminu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vminu_vx.h
new file mode 100644
index 000000000000..9d8fabd21672
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vminu_vx.h
@@ -0,0 +1,10 @@
+// vminu.vx *vd, vs2, rs1, vm   # vector-scalar
+VI_VX_ULOOP
+({
+  if (rs1 <= vs2) {
+    *vd =rs1;
+  } else {
+    *vd =vs2;
+  }
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmnand_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmnand_mm.h
new file mode 100644
index 000000000000..1fd8d6162e55
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmnand_mm.h
@@ -0,0 +1,2 @@
+// vmnand.mm *vd, vs2, vs1
+VI_LOOP_MASK(~(vs2 & vs1));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmnor_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmnor_mm.h
new file mode 100644
index 000000000000..e5356df7cd42
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmnor_mm.h
@@ -0,0 +1,2 @@
+// vmnor.mm *vd, vs2, vs1
+VI_LOOP_MASK(~(vs2 | vs1));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmor_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmor_mm.h
new file mode 100644
index 000000000000..86b456a07295
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmor_mm.h
@@ -0,0 +1,2 @@
+// vmor.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 | vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmornot_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmornot_mm.h
new file mode 100644
index 000000000000..34326f3b99ae
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmornot_mm.h
@@ -0,0 +1,2 @@
+// vmornot.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 | ~vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmpopc_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmpopc_m.h
new file mode 100644
index 000000000000..7831089371da
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmpopc_m.h
@@ -0,0 +1,25 @@
+// vmpopc rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+require(VECTOR->vstart == 0);
+{
+reg_t vl = VECTOR->vl;
+reg_t rs2_num = rs2(insn);
+reg_t popcount = 0;
+reg_t i;
+for (i=VECTOR->vstart; i<vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  if (v_vm(insn) == 1) {
+    popcount += vs2_lsb;
+  } else {
+    bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+    popcount += (vs2_lsb && do_mask);
+  }
+}
+VECTOR->vstart = 0;
+WRITE_RD(popcount);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vvm.h
new file mode 100644
index 000000000000..3f50e3bf6c25
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vvm.h
@@ -0,0 +1,16 @@
+// vmsbc.vvm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_VV_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs2) - (op_mask & vs1) - carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vxm.h
new file mode 100644
index 000000000000..257b7e4cd95e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsbc_vxm.h
@@ -0,0 +1,16 @@
+// vmsbc.vxm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+{
+VI_XI_LOOP_CARRY
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs2) - (op_mask & rs1) - carry;
+
+  carry = (res >> sew) & 0x1u;
+  *vd =(*vd & ~mmask) | ((carry << mpos) & mmask);
+})
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsbf_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmsbf_m.h
new file mode 100644
index 000000000000..b53701c6bebf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsbf_m.h
@@ -0,0 +1,35 @@
+// vmsbf.m *vd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+
+bool has_one = false;
+reg_t i;
+for (i = VECTOR->vstart; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+  uint64_t *vd =vector_elt_uint64_t(VECTOR, rd_num, midx);
+
+
+  if (v_vm(insn) == 1 || (v_vm(insn) == 0 && do_mask)) {
+    uint64_t res = 0;
+    if (!has_one && !vs2_lsb) {
+      res = 1;
+    } else if(!has_one && vs2_lsb) {
+      has_one = true;
+    }
+    *vd =(*vd & ~mmask) | ((res << mpos) & mmask);
+  }
+}
+
+VI_TAIL_ZERO_MASK(rd_num);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmseq_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vi.h
new file mode 100644
index 000000000000..db9b85753648
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vi.h
@@ -0,0 +1,5 @@
+// vseq.vi *vd, vs2, simm5
+VI_VI_LOOP_CMP
+({
+  res = simm5 == vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmseq_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vv.h
new file mode 100644
index 000000000000..796afc072596
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vv.h
@@ -0,0 +1,6 @@
+// vseq.vv *vd, vs2, vs1
+VI_VV_LOOP_CMP
+({
+  res = vs2 == vs1;
+})
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmseq_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vx.h
new file mode 100644
index 000000000000..2041508b1968
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmseq_vx.h
@@ -0,0 +1,5 @@
+// vseq.vx *vd, vs2, rs1
+VI_VX_LOOP_CMP
+({
+  res = rs1 == vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vi.h
new file mode 100644
index 000000000000..8590f579e035
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vi.h
@@ -0,0 +1,5 @@
+// vsgt.vi  *vd, vs2, simm5
+VI_VI_LOOP_CMP
+({
+  res = vs2 > simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vx.h
new file mode 100644
index 000000000000..ad5b35698892
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsgt_vx.h
@@ -0,0 +1,5 @@
+// vsgt.vx  *vd, vs2, rs1
+VI_VX_LOOP_CMP
+({
+  res = vs2 > rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vi.h
new file mode 100644
index 000000000000..07a3bf0bfab2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vi.h
@@ -0,0 +1,5 @@
+// vsgtu.vi  *vd, *vd2, zimm5
+VI_VI_ULOOP_CMP
+({
+  res = vs2 > simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vx.h
new file mode 100644
index 000000000000..9e7d0356fd93
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsgtu_vx.h
@@ -0,0 +1,5 @@
+// vsgtu.vx  *vd, vs2, rs1
+VI_VX_ULOOP_CMP
+({
+  res = vs2 > rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsif_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmsif_m.h
new file mode 100644
index 000000000000..1eb44e64494d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsif_m.h
@@ -0,0 +1,35 @@
+// vmpopc rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+
+bool has_one = false;
+reg_t i;
+for (i = VECTOR->vstart ; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+  uint64_t *vd =vector_elt_uint64_t(VECTOR, rd_num, midx);
+
+  if (v_vm(insn) == 1 || (v_vm(insn) == 0 && do_mask)) {
+    uint64_t res = 0;
+    if (!has_one && !vs2_lsb) {
+      res = 1;
+    } else if(!has_one && vs2_lsb) {
+      has_one = true;
+      res = 1;
+    }
+    *vd =(*vd & ~mmask) | ((res << mpos) & mmask);
+  }
+}
+
+VI_TAIL_ZERO_MASK(rd_num);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsle_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vi.h
new file mode 100644
index 000000000000..d2e1bd271235
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vi.h
@@ -0,0 +1,5 @@
+// vsle.vi *vd, vs2, simm5
+VI_VI_LOOP_CMP
+({
+  res = vs2 <= simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsle_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vv.h
new file mode 100644
index 000000000000..3bce5bcf70a6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vv.h
@@ -0,0 +1,5 @@
+// vsle.vv *vd, vs2, vs1
+VI_VV_LOOP_CMP
+({
+  res = vs2 <= vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsle_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vx.h
new file mode 100644
index 000000000000..1c22d4c33a10
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsle_vx.h
@@ -0,0 +1,5 @@
+// vsle.vx *vd, vs2, rs1
+VI_VX_LOOP_CMP
+({
+  res = vs2 <= rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vi.h
new file mode 100644
index 000000000000..dd664c238c21
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vi.h
@@ -0,0 +1,5 @@
+// vsleu.vi *vd, vs2, zimm5
+VI_VI_ULOOP_CMP
+({
+  res = vs2 <= simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vv.h
new file mode 100644
index 000000000000..8f37f3f31675
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vv.h
@@ -0,0 +1,5 @@
+// vsleu.vv *vd, vs2, vs1
+VI_VV_ULOOP_CMP
+({
+  res = vs2 <= vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vx.h
new file mode 100644
index 000000000000..5c666ce2cd08
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsleu_vx.h
@@ -0,0 +1,5 @@
+// vsleu.vx  *vd, vs2, rs1
+VI_VX_ULOOP_CMP
+({
+  res = vs2 <= rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmslt_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmslt_vv.h
new file mode 100644
index 000000000000..80a31b13f920
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmslt_vv.h
@@ -0,0 +1,5 @@
+// vslt.vv  *vd, *vd2, vs1
+VI_VV_LOOP_CMP
+({
+  res = vs2 < vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmslt_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmslt_vx.h
new file mode 100644
index 000000000000..ab1e8d65307c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmslt_vx.h
@@ -0,0 +1,5 @@
+// vslt.vx  *vd, vs2, vs1
+VI_VX_LOOP_CMP
+({
+  res = vs2 < rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vv.h
new file mode 100644
index 000000000000..d0cc56762a7f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vv.h
@@ -0,0 +1,5 @@
+// vsltu.vv  *vd, vs2, vs1
+VI_VV_ULOOP_CMP
+({
+  res = vs2 < vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vx.h
new file mode 100644
index 000000000000..3740d5de3892
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsltu_vx.h
@@ -0,0 +1,5 @@
+// vsltu.vx  *vd, vs2, vs1
+VI_VX_ULOOP_CMP
+({
+  res = vs2 < rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsne_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vi.h
new file mode 100644
index 000000000000..8b33b3eb92be
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vi.h
@@ -0,0 +1,5 @@
+// vsne.vi  *vd, vs2, simm5
+VI_VI_LOOP_CMP
+({
+  res = vs2 != simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsne_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vv.h
new file mode 100644
index 000000000000..44217b2dafb4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vv.h
@@ -0,0 +1,5 @@
+// vneq.vv  *vd, vs2, vs1
+VI_VV_LOOP_CMP
+({
+  res = vs2 != vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsne_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vx.h
new file mode 100644
index 000000000000..0171b4fbc774
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsne_vx.h
@@ -0,0 +1,5 @@
+// vsne.vx  *vd, vs2, rs1
+VI_VX_LOOP_CMP
+({
+  res = vs2 != rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmsof_m.h b/arch/riscv/kernel/soft_vector/insns_func/vmsof_m.h
new file mode 100644
index 000000000000..ec6268ace41d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmsof_m.h
@@ -0,0 +1,33 @@
+// vmsof.m rd, vs2, vm
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+
+bool has_one = false;
+reg_t i;
+for (i = VECTOR->vstart ; i < vl; ++i) {
+  const int mlen = VECTOR->vmlen;
+  const int midx = (mlen * i) / 64;
+  const int mpos = (mlen * i) % 64;
+  const uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos);
+
+  bool vs2_lsb = ((*vector_elt_uint64_t(VECTOR,rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1;
+  uint64_t *vd = vector_elt_uint64_t(VECTOR, rd_num, midx);
+
+  if (v_vm(insn) == 1 || (v_vm(insn) == 0 && do_mask)) {
+    uint64_t res = 0;
+    if(!has_one && vs2_lsb) {
+      has_one = true;
+      res = 1;
+    }
+    *vd =(*vd & ~mmask) | ((res << mpos) & mmask);
+  }
+}
+
+VI_TAIL_ZERO_MASK(rd_num);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmul_vv.h
new file mode 100644
index 000000000000..3233d8afd6b9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmul_vv.h
@@ -0,0 +1,5 @@
+// vmul *vd, vs2, vs1
+VI_VV_LOOP
+({
+  *vd =vs2 * vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmul_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmul_vx.h
new file mode 100644
index 000000000000..10c58b50c07e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmul_vx.h
@@ -0,0 +1,5 @@
+// vmul *vd, vs2, rs1
+VI_VX_LOOP
+({
+  *vd =vs2 * rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulh_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmulh_vv.h
new file mode 100644
index 000000000000..bc57f685c75c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulh_vv.h
@@ -0,0 +1,5 @@
+// vmulh *vd, vs2, vs1
+VI_VV_LOOP
+({
+  *vd =((int128_t)vs2 * vs1) >> sew;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulh_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmulh_vx.h
new file mode 100644
index 000000000000..3e647d9abeb0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulh_vx.h
@@ -0,0 +1,5 @@
+// vmulh *vd, vs2, rs1
+VI_VX_LOOP
+({
+  *vd =((int128_t)vs2 * rs1) >> sew;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vv.h
new file mode 100644
index 000000000000..657017870e25
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vv.h
@@ -0,0 +1,37 @@
+// vmulhsu.vv *vd, vs2, vs1
+VI_LOOP_BASE
+switch(sew) {
+case e8: {
+  int8_t *vd =vector_elt_int8_t(VECTOR, rd_num, i);
+  int8_t vs2 = *vector_elt_int8_t(VECTOR, rs2_num, i);
+  uint8_t vs1 = *vector_elt_uint8_t(VECTOR, rs1_num, i);
+
+  *vd =((int16_t)vs2 * (uint16_t)vs1) >> sew;
+  break;
+}
+case e16: {
+  int16_t *vd =vector_elt_int16_t(VECTOR, rd_num, i);
+  int16_t vs2 = *vector_elt_int16_t(VECTOR, rs2_num, i);
+  uint16_t vs1 = *vector_elt_uint16_t(VECTOR, rs1_num, i);
+
+  *vd =((int32_t)vs2 * (uint32_t)vs1) >> sew;
+  break;
+}
+case e32: {
+  int32_t *vd =vector_elt_int32_t(VECTOR, rd_num, i);
+  int32_t vs2 = *vector_elt_int32_t(VECTOR, rs2_num, i);
+  uint32_t vs1 = *vector_elt_uint32_t(VECTOR, rs1_num, i);
+
+  *vd =((int64_t)vs2 * (uint64_t)vs1) >> sew;
+  break;
+}
+default: {
+  int64_t *vd =vector_elt_int64_t(VECTOR, rd_num, i);
+  int64_t vs2 = *vector_elt_int64_t(VECTOR, rs2_num, i);
+  uint64_t vs1 = *vector_elt_uint64_t(VECTOR, rs1_num, i);
+
+  *vd =((int128_t)vs2 * (uint128_t)vs1) >> sew;
+  break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vx.h
new file mode 100644
index 000000000000..c3c750776901
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulhsu_vx.h
@@ -0,0 +1,37 @@
+// vmulhsu.vx *vd, vs2, rs1
+VI_LOOP_BASE
+switch(sew) {
+case e8: {
+  int8_t *vd =vector_elt_int8_t(VECTOR, rd_num, i);
+  int8_t vs2 = *vector_elt_int8_t(VECTOR, rs2_num, i);
+  uint8_t rs1 = RS1;
+
+  *vd =((int16_t)vs2 * (uint16_t)rs1) >> sew;
+  break;
+}
+case e16: {
+  int16_t *vd =vector_elt_int16_t(VECTOR, rd_num, i);
+  int16_t vs2 = *vector_elt_int16_t(VECTOR, rs2_num, i);
+  uint16_t rs1 = RS1;
+
+  *vd =((int32_t)vs2 * (uint32_t)rs1) >> sew;
+  break;
+}
+case e32: {
+  int32_t *vd =vector_elt_int32_t(VECTOR, rd_num, i);
+  int32_t vs2 = *vector_elt_int32_t(VECTOR, rs2_num, i);
+  uint32_t rs1 = RS1;
+
+  *vd =((int64_t)vs2 * (uint64_t)rs1) >> sew;
+  break;
+}
+default: {
+  int64_t *vd =vector_elt_int64_t(VECTOR, rd_num, i);
+  int64_t vs2 = *vector_elt_int64_t(VECTOR, rs2_num, i);
+  uint64_t rs1 = RS1;
+
+  *vd =((int128_t)vs2 * (uint128_t)rs1) >> sew;
+  break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vv.h
new file mode 100644
index 000000000000..f09da06088d8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vv.h
@@ -0,0 +1,5 @@
+// vmulhu *vd ,vs2, vs1
+VI_VV_ULOOP
+({
+  *vd =((uint128_t)vs2 * vs1) >> sew;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vx.h
new file mode 100644
index 000000000000..3addd9002cde
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmulhu_vx.h
@@ -0,0 +1,5 @@
+// vmulhu *vd ,vs2, rs1
+VI_VX_ULOOP
+({
+  *vd =((uint128_t)vs2 * rs1) >> sew;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmv_s_x.h b/arch/riscv/kernel/soft_vector/insns_func/vmv_s_x.h
new file mode 100644
index 000000000000..bb117c8c074b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmv_s_x.h
@@ -0,0 +1,48 @@
+// vmv_s_x: *vd[0] = rs1
+require(v_vm(insn) == 1);
+require(VECTOR->vsew == e8 || VECTOR->vsew == e16 ||
+        VECTOR->vsew == e32 || VECTOR->vsew == e64);
+{
+reg_t vl = VECTOR->vl;
+
+if (vl > 0) {
+  reg_t rd_num = rd(insn);
+  reg_t sew = VECTOR->vsew;
+  const reg_t max_len = VECTOR->VLEN / sew;
+  reg_t i;
+  switch(sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, 0) = RS1;
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, 0) = RS1;
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, 0) = RS1;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, 0) = RS1;
+    break;
+  }
+
+  for (i = 1; i < max_len; ++i) {
+    switch(sew) {
+    case e8:
+      *vector_elt_uint8_t(VECTOR, rd_num, i) = 0;
+      break;
+    case e16:
+      *vector_elt_uint16_t(VECTOR, rd_num, i) = 0;
+      break;
+    case e32:
+      *vector_elt_uint32_t(VECTOR, rd_num, i) = 0;
+      break;
+    default:
+      *vector_elt_uint64_t(VECTOR, rd_num, i) = 0;
+      break;
+    }
+  }
+
+  vl = 0;
+}
+
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmv_v_i.h b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_i.h
new file mode 100644
index 000000000000..6dc72c32debf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_i.h
@@ -0,0 +1,5 @@
+// vmv.v.i *vd, simm5
+VI_VVXI_MERGE_LOOP
+({
+  *vd =simm5;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmv_v_v.h b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_v.h
new file mode 100644
index 000000000000..aafa28480376
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_v.h
@@ -0,0 +1,5 @@
+// vvmv.v.v *vd, vs1
+VI_VVXI_MERGE_LOOP
+({
+  *vd =vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmv_v_x.h b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_x.h
new file mode 100644
index 000000000000..2c409043333a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmv_v_x.h
@@ -0,0 +1,5 @@
+// vmv.v.x *vd, rs1
+VI_VVXI_MERGE_LOOP
+({
+  *vd =rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmxnor_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmxnor_mm.h
new file mode 100644
index 000000000000..c9af826ff5c7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmxnor_mm.h
@@ -0,0 +1,2 @@
+// vmnxor.mm *vd, vs2, vs1
+VI_LOOP_MASK(~(vs2 ^ vs1));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vmxor_mm.h b/arch/riscv/kernel/soft_vector/insns_func/vmxor_mm.h
new file mode 100644
index 000000000000..5076f7641123
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vmxor_mm.h
@@ -0,0 +1,2 @@
+// vmxor.mm *vd, vs2, vs1
+VI_LOOP_MASK(vs2 ^ vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclip_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vi.h
new file mode 100644
index 000000000000..05573daaec81
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vi.h
@@ -0,0 +1,24 @@
+// vnclip: *vd[i] = clip(round(vs2[i] + rnd) >> simm)
+VRM xrm = VECTOR->vxrm;
+int64_t int_max = (1 << (VECTOR->vsew - 1)) - 1;
+int64_t int_min = -(1 << (VECTOR->vsew - 1));
+VI_VVXI_LOOP_NARROW
+({
+
+  int64_t result = vs2;
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+  result = vsext(result, sew * 2) >> (zimm5 & ((sew * 2) < 32? (sew * 2) - 1: 31));
+
+// saturation
+  if (result < int_min) {
+    result = int_min;
+    VECTOR->vxsat = 1;
+  } else if (result > int_max) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclip_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vv.h
new file mode 100644
index 000000000000..608a1e7bdbaf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vv.h
@@ -0,0 +1,31 @@
+// vnclip: *vd[i] = clip(round(vs2[i] + rnd) >> vs1[i])
+VRM xrm = VECTOR->vxrm;
+int64_t int_max = (1 << (VECTOR->vsew - 1)) - 1;
+int64_t int_min = -(1 << (VECTOR->vsew - 1));
+VI_VVXI_LOOP_NARROW
+({
+
+  int64_t result = vs2;
+  uint64_t unsigned_shift_amount;
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+// unsigned shifting to rs1
+  unsigned_shift_amount = (uint64_t)(vs1 & ((sew * 2) - 1));
+  if (unsigned_shift_amount >= (2 * sew)) {
+    unsigned_shift_amount = 2 * sew - 1;
+  }
+
+  result = (vsext(result, sew * 2)) >> unsigned_shift_amount;
+
+// saturation
+  if (result < int_min) {
+    result = int_min;
+    VECTOR->vxsat = 1;
+  } else if (result > int_max) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclip_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vx.h
new file mode 100644
index 000000000000..373d9758fc21
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclip_vx.h
@@ -0,0 +1,30 @@
+// vnclip: *vd[i] = clip(round(vs2[i] + rnd) >> rs1[i])
+VRM xrm = VECTOR->vxrm;
+int64_t int_max = (1 << (VECTOR->vsew - 1)) - 1;
+int64_t int_min = -(1 << (VECTOR->vsew - 1));
+VI_VVXI_LOOP_NARROW
+({
+
+  int64_t result = vs2;
+  uint64_t unsigned_shift_amount;
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+// unsigned shifting to rs1
+  unsigned_shift_amount = (uint64_t)(rs1 & ((sew * 2) - 1));
+  if (unsigned_shift_amount >= (2 * sew)) {
+    unsigned_shift_amount = 2 * sew - 1;
+  }
+  result = vsext(result, sew * 2) >> unsigned_shift_amount;
+
+// saturation
+  if (result < int_min) {
+    result = int_min;
+    VECTOR->vxsat = 1;
+  } else if (result > int_max) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vi.h
new file mode 100644
index 000000000000..5c66ad82ca82
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vi.h
@@ -0,0 +1,20 @@
+// vnclipu: *vd[i] = clip(round(vs2[i] + rnd) >> simm)
+VRM xrm = VECTOR->vxrm;
+uint64_t int_max = ~(-1ll << VECTOR->vsew);
+VI_VVXI_LOOP_NARROW
+({
+  uint64_t result = vs2_u;
+  // rounding
+  INT_ROUNDING(result, xrm, sew);
+
+  // unsigned shifting to rs1
+  result = vzext(result, sew * 2) >> (zimm5 & ((sew * 2) < 32? (sew * 2) - 1: 31));
+
+  // saturation
+  if (result & (uint64_t)(-1ll << sew)) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vv.h
new file mode 100644
index 000000000000..a37bb76ea722
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vv.h
@@ -0,0 +1,27 @@
+// vnclipu: *vd[i] = clip(round(vs2[i] + rnd) >> vs1[i])
+VRM xrm = VECTOR->vxrm;
+uint64_t int_max = ~(-1ll << VECTOR->vsew);
+VI_VVXI_LOOP_NARROW
+({
+
+  uint64_t result = vs2_u;
+  uint64_t unsigned_shift_amount;
+
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+// unsigned shifting to rs1
+  unsigned_shift_amount = (uint64_t)(vs1 & ((sew * 2) - 1));
+  if (unsigned_shift_amount >= (2 * sew)) {
+    result = 0;
+  } else {
+    result = vzext(result, sew * 2) >> unsigned_shift_amount;
+  }
+// saturation
+  if (result & (uint64_t)(-1ll << sew)) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vx.h
new file mode 100644
index 000000000000..f20b5e827a1a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnclipu_vx.h
@@ -0,0 +1,26 @@
+// vnclipu: *vd[i] = clip(round(vs2[i] + rnd) >> rs1[i])
+VRM xrm = VECTOR->vxrm;
+uint64_t int_max = ~(-1ll << VECTOR->vsew);
+VI_VVXI_LOOP_NARROW
+({
+  uint64_t result = vs2;
+  uint64_t unsigned_shift_amount;
+// rounding
+  INT_ROUNDING(result, xrm, sew);
+
+// unsigned shifting to rs1
+  unsigned_shift_amount = (uint64_t)(rs1 & ((sew * 2) - 1));
+  if (unsigned_shift_amount >= (2 * sew)) {
+    result = 0;
+  } else {
+    result = vzext(result, sew * 2) >> unsigned_shift_amount;
+  }
+
+// saturation
+  if (result & (uint64_t)(-1ll << sew)) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  }
+
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vv.h
new file mode 100644
index 000000000000..d21493dfe8e6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vv.h
@@ -0,0 +1,5 @@
+// vmsac.vv: *vd[i] = -(vs1[i] * vs2[i]) + *vd[i]
+VI_VV_LOOP
+({
+  *vd =-(vs1 * vs2) + *vd;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vx.h
new file mode 100644
index 000000000000..9cc6ab4d279a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnmsac_vx.h
@@ -0,0 +1,5 @@
+// vmsac: *vd[i] = -(x[rs1] * vs2[i]) + *vd[i]
+VI_VX_LOOP
+({
+  *vd =-(rs1 * vs2) + *vd;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vv.h
new file mode 100644
index 000000000000..4447ef4b8628
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vv.h
@@ -0,0 +1,5 @@
+// vnmsub.vv: *vd[i] = -(*vd[i] * vs1[i]) + vs2[i]
+VI_VV_LOOP
+({
+  *vd =-(*vd * vs1) + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vx.h
new file mode 100644
index 000000000000..24f4bff0ca88
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnmsub_vx.h
@@ -0,0 +1,5 @@
+// vnmsub.vx: *vd[i] = -(*vd[i] * x[rs1]) + vs2[i]
+VI_VX_LOOP
+({
+  *vd =-(*vd * rs1) + vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsra_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vi.h
new file mode 100644
index 000000000000..04b2da18c71e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vi.h
@@ -0,0 +1,5 @@
+// vnsra.vi *vd, vs2, zimm5
+VI_VI_LOOP_NSHIFT
+({
+  *vd =vs2 >> (zimm5 & (sew * 2 - 1) & 0x1f);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsra_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vv.h
new file mode 100644
index 000000000000..004e8a2ba0e3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vv.h
@@ -0,0 +1,5 @@
+// vnsra.vv *vd, vs2, vs1
+VI_VV_LOOP_NSHIFT
+({
+  *vd =vs2 >> (vs1 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsra_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vx.h
new file mode 100644
index 000000000000..a72b3f261a27
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsra_vx.h
@@ -0,0 +1,5 @@
+// vnsra.vx *vd, vs2, rs1
+VI_VX_LOOP_NSHIFT
+({
+  *vd =vs2 >> (rs1 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vi.h
new file mode 100644
index 000000000000..53a98d071bf6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vi.h
@@ -0,0 +1,5 @@
+// vnsrl.vi *vd, vs2, zimm5
+VI_VI_LOOP_NSHIFT
+({
+  *vd =vs2_u >> (zimm5 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vv.h
new file mode 100644
index 000000000000..440d497748f4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vv.h
@@ -0,0 +1,5 @@
+// vnsrl.vv *vd, vs2, vs1
+VI_VV_LOOP_NSHIFT
+({
+  *vd =vs2_u >> (vs1 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vx.h
new file mode 100644
index 000000000000..4c5d415f4fa5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vnsrl_vx.h
@@ -0,0 +1,5 @@
+// vnsrl.vx *vd, vs2, rs1
+VI_VX_LOOP_NSHIFT
+({
+  *vd =vs2_u >> (rs1 & (sew * 2 - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vor_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vor_vi.h
new file mode 100644
index 000000000000..858773291a19
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vor_vi.h
@@ -0,0 +1,5 @@
+// vor
+VI_VI_LOOP
+({
+  *vd =simm5 | vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vor_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vor_vv.h
new file mode 100644
index 000000000000..5d017034264b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vor_vv.h
@@ -0,0 +1,5 @@
+// vor
+VI_VV_LOOP
+({
+  *vd =vs1 | vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vor_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vor_vx.h
new file mode 100644
index 000000000000..e18b293bdb9d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vor_vx.h
@@ -0,0 +1,5 @@
+// vor
+VI_VX_LOOP
+({
+  *vd =rs1 | vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredand_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredand_vs.h
new file mode 100644
index 000000000000..5b32d07bb4b3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredand_vs.h
@@ -0,0 +1,5 @@
+// vredand.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res &= vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredmax_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredmax_vs.h
new file mode 100644
index 000000000000..ae2d43c08953
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredmax_vs.h
@@ -0,0 +1,5 @@
+// vredmax.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res = (vd_0_res >= vs2) ? vd_0_res : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredmaxu_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredmaxu_vs.h
new file mode 100644
index 000000000000..41296e25e36f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredmaxu_vs.h
@@ -0,0 +1,5 @@
+// vredmaxu.vs *vd, vs2 ,vs1
+VI_VV_ULOOP_REDUCTION
+({
+  vd_0_res = (vd_0_res >= vs2) ? vd_0_res : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredmin_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredmin_vs.h
new file mode 100644
index 000000000000..822e20bc1905
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredmin_vs.h
@@ -0,0 +1,5 @@
+// vredmin.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res = (vd_0_res <= vs2) ? vd_0_res : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredminu_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredminu_vs.h
new file mode 100644
index 000000000000..99c71ddbad80
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredminu_vs.h
@@ -0,0 +1,5 @@
+// vredminu.vs *vd, vs2 ,vs1
+VI_VV_ULOOP_REDUCTION
+({
+  vd_0_res = (vd_0_res <= vs2) ? vd_0_res : vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredor_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredor_vs.h
new file mode 100644
index 000000000000..8176e7c468fd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredor_vs.h
@@ -0,0 +1,5 @@
+// vredor.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res |= vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredsum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredsum_vs.h
new file mode 100644
index 000000000000..88418a57eddb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredsum_vs.h
@@ -0,0 +1,5 @@
+// vredsum.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res += vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vredxor_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vredxor_vs.h
new file mode 100644
index 000000000000..15112092ae1e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vredxor_vs.h
@@ -0,0 +1,5 @@
+// vredxor.vs *vd, vs2 ,vs1
+VI_VV_LOOP_REDUCTION
+({
+  vd_0_res ^= vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrem_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vrem_vv.h
new file mode 100644
index 000000000000..f277b32c4d3c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrem_vv.h
@@ -0,0 +1,11 @@
+// vrem.vv *vd, vs2, vs1
+VI_VV_LOOP
+({
+  if (vs1 == 0)
+    *vd =vs2;
+  else if(vs2 == -(1 << (sew - 1)) && vs1 == -1)
+    *vd =0;
+  else {
+    *vd =vs2 % vs1;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrem_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vrem_vx.h
new file mode 100644
index 000000000000..7b059ff43507
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrem_vx.h
@@ -0,0 +1,10 @@
+// vrem.vx *vd, vs2, rs1
+VI_VX_LOOP
+({
+  if (rs1 == 0)
+    *vd =vs2;
+  else if (vs2 == -(1 << (sew - 1)) && rs1 == -1)
+    *vd =0;
+  else
+    *vd =vs2 % rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vremu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vremu_vv.h
new file mode 100644
index 000000000000..dd93a9baa4fe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vremu_vv.h
@@ -0,0 +1,8 @@
+// vremu.vv *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  if (vs1 == 0)
+    *vd =vs2;
+  else
+    *vd =vs2 % vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vremu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vremu_vx.h
new file mode 100644
index 000000000000..2373d0c6e4a0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vremu_vx.h
@@ -0,0 +1,8 @@
+// vremu.vx *vd, vs2, rs1
+VI_VX_ULOOP
+({
+  if (rs1 == 0)
+    *vd =vs2;
+  else
+    *vd =vs2 % rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrgather_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vi.h
new file mode 100644
index 000000000000..2216a32bbdeb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vi.h
@@ -0,0 +1,32 @@
+// vrgather.vi *vd, vs2, zimm5 vm # *vd[i] = (zimm5 >= VLMAX) ? 0 : vs2[zimm5];
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+reg_t zimm5 = v_zimm5(insn);
+reg_t i;
+for (i = VECTOR->vstart; i < vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP();
+
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = zimm5 >= VECTOR->vlmax ? 0 : *vector_elt_uint8_t(VECTOR, rs2_num, zimm5);
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = zimm5 >= VECTOR->vlmax ? 0 : *vector_elt_uint16_t(VECTOR, rs2_num, zimm5);
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = zimm5 >= VECTOR->vlmax ? 0 : *vector_elt_uint32_t(VECTOR, rs2_num, zimm5);
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = zimm5 >= VECTOR->vlmax ? 0 : *vector_elt_uint64_t(VECTOR, rs2_num, zimm5);
+    break;
+  }
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrgather_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vv.h
new file mode 100644
index 000000000000..963d1d4319f0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vv.h
@@ -0,0 +1,42 @@
+// vrgather.vv *vd, vs2, vs1, vm # *vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+reg_t rs1_num = insn_rs1(insn);
+reg_t rs2_num = rs2(insn);
+reg_t i;
+for (i = VECTOR->vstart; i < vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP();
+  VI_CHECK_VREG_OVERLAP(rd_num, rs1_num);
+  VI_CHECK_VREG_OVERLAP(rd_num, rs2_num);
+  switch (sew) {
+  case e8: {
+    uint8_t vs1 = *vector_elt_uint8_t(VECTOR, rs1_num, i);
+    //if (i > 255) continue;
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = vs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint8_t(VECTOR, rs2_num, vs1);
+    break;
+  }
+  case e16: {
+    uint16_t vs1 = *vector_elt_uint16_t(VECTOR, rs1_num, i);
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = vs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint16_t(VECTOR, rs2_num, vs1);
+    break;
+  }
+  case e32: {
+    uint32_t vs1 = *vector_elt_uint32_t(VECTOR, rs1_num, i);
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = vs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint32_t(VECTOR, rs2_num, vs1);
+    break;
+  }
+  default: {
+    uint64_t vs1 = *vector_elt_uint64_t(VECTOR, rs1_num, i);
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = vs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint64_t(VECTOR, rs2_num, vs1);
+    break;
+  }
+  }
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrgather_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vx.h
new file mode 100644
index 000000000000..e0a9af346fdd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrgather_vx.h
@@ -0,0 +1,32 @@
+// vrgather.vx *vd, vs2, rs1, vm # *vd[i] = (rs1 >= VLMAX) ? 0 : vs2[rs1];
+require(VECTOR->vsew >= e8 && VECTOR->vsew <= e64);
+require(!VECTOR->vill);
+{
+reg_t vl = VECTOR->vl;
+reg_t sew = VECTOR->vsew;
+reg_t rd_num = rd(insn);
+reg_t rs2_num = rs2(insn);
+reg_t rs1 = RS1;
+reg_t i;
+for (i = VECTOR->vstart; i < vl; ++i) {
+  VI_LOOP_ELEMENT_SKIP();
+
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, i) = rs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint8_t(VECTOR, rs2_num, rs1);
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = rs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint16_t(VECTOR, rs2_num, rs1);
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = rs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint32_t(VECTOR, rs2_num, rs1);
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = rs1 >= VECTOR->vlmax ? 0 : *vector_elt_uint64_t(VECTOR, rs2_num, rs1);
+    break;
+  }
+}
+
+VI_TAIL_ZERO(1);
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrsub_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vrsub_vi.h
new file mode 100644
index 000000000000..d82cc683911f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrsub_vi.h
@@ -0,0 +1,5 @@
+// vrsub.vi *vd, vs2, imm, vm   # *vd[i] = imm - vs2[i]
+VI_VI_LOOP
+({
+  *vd =simm5 - vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vrsub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vrsub_vx.h
new file mode 100644
index 000000000000..d4a98f92ccaf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vrsub_vx.h
@@ -0,0 +1,5 @@
+// vrsub.vx *vd, vs2, rs1, vm   # *vd[i] = rs1 - vs2[i]
+VI_VX_LOOP
+({
+  *vd =rs1 - vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsadd_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vi.h
new file mode 100644
index 000000000000..d8165ca1a496
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vi.h
@@ -0,0 +1,29 @@
+// vsadd.vi *vd, vs2 simm5
+VI_LOOP_BASE
+{
+bool sat = false;
+switch(sew) {
+case e8: {
+  VI_PARAMS(8);
+  *vd =sat_add_int8_t_uint8_t(vs2, vsext(simm5, sew), &sat);
+  break;
+}
+case e16: {
+  VI_PARAMS(16);
+  *vd =sat_add_int16_t_uint16_t(vs2, vsext(simm5, sew), &sat);
+  break;
+}
+case e32: {
+  VI_PARAMS(32);
+  *vd =sat_add_int32_t_uint32_t(vs2, vsext(simm5, sew), &sat);
+  break;
+}
+default: {
+  VI_PARAMS(64);
+  *vd =sat_add_int64_t_uint64_t(vs2, vsext(simm5, sew), &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vv.h
new file mode 100644
index 000000000000..51ff440ca153
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vv.h
@@ -0,0 +1,30 @@
+// vsadd.vv *vd, vs2, vs1
+VI_LOOP_BASE
+{
+bool sat = false;
+switch(sew) {
+case e8: {
+  VV_PARAMS(8);
+  *vd =sat_add_int8_t_uint8_t(vs2, vs1, &sat);
+  break;
+}
+case e16: {
+  VV_PARAMS(16);
+  *vd =sat_add_int16_t_uint16_t(vs2, vs1, &sat);
+  break;
+}
+case e32: {
+  VV_PARAMS(32);
+  *vd =sat_add_int32_t_uint32_t(vs2, vs1, &sat);
+  break;
+}
+default: {
+  VV_PARAMS(64);
+  *vd =sat_add_int64_t_uint64_t(vs2, vs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vx.h
new file mode 100644
index 000000000000..df122a008063
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsadd_vx.h
@@ -0,0 +1,29 @@
+// vsadd.vx *vd, vs2, rs1
+VI_LOOP_BASE
+{
+bool sat = false;
+switch(sew) {
+case e8: {
+  VX_PARAMS(8);
+  *vd =sat_add_int8_t_uint8_t(vs2, rs1, &sat);
+  break;
+}
+case e16: {
+  VX_PARAMS(16);
+  *vd =sat_add_int16_t_uint16_t(vs2, rs1, &sat);
+  break;
+}
+case e32: {
+  VX_PARAMS(32);
+  *vd =sat_add_int32_t_uint32_t(vs2, rs1, &sat);
+  break;
+}
+default: {
+  VX_PARAMS(64);
+  *vd =sat_add_int64_t_uint64_t(vs2, rs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vi.h
new file mode 100644
index 000000000000..c389f83337f4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vi.h
@@ -0,0 +1,11 @@
+// vsaddu *vd, vs2, zimm5
+VI_VI_ULOOP
+({
+  bool sat = false;
+  *vd =vs2 + simm5;
+
+  sat = *vd < vs2;
+  *vd |= -(*vd < vs2);
+
+  VECTOR->vxsat |= sat;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vv.h
new file mode 100644
index 000000000000..dff560088be2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vv.h
@@ -0,0 +1,11 @@
+// vsaddu *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  bool sat = false;
+  *vd =vs2 + vs1;
+
+  sat = *vd < vs2;
+  *vd |= -(*vd < vs2);
+
+  VECTOR->vxsat |= sat;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vx.h
new file mode 100644
index 000000000000..27bcb286f3dc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsaddu_vx.h
@@ -0,0 +1,12 @@
+// vsaddu *vd, vs2, rs1
+VI_VX_ULOOP
+({
+  bool sat = false;
+  *vd =vs2 + rs1;
+
+  sat = *vd < vs2;
+  *vd |= -(*vd < vs2);
+
+  VECTOR->vxsat |= sat;
+
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsb_v.h
new file mode 100644
index 000000000000..8e6bc0782668
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsb_v.h
@@ -0,0 +1,5 @@
+// vsb.v and vsseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_ST(0, i * nf + fn, uint8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsbc_vvm.h b/arch/riscv/kernel/soft_vector/insns_func/vsbc_vvm.h
new file mode 100644
index 000000000000..9eaacc05aff0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsbc_vvm.h
@@ -0,0 +1,11 @@
+// vsbc.vvm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VV_LOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs2) - (op_mask & vs1) - carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsbc_vxm.h b/arch/riscv/kernel/soft_vector/insns_func/vsbc_vxm.h
new file mode 100644
index 000000000000..4f947e7ba290
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsbc_vxm.h
@@ -0,0 +1,11 @@
+// vsbc.vxm *vd, vs2, rs1
+require(!(rd(insn) == 0 && VECTOR->vlmul > 1));
+VI_VX_ULOOP
+({
+  uint64_t v0 = *vector_elt_uint64_t(VECTOR, 0, midx);
+  const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
+  uint64_t carry = (v0 >> mpos) & 0x1;
+
+  uint128_t res = (op_mask & vs2) - (op_mask & rs1) - carry;
+  *vd =res;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vse_v.h b/arch/riscv/kernel/soft_vector/insns_func/vse_v.h
new file mode 100644
index 000000000000..5d9c4076480f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vse_v.h
@@ -0,0 +1,13 @@
+// vsw.v and vsseg[2-8]w.v
+reg_t sew = VECTOR->vsew;
+
+if (sew == e8) {
+  VI_ST(0, (i * nf + fn), uint8, 1);
+} else if (sew == e16) {
+  VI_ST(0, (i * nf + fn), uint16, 2);
+} else if (sew == e32) {
+  VI_ST(0, (i * nf + fn), uint32, 4);
+} else if (sew == e64) {
+  VI_ST(0, (i * nf + fn), uint64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsetvl.h b/arch/riscv/kernel/soft_vector/insns_func/vsetvl.h
new file mode 100644
index 000000000000..6ba3d2f1fe9f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsetvl.h
@@ -0,0 +1 @@
+WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, RS2));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsetvli.h b/arch/riscv/kernel/soft_vector/insns_func/vsetvli.h
new file mode 100644
index 000000000000..07148dc46360
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsetvli.h
@@ -0,0 +1 @@
+WRITE_RD(set_vl(VECTOR, insn_rs1(insn), RS1, v_zimm11(insn)));
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsh_v.h
new file mode 100644
index 000000000000..19b04511b243
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsh_v.h
@@ -0,0 +1,5 @@
+// vsh.v and vsseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_ST(0, i * nf + fn, uint16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslide1down_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vslide1down_vx.h
new file mode 100644
index 000000000000..1ce25f3c165d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslide1down_vx.h
@@ -0,0 +1,42 @@
+//vslide1down.vx *vd, vs2, rs1
+VI_LOOP_BASE
+if (i != vl - 1) {
+  switch (sew) {
+  case e8: {
+    VI_XI_SLIDEDOWN_PARAMS(8, 1);
+    *vd =vs2;
+  }
+  break;
+  case e16: {
+    VI_XI_SLIDEDOWN_PARAMS(16, 1);
+    *vd =vs2;
+  }
+  break;
+  case e32: {
+    VI_XI_SLIDEDOWN_PARAMS(32, 1);
+    *vd =vs2;
+  }
+  break;
+  default: {
+    VI_XI_SLIDEDOWN_PARAMS(64, 1);
+    *vd =vs2;
+  }
+  break;
+  }
+} else {
+  switch (sew) {
+  case e8:
+    *vector_elt_uint8_t(VECTOR, rd_num, vl - 1) = RS1;
+    break;
+  case e16:
+    *vector_elt_uint16_t(VECTOR, rd_num, vl - 1) = RS1;
+    break;
+  case e32:
+    *vector_elt_uint32_t(VECTOR, rd_num, vl - 1) = RS1;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, vl - 1) = RS1;
+    break;
+  }
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslide1up_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vslide1up_vx.h
new file mode 100644
index 000000000000..8857ff94cd6c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslide1up_vx.h
@@ -0,0 +1,34 @@
+//vslide1up.vx *vd, vs2, rs1
+if (v_vm(insn) == 0)
+  require(rd(insn) != 0);
+
+VI_CHECK_SS
+{
+VI_LOOP_BASE
+if (i != 0) {
+  if (sew == e8) {
+    VI_XI_SLIDEUP_PARAMS(8, 1);
+    *vd =vs2;
+  } else if(sew == e16) {
+    VI_XI_SLIDEUP_PARAMS(16, 1);
+    *vd =vs2;
+  } else if(sew == e32) {
+    VI_XI_SLIDEUP_PARAMS(32, 1);
+    *vd =vs2;
+  } else if(sew == e64) {
+    VI_XI_SLIDEUP_PARAMS(64, 1);
+    *vd =vs2;
+  }
+} else {
+  if (sew == e8) {
+    *vector_elt_uint8_t(VECTOR, rd_num, 0) = RS1;
+  } else if(sew == e16) {
+    *vector_elt_uint16_t(VECTOR, rd_num, 0) = RS1;
+  } else if(sew == e32) {
+    *vector_elt_uint32_t(VECTOR, rd_num, 0) = RS1;
+  } else if(sew == e64) {
+    *vector_elt_uint64_t(VECTOR, rd_num, 0) = RS1;
+  }
+}
+VI_LOOP_END
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vi.h
new file mode 100644
index 000000000000..b4da0c5ac2f6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vi.h
@@ -0,0 +1,35 @@
+// vslidedown.vi *vd, vs2, rs1
+VI_LOOP_BASE
+{
+const reg_t sh = v_zimm5(insn);
+bool is_valid = (i + sh) < VECTOR->vlmax;
+reg_t offset = 0;
+
+if (is_valid) {
+  offset = sh;
+}
+
+switch (sew) {
+case e8: {
+  VI_XI_SLIDEDOWN_PARAMS(8, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+case e16: {
+  VI_XI_SLIDEDOWN_PARAMS(16, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+case e32: {
+  VI_XI_SLIDEDOWN_PARAMS(32, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+default: {
+  VI_XI_SLIDEDOWN_PARAMS(64, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vx.h
new file mode 100644
index 000000000000..3785aa1d1914
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslidedown_vx.h
@@ -0,0 +1,34 @@
+//vslidedown.vx *vd, vs2, rs1
+VI_LOOP_BASE
+{
+reg_t offset = RS1 == (reg_t)-1 ? ((RS1 & (VECTOR->vlmax * 2 - 1)) + i) : RS1;
+bool is_valid = offset < VECTOR->vlmax;
+
+if (!is_valid) {
+  offset = 0;
+}
+
+switch (sew) {
+case e8: {
+  VI_XI_SLIDEDOWN_PARAMS(8, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+case e16: {
+  VI_XI_SLIDEDOWN_PARAMS(16, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+case e32: {
+  VI_XI_SLIDEDOWN_PARAMS(32, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+default: {
+  VI_XI_SLIDEDOWN_PARAMS(64, offset);
+  *vd =is_valid ? vs2 : 0;
+}
+break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslideup_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vslideup_vi.h
new file mode 100644
index 000000000000..c18351ae1ba6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslideup_vi.h
@@ -0,0 +1,37 @@
+// vslideup.vi *vd, vs2, rs1
+if (v_vm(insn) == 0)
+  require(rd(insn) != 0);
+
+VI_CHECK_SS
+{
+VI_LOOP_BASE
+{
+const reg_t offset = v_zimm5(insn);
+if (VECTOR->vstart < offset && i < offset)
+  continue;
+
+switch (sew) {
+case e8: {
+  VI_XI_SLIDEUP_PARAMS(8, offset);
+  *vd =vs2;
+}
+break;
+case e16: {
+  VI_XI_SLIDEUP_PARAMS(16, offset);
+  *vd =vs2;
+}
+break;
+case e32: {
+  VI_XI_SLIDEUP_PARAMS(32, offset);
+  *vd =vs2;
+}
+break;
+default: {
+  VI_XI_SLIDEUP_PARAMS(64, offset);
+  *vd =vs2;
+}
+break;
+}
+}
+VI_LOOP_END
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vslideup_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vslideup_vx.h
new file mode 100644
index 000000000000..0f9a6300c312
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vslideup_vx.h
@@ -0,0 +1,32 @@
+//vslideup.vx *vd, vs2, rs1
+
+VI_LOOP_BASE
+{
+const reg_t offset = RS1;
+if (VECTOR->vstart < offset && i < offset)
+  continue;
+
+switch (sew) {
+case e8: {
+  VI_XI_SLIDEUP_PARAMS(8, offset);
+  *vd =vs2;
+}
+break;
+case e16: {
+  VI_XI_SLIDEUP_PARAMS(16, offset);
+  *vd =vs2;
+}
+break;
+case e32: {
+  VI_XI_SLIDEUP_PARAMS(32, offset);
+  *vd =vs2;
+}
+break;
+default: {
+  VI_XI_SLIDEUP_PARAMS(64, offset);
+  *vd =vs2;
+}
+break;
+}
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsll_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsll_vi.h
new file mode 100644
index 000000000000..18a809f5305b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsll_vi.h
@@ -0,0 +1,5 @@
+// vsll.vi  *vd, vs2, zimm5
+VI_VI_LOOP
+({
+  *vd =vs2 << (simm5 & (sew - 1) & 0x1f);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsll_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsll_vv.h
new file mode 100644
index 000000000000..dc575f02a17e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsll_vv.h
@@ -0,0 +1,5 @@
+// vsll
+VI_VV_LOOP
+({
+  *vd =vs2 << (vs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsll_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsll_vx.h
new file mode 100644
index 000000000000..431c04b4ff0a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsll_vx.h
@@ -0,0 +1,5 @@
+// vsll
+VI_VX_LOOP
+({
+  *vd =vs2 << (rs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsmul_vv.h
new file mode 100644
index 000000000000..9891cafe3354
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsmul_vv.h
@@ -0,0 +1,33 @@
+// vsmul: Signed saturating and rounding fractional multiply
+VRM xrm = VECTOR->vxrm;
+uint64_t int_max = (1ul << (VECTOR->vsew - 1)) - 1;
+uint64_t int_min = - (1 << (VECTOR->vsew - 1));
+uint64_t sign_mask = ((1ul << (VECTOR->vsew - 1)));
+
+VI_VV_ULOOP
+({
+  uint64_t vs1_sign;
+  uint64_t vs2_sign;
+  uint64_t result_sign;
+
+  bool overflow = vs1 == vs2 && vs1 == int_min;
+
+  uint128_t result = (int128_t)(int64_t)vs1 * (int128_t)(int64_t)vs2;
+  //result &= ((uint128_t)1llu << ((sew * 2) - 2)) - 1;
+  vs1_sign = vs1 & sign_mask;
+  vs2_sign = vs2 & sign_mask;
+  result_sign = (vs1_sign ^ vs2_sign) & sign_mask;
+  // rounding
+  INT_ROUNDING(result, xrm, sew - 1);
+  // unsigned shifting
+  result = result >> (sew - 1);
+
+  // saturation
+  if (overflow) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  } else {
+    //result |= result_sign;
+  }
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsmul_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsmul_vx.h
new file mode 100644
index 000000000000..3a499ea863e2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsmul_vx.h
@@ -0,0 +1,33 @@
+// vsmul
+VRM xrm = VECTOR->vxrm;
+int64_t int_max = (1ul << (VECTOR->vsew - 1)) - 1;
+int64_t int_min = - (1 << (VECTOR->vsew - 1));
+int64_t sign_mask = ((1ul << (VECTOR->vsew - 1)));
+
+VI_VX_ULOOP
+({
+  int64_t rs1_sign;
+  int64_t vs2_sign;
+  int64_t result_sign;
+
+  bool overflow = rs1 == vs2 && rs1 == int_min;
+
+  uint128_t result = (int128_t)(int64_t)rs1 * (int128_t)(int64_t)vs2;
+  //result &= ((uint128_t)1llu << ((sew * 2) - 2)) - 1;
+  rs1_sign = rs1 & sign_mask;
+  vs2_sign = vs2 & sign_mask;
+  result_sign = (rs1_sign ^ vs2_sign) & sign_mask;
+  // rounding
+  INT_ROUNDING(result, xrm, sew - 1);
+  // unsigned shifting
+  result = result >> (sew - 1);
+
+  // saturation
+  if (overflow) {
+    result = int_max;
+    VECTOR->vxsat = 1;
+  } else {
+    //result |= result_sign;
+  }
+  *vd =result;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsra_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsra_vi.h
new file mode 100644
index 000000000000..1bac96faef1d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsra_vi.h
@@ -0,0 +1,5 @@
+// vsra.vi *vd, vs2, zimm5
+VI_VI_LOOP
+({
+  *vd =vs2 >> (simm5 & (sew - 1) & 0x1f);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsra_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsra_vv.h
new file mode 100644
index 000000000000..b35bce32296d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsra_vv.h
@@ -0,0 +1,5 @@
+// vsra.vv  *vd, vs2, vs1
+VI_VV_LOOP
+({
+  *vd =vs2 >> (vs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsra_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsra_vx.h
new file mode 100644
index 000000000000..446154c256b4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsra_vx.h
@@ -0,0 +1,5 @@
+// vsra.vx *vd, vs2, rs1
+VI_VX_LOOP
+({
+  *vd =vs2 >> (rs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsrl_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vi.h
new file mode 100644
index 000000000000..4e020ec14f61
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vi.h
@@ -0,0 +1,5 @@
+// vsrl.vi *vd, vs2, zimm5
+VI_VI_ULOOP
+({
+  *vd =vs2 >> (simm5 & (sew - 1) & 0x1f);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsrl_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vv.h
new file mode 100644
index 000000000000..be2f205e826d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vv.h
@@ -0,0 +1,5 @@
+// vsrl.vv  *vd, vs2, vs1
+VI_VV_ULOOP
+({
+  *vd =vs2 >> (vs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsrl_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vx.h
new file mode 100644
index 000000000000..02fe5ad79d33
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsrl_vx.h
@@ -0,0 +1,5 @@
+// vsrl.vx *vd, vs2, rs1
+VI_VX_ULOOP
+({
+  *vd =vs2 >> (rs1 & (sew - 1));
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vssb_v.h
new file mode 100644
index 000000000000..ee7bab9bd3cf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssb_v.h
@@ -0,0 +1,5 @@
+// vssb.v and vssseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_ST(i * RS2, fn, uint8, 1);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsse_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsse_v.h
new file mode 100644
index 000000000000..3229bcf17e52
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsse_v.h
@@ -0,0 +1,13 @@
+// vsse.v and vssseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+
+if (sew == e8) {
+  VI_ST(i * RS2, fn, uint8, 1);
+} else if (sew == e16) {
+  VI_ST(i * RS2, fn, uint16, 2);
+} else if (sew == e32) {
+  VI_ST(i * RS2, fn, uint32, 4);
+} else if (sew == e64) {
+  VI_ST(i * RS2, fn, uint64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vssh_v.h
new file mode 100644
index 000000000000..e3c3319edbd9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssh_v.h
@@ -0,0 +1,5 @@
+// vssh.v and vssseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_ST(i * RS2, fn, uint16, 2);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssra_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vssra_vi.h
new file mode 100644
index 000000000000..5552af60fac8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssra_vi.h
@@ -0,0 +1,8 @@
+// vssra.vi *vd, vs2, simm5
+VRM xrm = VECTOR->vxrm;
+VI_VI_LOOP
+({
+  int sh = simm5 & (sew - 1) & 0x1f;
+  INT_ROUNDING(vs2, xrm, sh);
+  *vd =vs2 >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssra_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vssra_vv.h
new file mode 100644
index 000000000000..d3847b85d515
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssra_vv.h
@@ -0,0 +1,9 @@
+// vssra.vv *vd, vs2, vs1
+VRM xrm = VECTOR->vxrm;
+VI_VV_LOOP
+({
+  int sh = vs1 & (sew - 1);
+
+  INT_ROUNDING(vs2, xrm, sh);
+  *vd =vs2 >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssra_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vssra_vx.h
new file mode 100644
index 000000000000..877f575aabca
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssra_vx.h
@@ -0,0 +1,9 @@
+// vssra.vx *vd, vs2, rs1
+VRM xrm = VECTOR->vxrm;
+VI_VX_LOOP
+({
+  int sh = rs1 & (sew - 1);
+
+  INT_ROUNDING(vs2, xrm, sh);
+  *vd =vs2 >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssrl_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vi.h
new file mode 100644
index 000000000000..d1644da390a0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vi.h
@@ -0,0 +1,9 @@
+// vssra.vi *vd, vs2, simm5
+VRM xrm = VECTOR->vxrm;
+VI_VI_ULOOP
+({
+  int sh = simm5 & (sew - 1) & 0x1f;
+  uint128_t val = vs2;
+  INT_ROUNDING(val, xrm, sh);
+  *vd = val >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssrl_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vv.h
new file mode 100644
index 000000000000..966e8be63d29
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vv.h
@@ -0,0 +1,10 @@
+// vssrl.vv *vd, vs2, vs1
+VRM xrm = VECTOR->vxrm;
+VI_VV_ULOOP
+({
+  int sh = vs1 & (sew - 1);
+  uint128_t val = vs2;
+
+  INT_ROUNDING(val, xrm, sh);
+  *vd = val >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssrl_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vx.h
new file mode 100644
index 000000000000..693198deba00
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssrl_vx.h
@@ -0,0 +1,10 @@
+// vssrl.vx *vd, vs2, rs1
+VRM xrm = VECTOR->vxrm;
+VI_VX_ULOOP
+({
+  int sh = rs1 & (sew - 1);
+  uint128_t val = vs2;
+
+  INT_ROUNDING(val, xrm, sh);
+  *vd = val >> sh;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vssub_vv.h
new file mode 100644
index 000000000000..19f4bde9d3fa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssub_vv.h
@@ -0,0 +1,30 @@
+// vssub.vv *vd, vs2, vs1
+VI_LOOP_BASE
+{
+bool sat = false;
+
+switch (sew) {
+case e8: {
+  VV_PARAMS(8);
+  *vd =sat_sub_int8_t_uint8_t(vs2, vs1, &sat);
+  break;
+}
+case e16: {
+  VV_PARAMS(16);
+  *vd =sat_sub_int16_t_uint16_t(vs2, vs1, &sat);
+  break;
+}
+case e32: {
+  VV_PARAMS(32);
+  *vd =sat_sub_int32_t_uint32_t(vs2, vs1, &sat);
+  break;
+}
+default: {
+  VV_PARAMS(64);
+  *vd =sat_sub_int64_t_uint64_t(vs2, vs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vssub_vx.h
new file mode 100644
index 000000000000..295b4f2c7c2e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssub_vx.h
@@ -0,0 +1,30 @@
+// vssub.vx *vd, vs2, rs1
+VI_LOOP_BASE
+{
+bool sat = false;
+
+switch (sew) {
+case e8: {
+  VX_PARAMS(8);
+  *vd =sat_sub_int8_t_uint8_t(vs2, rs1, &sat);
+  break;
+}
+case e16: {
+  VX_PARAMS(16);
+  *vd =sat_sub_int16_t_uint16_t(vs2, rs1, &sat);
+  break;
+}
+case e32: {
+  VX_PARAMS(32);
+  *vd =sat_sub_int32_t_uint32_t(vs2, rs1, &sat);
+  break;
+}
+default: {
+  VX_PARAMS(64);
+  *vd =sat_sub_int64_t_uint64_t(vs2, rs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssubu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vssubu_vv.h
new file mode 100644
index 000000000000..636c3f06c313
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssubu_vv.h
@@ -0,0 +1,30 @@
+// vssubu.vv *vd, vs2, vs1
+VI_LOOP_BASE
+{
+bool sat = false;
+
+switch (sew) {
+case e8: {
+  VV_U_PARAMS(8);
+  *vd =sat_subu_uint8_t(vs2, vs1, &sat);
+  break;
+}
+case e16: {
+  VV_U_PARAMS(16);
+  *vd =sat_subu_uint16_t(vs2, vs1, &sat);
+  break;
+}
+case e32: {
+  VV_U_PARAMS(32);
+  *vd =sat_subu_uint32_t(vs2, vs1, &sat);
+  break;
+}
+default: {
+  VV_U_PARAMS(64);
+  *vd =sat_subu_uint64_t(vs2, vs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssubu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vssubu_vx.h
new file mode 100644
index 000000000000..b554349c35f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssubu_vx.h
@@ -0,0 +1,30 @@
+// vssubu.vx *vd, vs2, rs1
+VI_LOOP_BASE
+{
+bool sat = false;
+
+switch (sew) {
+case e8: {
+  VX_U_PARAMS(8);
+  *vd =sat_subu_uint8_t(vs2, rs1, &sat);
+  break;
+}
+case e16: {
+  VX_U_PARAMS(16);
+  *vd =sat_subu_uint16_t(vs2, rs1, &sat);
+  break;
+}
+case e32: {
+  VX_U_PARAMS(32);
+  *vd =sat_subu_uint32_t(vs2, rs1, &sat);
+  break;
+}
+default: {
+  VX_U_PARAMS(64);
+  *vd =sat_subu_uint64_t(vs2, rs1, &sat);
+  break;
+}
+}
+VECTOR->vxsat |= sat;
+}
+VI_LOOP_END
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vssw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vssw_v.h
new file mode 100644
index 000000000000..91ba344baf4a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vssw_v.h
@@ -0,0 +1,5 @@
+// vssw.v and vssseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_ST(i * RS2, fn, uint32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vsub_vv.h
new file mode 100644
index 000000000000..4dd7d183368f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsub_vv.h
@@ -0,0 +1,5 @@
+// vsub
+VI_VV_LOOP
+({
+  *vd =vs2 - vs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vsub_vx.h
new file mode 100644
index 000000000000..187e70203931
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsub_vx.h
@@ -0,0 +1,5 @@
+// vsub: *vd[i] = (*vd[i] * x[rs1]) - vs2[i]
+VI_VX_LOOP
+({
+  *vd =vs2 - rs1;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsuxb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsuxb_v.h
new file mode 100644
index 000000000000..05bab138a4a3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsuxb_v.h
@@ -0,0 +1,36 @@
+// vsuxb.v and vsxseg[2-8]b.v
+reg_t vl = VECTOR->vl;
+reg_t baseAddr = RS1;
+reg_t stride = rs2(insn);
+reg_t vs3 = rd(insn);
+reg_t vlmax = VECTOR->vlmax;
+VI_DUPLICATE_VREG(stride, vlmax);
+require(VECTOR->vsew >= e8);
+for (i = 0; i < vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  VI_STRIP(i)
+  VI_ELEMENT_SKIP(i);
+  switch (VECTOR->vsew) {
+  case e8:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint8_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e16:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint16_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e32:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint32_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e64:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint64_t(VECTOR, vs3, vreg_inx));
+    break;
+  }
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsuxe_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsuxe_v.h
new file mode 100644
index 000000000000..018e058c592f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsuxe_v.h
@@ -0,0 +1,37 @@
+// vsxe.v and vsxseg[2-8]e.v
+const reg_t sew = VECTOR->vsew;
+const reg_t vl = VECTOR->vl;
+reg_t baseAddr = RS1;
+reg_t stride = rs2(insn);
+reg_t vs3 = rd(insn);
+reg_t vlmax = VECTOR->vlmax;
+VI_DUPLICATE_VREG(stride, vlmax);
+require(sew >= e8 && sew <= e64);
+for (i = 0; i < vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  VI_STRIP(i)
+  VI_ELEMENT_SKIP(i);
+  switch (sew) {
+  case e8:
+    if (is_valid)
+      store_uint8(baseAddr + index[i],
+                      *vector_elt_uint8_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e16:
+    if (is_valid)
+      store_uint16(baseAddr + index[i],
+                       *vector_elt_uint16_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e32:
+    if (is_valid)
+      store_uint32(baseAddr + index[i],
+                       *vector_elt_uint32_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e64:
+    if (is_valid)
+      store_uint64(baseAddr + index[i],
+                       *vector_elt_uint64_t(VECTOR, vs3, vreg_inx));
+    break;
+  }
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsuxh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsuxh_v.h
new file mode 100644
index 000000000000..c9d283db4bd3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsuxh_v.h
@@ -0,0 +1,32 @@
+// vsxh.v and vsxseg[2-8]h.v
+reg_t vl = VECTOR->vl;
+reg_t baseAddr = RS1;
+reg_t stride = rs2(insn);
+reg_t vs3 = rd(insn);
+reg_t vlmax = VECTOR->vlmax;
+VI_DUPLICATE_VREG(stride, vlmax);
+require(VECTOR->vsew >= e16);
+for (i = 0; i < vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  VI_STRIP(i)
+  VI_ELEMENT_SKIP(i);
+
+  switch (VECTOR->vsew) {
+  case e16:
+    if (is_valid)
+      store_uint16(baseAddr + index[i],
+                       *vector_elt_uint16_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e32:
+    if (is_valid)
+      store_uint16(baseAddr + index[i],
+                       *vector_elt_uint32_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e64:
+    if (is_valid)
+      store_uint16(baseAddr + index[i],
+                       *vector_elt_uint64_t(VECTOR, vs3, vreg_inx));
+    break;
+  }
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsuxw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsuxw_v.h
new file mode 100644
index 000000000000..7ef7a044db4a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsuxw_v.h
@@ -0,0 +1,26 @@
+// vsxw.v and vsxseg[2-8]w.v
+reg_t vl = VECTOR->vl;
+reg_t baseAddr = RS1;
+reg_t stride = rs2(insn);
+reg_t vs3 = rd(insn);
+reg_t vlmax = VECTOR->vlmax;
+VI_DUPLICATE_VREG(stride, vlmax);
+require(VECTOR->vsew >= e32);
+for (i = 0; i < vlmax && vl != 0; ++i) {
+  bool is_valid = true;
+  VI_STRIP(i)
+  VI_ELEMENT_SKIP(i);
+  switch (VECTOR->vsew) {
+  case e32:
+    if (is_valid)
+      store_uint32(baseAddr + index[i],
+                       *vector_elt_uint32_t(VECTOR, vs3, vreg_inx));
+    break;
+  case e64:
+    if (is_valid)
+      store_uint32(baseAddr + index[i],
+                       *vector_elt_uint64_t(VECTOR, vs3, vreg_inx));
+    break;
+  }
+}
+VECTOR->vstart = 0;
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsw_v.h
new file mode 100644
index 000000000000..976cbfd5a854
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsw_v.h
@@ -0,0 +1,5 @@
+// vsw.v and vsseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_ST(0, i * nf + fn, uint32, 4);
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsxb_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsxb_v.h
new file mode 100644
index 000000000000..5efad746c543
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsxb_v.h
@@ -0,0 +1,8 @@
+// vsxb.v and vsxseg[2-8]b.v
+require(VECTOR->vsew >= e8);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_ST_WITH_I(index[i], fn, uint8, 1);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsxe_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsxe_v.h
new file mode 100644
index 000000000000..b5c0a7f5ce74
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsxe_v.h
@@ -0,0 +1,14 @@
+// vsxe.v and vsxseg[2-8]e.v
+reg_t sew = VECTOR->vsew;
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+require(sew >= e8 && sew <= e64);
+if (sew == e8) {
+  VI_ST_WITH_I(index[i], fn, uint8, 1);
+} else if (sew == e16) {
+  VI_ST_WITH_I(index[i], fn, uint16, 2);
+} else if (sew == e32) {
+  VI_ST_WITH_I(index[i], fn, uint32, 4);
+} else if (sew == e64) {
+  VI_ST_WITH_I(index[i], fn, uint64, 8);
+}
+
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsxh_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsxh_v.h
new file mode 100644
index 000000000000..4ebe0072512c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsxh_v.h
@@ -0,0 +1,8 @@
+// vsxh.v and vsxseg[2-8]h.v
+require(VECTOR->vsew >= e16);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_ST_WITH_I(index[i], fn, uint16, 2);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vsxw_v.h b/arch/riscv/kernel/soft_vector/insns_func/vsxw_v.h
new file mode 100644
index 000000000000..a2aaaa2bff67
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vsxw_v.h
@@ -0,0 +1,8 @@
+// vsxw.v and vsxseg[2-8]w.v
+require(VECTOR->vsew >= e32);
+{
+VI_DUPLICATE_VREG(rs2(insn), VECTOR->vlmax);
+{
+VI_ST_WITH_I(index[i], fn, uint32, 4);
+}
+}
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwadd_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwadd_vv.h
new file mode 100644
index 000000000000..039c43d0b57d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwadd_vv.h
@@ -0,0 +1,6 @@
+// vwadd.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, +, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwadd_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwadd_vx.h
new file mode 100644
index 000000000000..e4bee2590d36
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwadd_vx.h
@@ -0,0 +1,6 @@
+// vwadd.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, +, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwadd_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vwadd_wv.h
new file mode 100644
index 000000000000..45f60ad89cda
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwadd_wv.h
@@ -0,0 +1,6 @@
+// vwadd.wv *vd, vs2, vs1
+VI_CHECK_DDS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(vs1, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwadd_wx.h b/arch/riscv/kernel/soft_vector/insns_func/vwadd_wx.h
new file mode 100644
index 000000000000..921b4ffbf325
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwadd_wx.h
@@ -0,0 +1,6 @@
+// vwaddu.wx *vd, vs2, rs1
+VI_CHECK_DDS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(rs1, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vv.h
new file mode 100644
index 000000000000..da824ba07097
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vv.h
@@ -0,0 +1,6 @@
+// vwaddu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, +, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vx.h
new file mode 100644
index 000000000000..d3574a4a768d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_vx.h
@@ -0,0 +1,6 @@
+// vwaddu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, +, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wv.h
new file mode 100644
index 000000000000..f146a927328b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wv.h
@@ -0,0 +1,6 @@
+// vwaddu.wv *vd, vs2, vs1
+VI_CHECK_DDS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(vs1, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wx.h b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wx.h
new file mode 100644
index 000000000000..4f3df806411f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwaddu_wx.h
@@ -0,0 +1,6 @@
+// vwaddu.wx *vd, vs2, rs1
+VI_CHECK_DDS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(rs1, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vv.h
new file mode 100644
index 000000000000..e085711d4f1b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vv.h
@@ -0,0 +1,6 @@
+// vwmacc.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, vd_w, *, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vx.h
new file mode 100644
index 000000000000..d90066522f55
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmacc_vx.h
@@ -0,0 +1,6 @@
+// vwmacc.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, vd_w, *, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vv.h
new file mode 100644
index 000000000000..f3772ad38cbb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vv.h
@@ -0,0 +1,6 @@
+// vwmaccsu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN_MIX(vs2, vs1, vd_w, *, +, int, uint, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vx.h
new file mode 100644
index 000000000000..23ff0e36dcfb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccsu_vx.h
@@ -0,0 +1,6 @@
+// vwmaccsu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN_MIX(vs2, rs1, vd_w, *, +, int, uint, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vv.h
new file mode 100644
index 000000000000..0a8c68441189
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vv.h
@@ -0,0 +1,6 @@
+// vwmaccu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, vd_w, *, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vx.h
new file mode 100644
index 000000000000..7ccbe00cd2d6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccu_vx.h
@@ -0,0 +1,6 @@
+// vwmaccu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, vd_w, *, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmaccus_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmaccus_vx.h
new file mode 100644
index 000000000000..b397365d73ce
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmaccus_vx.h
@@ -0,0 +1,6 @@
+// vwmaccus.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN_MIX(vs2, rs1, vd_w, *, +, int, int, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmul_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmul_vv.h
new file mode 100644
index 000000000000..d6108263e460
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmul_vv.h
@@ -0,0 +1,6 @@
+// vwmul.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, *, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmul_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmul_vx.h
new file mode 100644
index 000000000000..c3afc255aaac
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmul_vx.h
@@ -0,0 +1,6 @@
+// vwmul.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, *, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vv.h
new file mode 100644
index 000000000000..2e9b36c554f1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vv.h
@@ -0,0 +1,16 @@
+// vwmulsu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  switch(VECTOR->vsew) {
+  case e8:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = (int16_t)(int8_t)vs2 * (int16_t)(uint8_t)vs1;
+    break;
+  case e16:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = (int32_t)(int16_t)vs2 * (int32_t)(uint16_t)vs1;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = (int64_t)(int32_t)vs2 * (int64_t)(uint32_t)vs1;
+    break;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vx.h
new file mode 100644
index 000000000000..752f75e755ce
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmulsu_vx.h
@@ -0,0 +1,16 @@
+// vwmulsu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  switch(VECTOR->vsew) {
+  case e8:
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = (int16_t)(int8_t)vs2 * (int16_t)(uint8_t)rs1;
+    break;
+  case e16:
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = (int32_t)(int16_t)vs2 * (int32_t)(uint16_t)rs1;
+    break;
+  default:
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = (int64_t)(int32_t)vs2 * (int64_t)(uint32_t)rs1;
+    break;
+  }
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vv.h
new file mode 100644
index 000000000000..955e7ed452b4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vv.h
@@ -0,0 +1,6 @@
+// vwmulu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, *, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vx.h
new file mode 100644
index 000000000000..a6cceeadaa5b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwmulu_vx.h
@@ -0,0 +1,6 @@
+// vwmul.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, *, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwredsum_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vwredsum_vs.h
new file mode 100644
index 000000000000..ee023ae21a8b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwredsum_vs.h
@@ -0,0 +1,5 @@
+// vwredsum.vs *vd, vs2, vs1
+VI_VV_LOOP_WIDE_REDUCTION
+({
+  vd_0_res += vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwredsumu_vs.h b/arch/riscv/kernel/soft_vector/insns_func/vwredsumu_vs.h
new file mode 100644
index 000000000000..b73d05661b89
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwredsumu_vs.h
@@ -0,0 +1,5 @@
+// vwredsum.vs *vd, vs2, vs1
+VI_VV_ULOOP_WIDE_REDUCTION
+({
+  vd_0_res += vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vv.h
new file mode 100644
index 000000000000..899beda4f004
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vv.h
@@ -0,0 +1,2 @@
+// vwsmacc.vv *vd, vs2, vs1
+VI_VVX_LOOP_WIDE_SSMA(vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vx.h
new file mode 100644
index 000000000000..d47bae0db748
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmacc_vx.h
@@ -0,0 +1,2 @@
+// vwsmacc.vx *vd, vs2, rs1
+VI_VVX_LOOP_WIDE_SSMA(rs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vv.h
new file mode 100644
index 000000000000..893a19aa949f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vv.h
@@ -0,0 +1,2 @@
+// vwsmaccsu.vx *vd, vs2, vs1
+VI_VVX_LOOP_WIDE_SU_SSMA(vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vx.h
new file mode 100644
index 000000000000..f386e19f2cd9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccsu_vx.h
@@ -0,0 +1,2 @@
+// vwsmaccsu.vx *vd, vs2, rs1
+VI_VVX_LOOP_WIDE_SU_SSMA(rs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vv.h
new file mode 100644
index 000000000000..8153f3227866
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vv.h
@@ -0,0 +1,2 @@
+// vwsmaccu.vv *vd, vs2, vs1
+VI_VVX_LOOP_WIDE_USSMA(vs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vx.h
new file mode 100644
index 000000000000..3b832233ebbb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccu_vx.h
@@ -0,0 +1,2 @@
+// vwsmaccu *vd, vs2, rs1
+VI_VVX_LOOP_WIDE_USSMA(rs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsmaccus_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccus_vx.h
new file mode 100644
index 000000000000..a798f0e4abc5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsmaccus_vx.h
@@ -0,0 +1,2 @@
+// vwsmaccus.vx  *vd, vs2, rs1
+VI_VVX_LOOP_WIDE_US_SSMA(rs1);
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsub_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsub_vv.h
new file mode 100644
index 000000000000..f4f5b290df9a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsub_vv.h
@@ -0,0 +1,6 @@
+// vwsub.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, -, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsub_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsub_vx.h
new file mode 100644
index 000000000000..cc2d5f0659b0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsub_vx.h
@@ -0,0 +1,6 @@
+// vwsub.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, -, +, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsub_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsub_wv.h
new file mode 100644
index 000000000000..072cafcb357b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsub_wv.h
@@ -0,0 +1,6 @@
+// vwsub.wv *vd, vs2, vs1
+VI_CHECK_DDS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(vs1, -, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsub_wx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsub_wx.h
new file mode 100644
index 000000000000..849a051a859c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsub_wx.h
@@ -0,0 +1,6 @@
+// vwsub.wx *vd, vs2, rs1
+VI_CHECK_DDS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(rs1, -, int);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vv.h
new file mode 100644
index 000000000000..4e99fd428824
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vv.h
@@ -0,0 +1,6 @@
+// vwsubu.vv *vd, vs2, vs1
+VI_CHECK_DSS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, vs1, 0, -, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vx.h
new file mode 100644
index 000000000000..a05db3d50f22
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_vx.h
@@ -0,0 +1,6 @@
+// vwsubu.vx *vd, vs2, rs1
+VI_CHECK_DSS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_OP_AND_ASSIGN(vs2, rs1, 0, -, +, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wv.h b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wv.h
new file mode 100644
index 000000000000..0979beeef30d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wv.h
@@ -0,0 +1,6 @@
+// vwsubu.wv *vd, vs2, vs1
+VI_CHECK_DDS(true);
+VI_VV_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(vs1, -, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wx.h b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wx.h
new file mode 100644
index 000000000000..817f4b888f34
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vwsubu_wx.h
@@ -0,0 +1,6 @@
+// vwsubu.wx *vd, vs2, rs1
+VI_CHECK_DDS(false);
+VI_VX_LOOP_WIDEN
+({
+  VI_WIDE_WVX_OP(rs1, -, uint);
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vxor_vi.h b/arch/riscv/kernel/soft_vector/insns_func/vxor_vi.h
new file mode 100644
index 000000000000..bea4263c54e7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vxor_vi.h
@@ -0,0 +1,5 @@
+// vxor
+VI_VI_LOOP
+({
+  *vd =simm5 ^ vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vxor_vv.h b/arch/riscv/kernel/soft_vector/insns_func/vxor_vv.h
new file mode 100644
index 000000000000..b2de0b707e02
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vxor_vv.h
@@ -0,0 +1,5 @@
+// vxor
+VI_VV_LOOP
+({
+  *vd =vs1 ^ vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/insns_func/vxor_vx.h b/arch/riscv/kernel/soft_vector/insns_func/vxor_vx.h
new file mode 100644
index 000000000000..ed3552fb2411
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/insns_func/vxor_vx.h
@@ -0,0 +1,5 @@
+// vxor
+VI_VX_LOOP
+({
+  *vd =rs1 ^ vs2;
+})
diff --git a/arch/riscv/kernel/soft_vector/riscv_decode.h b/arch/riscv/kernel/soft_vector/riscv_decode.h
new file mode 100644
index 000000000000..61eeca6ca55a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/riscv_decode.h
@@ -0,0 +1,1933 @@
+/*============================================================================
+
+Copyright (c) 2010-2017, The Regents of the University of California
+(Regents).  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the Regents nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
+OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+=============================================================================*/
+
+#ifndef _RISCV_DECODE_H
+#define _RISCV_DECODE_H
+
+#if (-1 != ~0) || ((-1 >> 1) != -1)
+# error spike requires a two''s-complement c++ implementation
+#endif
+
+#ifdef WORDS_BIGENDIAN
+# error spike requires a little-endian host
+#endif
+
+#include <asm/string.h>
+#include "encoding.h"
+#include "softfloat/config.h"
+#include "softfloat/softfloat_types.h"
+#include "softfloat/specialize.h"
+#include "arith.h"
+#include "softfloat/stdint.h"
+#include "softfloat/stdbool.h"
+#include "linux/compiler.h"
+typedef enum VRM{
+  RNU = 0,
+  RNE,
+  RDN,
+  ROD,
+  INVALID_RM
+} VRM;
+
+//#define   likely(x) __builtin_expect(x, 1)
+//#define unlikely(x) __builtin_expect(x, 0)
+
+#define NOINLINE __attribute__ ((noinline))
+
+typedef int64_t sreg_t;
+typedef unsigned long reg_t;
+typedef __int128 int128_t;
+typedef unsigned __int128 uint128_t;
+
+#define NXPR 32
+#define NFPR 32
+#define NVPR 32
+#define NCSR 4096
+
+#define X_RA 1
+#define X_SP 2
+
+#define FP_RD_NE  0
+#define FP_RD_0   1
+#define FP_RD_DN  2
+#define FP_RD_UP  3
+#define FP_RD_NMM 4
+
+#define FSR_RD_SHIFT 5
+#define FSR_RD   (0x7 << FSR_RD_SHIFT)
+
+#define FPEXC_NX 0x01
+#define FPEXC_UF 0x02
+#define FPEXC_OF 0x04
+#define FPEXC_DZ 0x08
+#define FPEXC_NV 0x10
+
+#define FSR_AEXC_SHIFT 0
+#define FSR_NVA  (FPEXC_NV << FSR_AEXC_SHIFT)
+#define FSR_OFA  (FPEXC_OF << FSR_AEXC_SHIFT)
+#define FSR_UFA  (FPEXC_UF << FSR_AEXC_SHIFT)
+#define FSR_DZA  (FPEXC_DZ << FSR_AEXC_SHIFT)
+#define FSR_NXA  (FPEXC_NX << FSR_AEXC_SHIFT)
+#define FSR_AEXC (FSR_NVA | FSR_OFA | FSR_UFA | FSR_DZA | FSR_NXA)
+
+#define insn_length(x) 4
+#define MAX_INSN_LENGTH 8
+#define PC_ALIGN 2
+
+#ifndef TAIL_ZEROING
+  #define TAIL_ZEROING true
+#else
+  #define TAIL_ZEROING false
+#endif
+
+typedef struct vector_state {
+    __uint128_t regs[32];
+    reg_t reg_mask, vlmax, vmlen;
+    reg_t vstart, vxrm, vxsat, vl, vtype;
+    reg_t vediv, vsew, vlmul;
+    reg_t ELEN, VLEN, SLEN;
+    bool vill;
+} vector_state;
+
+#define BITS(v, hi, lo) ((v >> lo) & ((2 << (hi - lo)) - 1))
+
+#define trap_illegal_instruction(n) return n;
+#define require(x) if (unlikely(!(x))) trap_illegal_instruction(0)
+
+#define vector_elt(type) \
+        type * vector_elt_##type(vector_state* vector, reg_t vReg, reg_t n);\
+
+vector_elt(float32_t)
+vector_elt(float64_t)
+vector_elt(int8_t)
+vector_elt(int16_t)
+vector_elt(int32_t)
+vector_elt(int64_t)
+vector_elt(uint8_t)
+vector_elt(uint16_t)
+vector_elt(uint32_t)
+vector_elt(uint64_t)
+#undef vector_elt
+
+typedef uint64_t insn_t;
+typedef uint64_t insn_bits_t;
+typedef float128_t freg_t;
+
+//TODO
+#define load_store(type) \
+      type##_t load_##type(reg_t addr);\
+      \
+      void store_##type(reg_t addr, type##_t val);
+      
+load_store(uint8)
+load_store(uint16)
+load_store(uint32)
+load_store(uint64)
+
+load_store(int8)
+load_store(int16)
+load_store(int32)
+load_store(int64)
+#undef load_store
+
+inline int get_max_xlen(void);
+reg_t set_vl(vector_state *vector, uint64_t regId, reg_t reqVL, reg_t newType);
+
+inline uint64_t x(insn_t b, int lo, int len);
+inline uint64_t xs(insn_t b, int lo, int len);
+inline uint64_t imm_sign(insn_t b);
+inline int length(insn_t b);
+inline int64_t i_imm(insn_t b);
+inline int64_t shamt(insn_t b);
+inline int64_t s_imm(insn_t b);
+inline int64_t sb_imm(insn_t b);
+inline int64_t u_imm(insn_t b);
+inline int64_t uj_imm(insn_t b);
+inline uint64_t rd(insn_t b);
+inline uint64_t insn_rs1(insn_t b);
+inline uint64_t rs2(insn_t b);
+inline uint64_t rs3(insn_t b);
+inline uint64_t rm(insn_t b);
+inline uint64_t csr(insn_t b);
+
+inline uint64_t v_vm(insn_t b);
+inline uint64_t v_wd(insn_t b);
+inline uint64_t v_nf(insn_t b);
+inline uint64_t v_simm5(insn_t b);
+inline uint64_t v_zimm5(insn_t b);
+inline uint64_t v_zimm11(insn_t b);
+inline uint64_t v_lmul(insn_t b);
+inline uint64_t v_sew(insn_t b);
+
+typedef struct processor{
+  reg_t XPR[32];
+  freg_t FPR[32];
+  vector_state vector;
+  reg_t saved_a0;
+  reg_t mstatus;
+  reg_t frm;
+  reg_t fflags;
+  reg_t pc;
+} processor_t;
+
+bool supports_extension(processor_t * state, unsigned char ext);
+
+int get_flen(processor_t * state);
+inline int get_xlen(void);
+#define STATE (*p) 
+#define VECTOR (&(p->vector))
+#define FLEN (get_flen(p)) 
+
+#define READ_REG(reg) STATE.XPR[reg]
+#define READ_FREG(reg) STATE.FPR[reg]
+# define WRITE_REG(reg, value) STATE.XPR[reg] = value
+
+#define RD READ_REG(rd(insn))
+#define RS1 READ_REG(insn_rs1(insn))
+#define RS2 READ_REG(rs2(insn))
+#define RS3 READ_REG(rs3(insn))
+#define WRITE_RD(value) WRITE_REG(rd(insn), value)
+
+// FPU macros
+#define FRS1 READ_FREG(insn_rs1(insn))
+#define FRS2 READ_FREG(rs2(insn))
+#define FRS3 READ_FREG(rs3(insn))
+#define dirty_fp_state (STATE.mstatus |= MSTATUS_FS | (xlen == 64 ? MSTATUS64_SD : MSTATUS32_SD))
+#define dirty_ext_state (STATE.mstatus |= MSTATUS_XS | (xlen == 64 ? MSTATUS64_SD : MSTATUS32_SD))
+#define DO_WRITE_FREG(reg, value) (STATE.FPR[reg] = value, dirty_fp_state)
+#define WRITE_FREG(reg, value, len) DO_WRITE_FREG(reg, freg##len(value))
+#define WRITE_FRD(value, len) WRITE_FREG(rd(insn), value, len)
+ 
+#define SHAMT (i_imm(insn) & 0x3F)
+#define RM ({ int rm = rm(insn); \
+              if(rm == 7) rm = STATE.frm; \
+              if(rm > 4) trap_illegal_instruction(0); \
+              rm; })
+
+#define require_rv64 require(xlen == 64)
+#define require_rv32 require(xlen == 32)
+#define require_extension(s) require(supports_extension(p,s))
+#define require_fp require((STATE.mstatus & MSTATUS_FS) != 0)
+#define require_accelerator require((STATE.mstatus & MSTATUS_XS) != 0)
+
+#define set_fp_exceptions ({ if (softfloat_exceptionFlags) { \
+                               dirty_fp_state; \
+                               STATE.fflags |= softfloat_exceptionFlags; \
+                             } \
+                             softfloat_exceptionFlags = 0; })
+
+#define sext32(x) ((sreg_t)(int32_t)(x))
+#define zext32(x) ((reg_t)(uint32_t)(x))
+#define sext_xlen(x) (((sreg_t)(x) << (64-xlen)) >> (64-xlen))
+#define zext_xlen(x) (((reg_t)(x) << (64-xlen)) >> (64-xlen))
+
+/* Convenience wrappers to simplify softfloat code sequences */
+#define isBoxedF32(r) (isBoxedF64(r) && ((uint32_t)((r.v[0] >> 32) + 1) == 0))
+#define unboxF32(r) (isBoxedF32(r) ? (uint32_t)r.v[0] : defaultNaNF32UI)
+#define isBoxedF64(r) ((r.v[1] + 1) == 0)
+#define unboxF64(r) (isBoxedF64(r) ? r.v[0] : defaultNaNF64UI)
+
+inline float32_t f32(uint32_t v);
+inline float64_t f64(uint64_t v);
+inline float32_t f32_f(freg_t r);
+inline float64_t f64_f(freg_t r);
+inline float128_t f128(freg_t r);
+inline freg_t freg32(float32_t f);
+inline freg_t freg64(float64_t f);
+inline freg_t freg128(float128_t f);
+#define F32_SIGN ((uint32_t)1 << 31)
+#define F64_SIGN ((uint64_t)1 << 63)
+#define fsgnj32(a, b, n, x) \
+  f32((f32(a).v & ~F32_SIGN) | ((((x) ? f32(a).v : (n) ? F32_SIGN : 0) ^ f32(b).v) & F32_SIGN))
+#define fsgnj64(a, b, n, x) \
+  f64((f64(a).v & ~F64_SIGN) | ((((x) ? f64(a).v : (n) ? F64_SIGN : 0) ^ f64(b).v) & F64_SIGN))
+
+#define isNaNF128(x) isNaNF128UI(x.v[1], x.v[0])
+inline float128_t defaultNaNF128(void);
+inline freg_t fsgnj128(freg_t a, freg_t b, bool n, bool x);
+inline freg_t f128_negate(freg_t a);
+
+// Vector macros
+#define e8 8      // 8b elements
+#define e16 16    // 16b elements
+#define e32 32    // 32b elements
+#define e64 64    // 64b elements
+#define e128 128  // 128b elements
+
+#define vsext(x, sew) (((sreg_t)(x) << (64-sew)) >> (64-sew))
+#define vzext(x, sew) (((reg_t)(x) << (64-sew)) >> (64-sew))
+
+#define DEBUG_RVV_FP_VV
+#define DEBUG_RVV_FP_VF
+#define DEBUG_RVV_FMA_VV
+#define DEBUG_RVV_FMA_VF
+//
+// vector: masking skip helper
+//
+#define VI_LOOP_ELEMENT_SKIP(BODY) \
+  const int mlen = VECTOR->vmlen; \
+  const int midx = (mlen * i) / 64; \
+  const int mpos = (mlen * i) % 64; \
+  if (v_vm(insn) == 0) { \
+	bool skip; \
+    BODY; \
+    skip = ((*vector_elt_uint64_t(VECTOR, 0, midx) >> mpos) & 0x1) == 0; \
+    if (skip) \
+      continue; \
+  }
+
+#define VI_ELEMENT_SKIP(inx) \
+  if (inx >= vl && TAIL_ZEROING) { \
+    is_valid = false; \
+  } else if (inx >= vl && !TAIL_ZEROING) { \
+    continue; \
+  } else if (inx < VECTOR->vstart) { \
+    continue; \
+  } else { \
+    VI_LOOP_ELEMENT_SKIP(); \
+  }
+
+//
+// vector: operation and register acccess check helper
+//
+inline bool is_overlaped(const int astart, const int asize,
+                                const int bstart, const int bsize);
+
+#define VI_NARROW_CHECK_COMMON \
+  require(VECTOR->vlmul <= 4); \
+  require(VECTOR->vsew * 2 <= VECTOR->ELEN); \
+  require(rs2(insn) + VECTOR->vlmul * 2 <= 32);
+
+#define VI_WIDE_CHECK_COMMON \
+  require(!VECTOR->vill);\
+  require(VECTOR->vlmul <= 4); \
+  require(VECTOR->vsew * 2 <= VECTOR->ELEN); \
+  require(rd(insn) + VECTOR->vlmul * 2 <= 32); \
+  if (v_vm(insn) == 0) \
+    require(rd(insn) != 0);
+
+#define VI_CHECK_VREG_OVERLAP(v1, v2) \
+  require(!is_overlaped(v1, VECTOR->vlmul, v2, VECTOR->vlmul));
+
+#define VI_CHECK_SS \
+  require(!is_overlaped(rd(insn), VECTOR->vlmul, rs2(insn), VECTOR->vlmul));
+
+#define VI_CHECK_SD \
+  require(!is_overlaped(rd(insn), VECTOR->vlmul, rs2(insn), VECTOR->vlmul * 2));
+
+#define VI_CHECK_DSS(is_rs) \
+  VI_WIDE_CHECK_COMMON; \
+  require(!is_overlaped(rd(insn), VECTOR->vlmul * 2, rs2(insn), VECTOR->vlmul)); \
+  if (is_rs) \
+     require(!is_overlaped(rd(insn), VECTOR->vlmul * 2, insn_rs1(insn), VECTOR->vlmul));
+
+#define VI_CHECK_DDS(is_rs) \
+  VI_WIDE_CHECK_COMMON; \
+  require(rs2(insn) + VECTOR->vlmul * 2 <= 32); \
+  if (is_rs) \
+     require(!is_overlaped(rd(insn), VECTOR->vlmul * 2, insn_rs1(insn), VECTOR->vlmul));
+
+//
+// vector: loop header and end helper
+//
+#define VI_GENERAL_LOOP_BASE \
+  reg_t vl, sew, rd_num, rs1_num, rs2_num, i; \
+  require(VECTOR->vsew == e8 || VECTOR->vsew == e16 || VECTOR->vsew == e32 || VECTOR->vsew == e64); \
+  require(!VECTOR->vill);\
+  vl = VECTOR->vl; \
+  sew = VECTOR->vsew; \
+  rd_num = rd(insn); \
+  rs1_num = insn_rs1(insn); \
+  rs2_num = rs2(insn); \
+  for (i=VECTOR->vstart; i<vl; ++i){ 
+
+#define VI_TAIL_ZERO(elm) \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING) { \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((sew >> 3) * elm)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((sew >> 3) * elm)); \
+  }
+
+#define VI_TAIL_ZERO_MASK(dst) \
+  if (vl != 0 && TAIL_ZEROING){ \
+    for (i=vl; i<VECTOR->vlmax; ++i){ \
+      const int mlen = VECTOR->vmlen; \
+      const int midx = (mlen * i) / 64; \
+      const int mpos = (mlen * i) % 64; \
+      uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+      uint64_t *vdi = vector_elt_uint64_t(VECTOR, dst, midx); \
+      *vdi = (*vdi & ~mmask);\
+    }\
+  }\
+
+#define VI_LOOP_BASE \
+    VI_GENERAL_LOOP_BASE \
+    VI_LOOP_ELEMENT_SKIP();
+
+#define VI_LOOP_END \
+  } \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING){ \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((sew >> 3) * 1)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((sew >> 3) * 1)); \
+  }\
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_END_NO_TAIL_ZERO \
+  } \
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_WIDEN_END \
+  } \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING){ \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((sew >> 3) * 2)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((sew >> 3) * 2)); \
+  }\
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_REDUCTION_END(x) \
+  } \
+  if (vl > 0 && TAIL_ZEROING) { \
+    uint8_t *tail = (uint8_t *)vector_elt_int##x##_t(VECTOR, rd_num, 1); \
+    *vd_0_des = vd_0_res; \
+    memset(tail, 0, (VECTOR->VLEN - x) >> 3); \
+  } \
+  VECTOR->vstart = 0; 
+
+#define VI_LOOP_CMP_BASE \
+  reg_t vl, sew, rd_num, rs1_num, rs2_num, i; \
+  require(VECTOR->vsew == e8 || VECTOR->vsew == e16 || VECTOR->vsew == e32 || VECTOR->vsew == e64); \
+  require(!VECTOR->vill);\
+  vl = VECTOR->vl; \
+  sew = VECTOR->vsew; \
+  rd_num = rd(insn); \
+  rs1_num = insn_rs1(insn); \
+  rs2_num = rs2(insn); \
+  for (i = VECTOR->vstart; i<vl; ++i){ \
+	uint64_t mmask, res; \
+	uint64_t *vdi; \
+    VI_LOOP_ELEMENT_SKIP(); \
+    mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+    vdi = vector_elt_uint64_t(VECTOR, rd(insn), midx); \
+    res = 0;
+
+#define VI_LOOP_CMP_END \
+    *vdi = (*vdi & ~mmask) | (((res) << mpos) & mmask); \
+  } \
+  VI_TAIL_ZERO_MASK(rd_num); \
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_MASK(op) \
+  reg_t vl, i; \
+  require(VECTOR->vsew <= e64); \
+  vl = VECTOR->vl; \
+  for (i = VECTOR->vstart; i < vl; ++i) { \
+    int mlen = VECTOR->vmlen; \
+    int midx = (mlen * i) / 64; \
+    int mpos = (mlen * i) % 64; \
+    uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+    uint64_t vs2 = *vector_elt_uint64_t(VECTOR, rs2(insn), midx); \
+    uint64_t vs1 = *vector_elt_uint64_t(VECTOR, insn_rs1(insn), midx); \
+    uint64_t *res = vector_elt_uint64_t(VECTOR, rd(insn), midx); \
+    *res = (*res & ~mmask) | ((op) & (1ULL << mpos)); \
+  } \
+  \
+  if (TAIL_ZEROING) {\
+  for (i = vl; i < VECTOR->vlmax && i > 0; ++i) { \
+    int mlen = VECTOR->vmlen; \
+    int midx = (mlen * i) / 64; \
+    int mpos = (mlen * i) % 64; \
+    uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+    uint64_t *res = vector_elt_uint64_t(VECTOR, rd(insn), midx); \
+    *res = (*res & ~mmask); \
+    } \
+  } \
+  VECTOR->vstart = 0;
+
+#define VI_LOOP_NSHIFT_BASE \
+  require(VECTOR->vsew <= e32); \
+  if (rd(insn) != 0){ \
+    VI_CHECK_SD; \
+  } \
+  { \
+  VI_GENERAL_LOOP_BASE; \
+  { \
+  VI_LOOP_ELEMENT_SKIP({\
+    require(!(rd(insn) == 0 && VECTOR->vlmul > 1));\
+  }); \
+  }
+
+
+#define INT_ROUNDING(result, xrm, gb) \
+  if (gb > 0) { \
+    switch(xrm) {\
+      case RNU:\
+        result += ((uint64_t)1 << ((gb) - 1));\
+        break;\
+      case RNE:\
+        if ((result & ((uint64_t)0x3 << ((gb) - 1))) == 0x1){\
+            result -= ((uint64_t)1 << ((gb) - 1));\
+            }else if ((result & ((uint64_t)0x3 << ((gb) - 1))) == 0x3){\
+            result += ((uint64_t)1 << ((gb) - 1));\
+        }\
+        break;\
+      case RDN:\
+        result = (result >> ((gb) - 1)) << ((gb) - 1);\
+        break;\
+      case ROD:\
+        result |= ((uint64_t)1ul << (gb)); \
+        break;\
+      case INVALID_RM:\
+        require(0);\
+    } \
+  } else if (gb == 0 && xrm == ROD) { \
+    result |= 1ul; \
+  }
+
+//
+// vector: integer and masking operand access helper
+//
+#define VXI_PARAMS(x) \
+  int##x##_t *vd; \
+  int##x##_t vs1, vs2; \
+  int##x##_t rs1; \
+  int##x##_t simm5; \
+  vd = vector_elt_int##x##_t(VECTOR, rd_num, i); \
+  rs1 = (int##x##_t)RS1; \
+  simm5 = (int##x##_t)v_simm5(insn); \
+  vs1 = *vector_elt_int##x##_t(VECTOR, rs1_num, i); \
+  vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i);
+
+#define VV_U_PARAMS(x) \
+  uint##x##_t *vd; \
+  uint##x##_t vs1 = *vector_elt_uint##x##_t(VECTOR, rs1_num, i); \
+  uint##x##_t vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_uint##x##_t(VECTOR, rd_num, i);
+
+#define VX_U_PARAMS(x) \
+  uint##x##_t *vd; \
+  uint##x##_t rs1 = (uint##x##_t)RS1; \
+  uint##x##_t vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_uint##x##_t(VECTOR, rd_num, i);
+
+#define VI_U_PARAMS(x) \
+  uint##x##_t *vd; \
+  uint##x##_t simm5 = (uint##x##_t)v_zimm5(insn); \
+  uint##x##_t vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_uint##x##_t(VECTOR, rd_num, i);
+
+#define VV_PARAMS(x) \
+  int##x##_t *vd; \
+  int##x##_t vs1; \
+  int##x##_t vs2; \
+  vs1 = *vector_elt_int##x##_t(VECTOR, rs1_num, i); \
+  vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_int##x##_t(VECTOR, rd_num, i);
+
+#define VX_PARAMS(x) \
+  int##x##_t *vd; \
+  int##x##_t rs1 = (int##x##_t)RS1; \
+  int##x##_t vs2; \
+  vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+  vd = vector_elt_int##x##_t(VECTOR, rd_num, i);
+
+#define VI_PARAMS(x) \
+  int##x##_t *vd; \
+  int##x##_t simm5 = (int##x##_t)v_simm5(insn); \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i);\
+  vd = vector_elt_int##x##_t(VECTOR, rd_num, i);
+
+#define XV_PARAMS(x) \
+  int##x##_t *vd = vector_elt_int##x##_t(VECTOR, rd_num, i); \
+  uint##x##_t vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, RS1);
+
+#define VI_XI_SLIDEDOWN_PARAMS(x, off) \
+  int##x##_t *vd = vector_elt_int##x##_t(VECTOR, rd_num, i); \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i + off);
+
+#define VI_XI_SLIDEUP_PARAMS(x, offset) \
+  int##x##_t *vd = vector_elt_int##x##_t(VECTOR, rd_num, i); \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i - offset);
+
+#define VI_NSHIFT_PARAMS(sew1, sew2) \
+  uint##sew1##_t *vd = vector_elt_uint##sew1##_t(VECTOR, rd_num, i); \
+  uint##sew2##_t  vs2_u; \
+  uint##sew2##_t vs2; \
+  uint##sew1##_t zimm5 = (uint##sew1##_t)v_zimm5(insn); \
+  vs2_u = *vector_elt_uint##sew2##_t(VECTOR, rs2_num, i); \
+  vs2 = *vector_elt_int##sew2##_t(VECTOR, rs2_num, i); \
+
+#define VX_NSHIFT_PARAMS(sew1, sew2) \
+  uint##sew1##_t *vd = vector_elt_uint##sew1##_t(VECTOR, rd_num, i); \
+  uint##sew2##_t vs2_u; \
+  uint##sew2##_t vs2; \
+  uint##sew1##_t rs1 = (int##sew1##_t)RS1; \
+  vs2_u = *vector_elt_uint##sew2##_t(VECTOR, rs2_num, i); \
+  vs2 = *vector_elt_int##sew2##_t(VECTOR, rs2_num, i);
+
+#define VV_NSHIFT_PARAMS(sew1, sew2) \
+  uint##sew1##_t *vd = vector_elt_uint##sew1##_t(VECTOR, rd_num, i); \
+  uint##sew2##_t vs2_u; \
+  uint##sew2##_t vs2; \
+  uint##sew1##_t vs1 = *vector_elt_int##sew1##_t(VECTOR, rs1_num, i); \
+  vs2_u = *vector_elt_uint##sew2##_t(VECTOR, rs2_num, i); \
+  vs2 = *vector_elt_int##sew2##_t(VECTOR, rs2_num, i);
+
+#define XI_CARRY_PARAMS(x) \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+  int##x##_t rs1; \
+  int##x##_t simm5; \
+  uint64_t *vd = vector_elt_uint64_t(VECTOR, rd_num, midx); \
+  rs1 = (int##x##_t)RS1; \
+  simm5 = (int##x##_t)v_simm5(insn); \
+
+#define VV_CARRY_PARAMS(x) \
+  int##x##_t vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+  int##x##_t vs1 = *vector_elt_int##x##_t(VECTOR, rs1_num, i); \
+  uint64_t *vd = vector_elt_uint64_t(VECTOR, rd_num, midx);
+
+//
+// vector: integer and masking operation loop
+//
+
+// comparision result to masking register
+#define VI_VV_LOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VV_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VX_LOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VX_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VI_LOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VI_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VI_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VI_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VI_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VV_ULOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VV_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VX_ULOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VX_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+#define VI_VI_ULOOP_CMP(BODY) \
+{ \
+  VI_LOOP_CMP_BASE \
+  if (sew == e8){ \
+    VI_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VI_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VI_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VI_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_CMP_END \
+}
+
+// merge and copy loop
+#define VI_VVXI_MERGE_LOOP(BODY) \
+{ \
+  VI_GENERAL_LOOP_BASE \
+  if (sew == e8){ \
+    VXI_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VXI_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VXI_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VXI_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+// reduction loop - signed
+#define VI_LOOP_REDUCTION_BASE(x) \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num = insn_rs1(insn); \
+  reg_t rs2_num = rs2(insn); \
+  int##x##_t *vd_0_des = vector_elt_int##x##_t(VECTOR, rd_num, 0); \
+  int##x##_t vd_0_res = *vector_elt_int##x##_t(VECTOR, rs1_num, 0); \
+  int##x##_t vs2; \
+  reg_t i; \
+  require(x == e8 || x == e16 || x == e32 || x == e64); \
+  require(!VECTOR->vill);\
+  for (i = VECTOR->vstart; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP(); \
+    vs2 = *vector_elt_int##x##_t(VECTOR, rs2_num, i); \
+
+#define REDUCTION_LOOP(x, BODY) \
+  VI_LOOP_REDUCTION_BASE(x) \
+  BODY; \
+  VI_LOOP_REDUCTION_END(x)
+
+#define VI_VV_LOOP_REDUCTION(BODY) \
+  reg_t sew = VECTOR->vsew; \
+  if (sew == e8) { \
+    REDUCTION_LOOP(8, BODY) \
+  } else if(sew == e16) { \
+    REDUCTION_LOOP(16, BODY) \
+  } else if(sew == e32) { \
+    REDUCTION_LOOP(32, BODY) \
+  } else if(sew == e64) { \
+    REDUCTION_LOOP(64, BODY) \
+  }
+
+// reduction loop - unsgied
+#define VI_ULOOP_REDUCTION_BASE(x) \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num = insn_rs1(insn); \
+  reg_t rs2_num = rs2(insn); \
+  uint##x##_t *vd_0_des = vector_elt_uint##x##_t(VECTOR, rd_num, 0); \
+  uint##x##_t vd_0_res = *vector_elt_uint##x##_t(VECTOR, rs1_num, 0); \
+  uint##x##_t vs2; \
+  reg_t i; \
+  for (i=VECTOR->vstart; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP(); \
+    vs2 = *vector_elt_uint##x##_t(VECTOR, rs2_num, i);
+
+#define REDUCTION_ULOOP(x, BODY) \
+  VI_ULOOP_REDUCTION_BASE(x) \
+  BODY; \
+  VI_LOOP_REDUCTION_END(x)
+
+#define VI_VV_ULOOP_REDUCTION(BODY) \
+  reg_t sew = VECTOR->vsew; \
+  if (sew == e8){ \
+    REDUCTION_ULOOP(8, BODY) \
+  } else if(sew == e16) { \
+    REDUCTION_ULOOP(16, BODY) \
+  } else if(sew == e32) { \
+    REDUCTION_ULOOP(32, BODY) \
+  } else if(sew == e64) { \
+    REDUCTION_ULOOP(64, BODY) \
+  }
+
+// genearl VXI signed/unsgied loop
+#define VI_VV_ULOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VV_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VV_LOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VV_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VX_ULOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VX_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VX_LOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VX_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VI_ULOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_U_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VI_U_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VI_U_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VI_U_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+#define VI_VI_LOOP(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VI_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VI_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VI_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}
+
+// narrow operation loop
+#define VI_VV_LOOP_NARROW(BODY) \
+VI_NARROW_CHECK_COMMON; \
+{ \
+VI_LOOP_BASE \
+if (sew == e8){ \
+  VI_NARROW_SHIFT(8, 16) \
+  BODY; \
+}else if(sew == e16){ \
+  VI_NARROW_SHIFT(16, 32) \
+  BODY; \
+}else if(sew == e32){ \
+  VI_NARROW_SHIFT(32, 64) \
+  BODY; \
+} \
+VI_LOOP_END \
+}
+
+#define VI_NARROW_SHIFT(sew1, sew2) \
+  uint##sew1##_t *vd = vector_elt_uint##sew1##_t(VECTOR, rd_num, i); \
+  uint##sew2##_t vs2_u; \
+  uint##sew1##_t zimm5; \
+  int##sew2##_t vs2; \
+  int##sew1##_t vs1; \
+  int##sew1##_t rs1; \
+  rs1 = (int##sew1##_t)RS1; \
+  vs2 = *vector_elt_int##sew2##_t(VECTOR, rs2_num, i); \
+  vs1 = *vector_elt_int##sew1##_t(VECTOR, rs1_num, i); \
+  vs2_u = *vector_elt_uint##sew2##_t(VECTOR, rs2_num, i); \
+  zimm5 = (uint##sew1##_t)v_zimm5(insn);
+
+#define VI_VVXI_LOOP_NARROW(BODY) \
+  require(VECTOR->vsew <= e32); \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_NARROW_SHIFT(8, 16) \
+    BODY; \
+  } else if (sew == e16) { \
+    VI_NARROW_SHIFT(16, 32) \
+    BODY; \
+  } else if (sew == e32) { \
+    VI_NARROW_SHIFT(32, 64) \
+    BODY; \
+  } \
+  VI_LOOP_END \
+  }
+
+#define VI_VI_LOOP_NSHIFT(BODY) \
+{ \
+  VI_LOOP_NSHIFT_BASE \
+  if (sew == e8){ \
+    VI_NSHIFT_PARAMS(8, 16) \
+    BODY; \
+  } else if (sew == e16) { \
+    VI_NSHIFT_PARAMS(16, 32) \
+    BODY; \
+  } else if (sew == e32) { \
+    VI_NSHIFT_PARAMS(32, 64) \
+    BODY; \
+  } \
+  VI_LOOP_END \
+  } \
+}
+
+#define VI_VX_LOOP_NSHIFT(BODY) \
+{ \
+  VI_LOOP_NSHIFT_BASE \
+  if (sew == e8){ \
+    VX_NSHIFT_PARAMS(8, 16) \
+    BODY; \
+  } else if (sew == e16) { \
+    VX_NSHIFT_PARAMS(16, 32) \
+    BODY; \
+  } else if (sew == e32) { \
+    VX_NSHIFT_PARAMS(32, 64) \
+    BODY; \
+  } \
+  VI_LOOP_END \
+} \
+}
+
+#define VI_VV_LOOP_NSHIFT(BODY) \
+{ \
+  VI_LOOP_NSHIFT_BASE \
+  if (sew == e8){ \
+    VV_NSHIFT_PARAMS(8, 16) \
+    BODY; \
+  } else if (sew == e16) { \
+    VV_NSHIFT_PARAMS(16, 32) \
+    BODY; \
+  } else if (sew == e32) { \
+    VV_NSHIFT_PARAMS(32, 64) \
+    BODY; \
+  } \
+  VI_LOOP_END \
+}\
+}
+
+// widen operation loop
+#define VI_VV_LOOP_WIDEN(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VV_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VV_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VV_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VV_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_WIDEN_END \
+}
+
+#define VI_VX_LOOP_WIDEN(BODY) \
+{ \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VX_PARAMS(8); \
+    BODY; \
+  }else if(sew == e16){ \
+    VX_PARAMS(16); \
+    BODY; \
+  }else if(sew == e32){ \
+    VX_PARAMS(32); \
+    BODY; \
+  }else if(sew == e64){ \
+    VX_PARAMS(64); \
+    BODY; \
+  } \
+  VI_LOOP_WIDEN_END \
+}
+
+#define VI_WIDE_OP_AND_ASSIGN(var0, var1, var2, op0, op1, sign) \
+  switch(VECTOR->vsew) { \
+  case e8: { \
+    sign##16_t vd_w; \
+    vd_w = *vector_elt_##sign##16_t(VECTOR, rd_num, i); \
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = \
+      op1((sign##16_t)(sign##8_t)var0 op0 (sign##16_t)(sign##8_t)var1) + var2; \
+    } \
+    break; \
+  case e16: { \
+    sign##32_t vd_w; \
+    vd_w = *vector_elt_##sign##32_t(VECTOR, rd_num, i); \
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = \
+      op1((sign##32_t)(sign##16_t)var0 op0 (sign##32_t)(sign##16_t)var1) + var2; \
+    } \
+    break; \
+  default: { \
+    sign##64_t vd_w; \
+    vd_w = *vector_elt_##sign##64_t(VECTOR, rd_num, i); \
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = \
+      op1((sign##64_t)(sign##32_t)var0 op0 (sign##64_t)(sign##32_t)var1) + var2; \
+    } \
+    break; \
+  }
+
+#define VI_WIDE_OP_AND_ASSIGN_MIX(var0, var1, var2, op0, op1, sign_d, sign_1, sign_2) \
+  switch(VECTOR->vsew) { \
+  case e8: { \
+    sign_d##16_t vd_w = *vector_elt_##sign_d##16_t(VECTOR, rd_num, i); \
+    *vector_elt_uint16_t(VECTOR, rd_num, i) = \
+      op1((sign_1##16_t)(sign_1##8_t)var0 op0 (sign_2##16_t)(sign_2##8_t)var1) + var2; \
+    } \
+    break; \
+  case e16: { \
+    sign_d##32_t vd_w = *vector_elt_##sign_d##32_t(VECTOR, rd_num, i); \
+    *vector_elt_uint32_t(VECTOR, rd_num, i) = \
+      op1((sign_1##32_t)(sign_1##16_t)var0 op0 (sign_2##32_t)(sign_2##16_t)var1) + var2; \
+    } \
+    break; \
+  default: { \
+    sign_d##64_t vd_w = *vector_elt_##sign_d##64_t(VECTOR, rd_num, i); \
+    *vector_elt_uint64_t(VECTOR, rd_num, i) = \
+      op1((sign_1##64_t)(sign_1##32_t)var0 op0 (sign_2##64_t)(sign_2##32_t)var1) + var2; \
+    } \
+    break; \
+  }
+
+#define VI_WIDE_WVX_OP(var0, op0, sign) \
+  switch(VECTOR->vsew) { \
+  case e8: { \
+    sign##16_t *vd_w = vector_elt_##sign##16_t(VECTOR, rd_num, i); \
+    sign##16_t vs2_w = *vector_elt_##sign##16_t(VECTOR, rs2_num, i); \
+    *vd_w = vs2_w op0 (sign##16_t)(sign##8_t)var0; \
+    } \
+    break; \
+  case e16: { \
+    sign##32_t *vd_w = vector_elt_##sign##32_t(VECTOR, rd_num, i); \
+    sign##32_t vs2_w = *vector_elt_##sign##32_t(VECTOR, rs2_num, i); \
+    *vd_w = vs2_w op0 (sign##32_t)(sign##16_t)var0; \
+    } \
+    break; \
+  default: { \
+    sign##64_t *vd_w = vector_elt_##sign##64_t(VECTOR, rd_num, i); \
+    sign##64_t vs2_w = *vector_elt_##sign##64_t(VECTOR, rs2_num, i); \
+    *vd_w = vs2_w op0 (sign##64_t)(sign##32_t)var0; \
+    } \
+    break; \
+  }
+
+#define VI_WIDE_SSMA(sew1, sew2, opd) \
+  int##sew2##_t *vd = vector_elt_int##sew2##_t(VECTOR, rd_num, i); \
+  int##sew1##_t vs1 ; \
+  int##sew1##_t vs2 = *vector_elt_int##sew1##_t(VECTOR, rs2_num, i); \
+  int##sew1##_t rs1; \
+  int##sew2##_t res; \
+  bool sat = false; \
+  const int gb = sew1 / 2; \
+  VRM vrm = VECTOR->vxrm; \
+  rs1 = (int##sew1##_t)RS1; \
+  vs1 = *vector_elt_int##sew1##_t(VECTOR, rs1_num, i); \
+  res = (int##sew2##_t)vs2 * (int##sew2##_t)opd; \
+  INT_ROUNDING(res, vrm, gb); \
+  res = res >> gb; \
+  *vd = sat_add_int##sew2##_t_uint##sew2##_t(*vd, res, &sat); \
+  VECTOR->vxsat |= sat;
+
+#define VI_VVX_LOOP_WIDE_SSMA(opd) \
+  VI_WIDE_CHECK_COMMON \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_WIDE_SSMA(8, 16, opd); \
+  } else if(sew == e16){ \
+    VI_WIDE_SSMA(16, 32, opd); \
+  } else if(sew == e32){ \
+    VI_WIDE_SSMA(32, 64, opd); \
+  } \
+  VI_LOOP_WIDEN_END \
+  }
+
+#define VI_WIDE_USSMA(sew1, sew2, opd) \
+  int##sew2##_t *vd = vector_elt_uint##sew2##_t(VECTOR, rd_num, i); \
+  int##sew1##_t vs1; \
+  int##sew1##_t vs2 = *vector_elt_uint##sew1##_t(VECTOR, rs2_num, i); \
+  int##sew1##_t rs1; \
+  uint##sew2##_t res; \
+  bool sat = false; \
+  const int gb = sew1 / 2; \
+  VRM vrm = VECTOR->vxrm; \
+  rs1 = (uint##sew1##_t)RS1; \
+  vs1 = *vector_elt_uint##sew1##_t(VECTOR, rs1_num, i); \
+  res = (uint##sew2##_t)vs2 * (uint##sew2##_t)opd; \
+  INT_ROUNDING(res, vrm, gb); \
+  \
+  res = res >> gb; \
+  *vd = sat_addu_uint##sew2##_t(*vd, res, &sat); \
+  VECTOR->vxsat |= sat;
+
+#define VI_VVX_LOOP_WIDE_USSMA(opd) \
+  VI_WIDE_CHECK_COMMON \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_WIDE_USSMA(8, 16, opd); \
+  } else if(sew == e16){ \
+    VI_WIDE_USSMA(16, 32, opd); \
+  } else if(sew == e32){ \
+    VI_WIDE_USSMA(32, 64, opd); \
+  } \
+  VI_LOOP_WIDEN_END \
+  }
+
+#define VI_WIDE_SU_SSMA(sew1, sew2, opd) \
+  int##sew2##_t *vd = vector_elt_int##sew2##_t(VECTOR, rd_num, i); \
+  int##sew1##_t vs1; \
+  uint##sew1##_t vs2 = *vector_elt_uint##sew1##_t(VECTOR, rs2_num, i); \
+  int##sew1##_t rs1; \
+  int##sew2##_t res; \
+  bool sat = false; \
+  const int gb = sew1 / 2; \
+  VRM vrm = VECTOR->vxrm; \
+  rs1 = (int##sew1##_t)RS1; \
+  vs1 = *vector_elt_int##sew1##_t(VECTOR, rs1_num, i); \
+  res = (uint##sew2##_t)vs2 * (int##sew2##_t)opd; \
+  INT_ROUNDING(res, vrm, gb); \
+  \
+  res = res >> gb; \
+  *vd = sat_sub_int##sew2##_t_uint##sew2##_t(*vd, res, &sat); \
+  VECTOR->vxsat |= sat;
+
+#define VI_VVX_LOOP_WIDE_SU_SSMA(opd) \
+  VI_WIDE_CHECK_COMMON \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_WIDE_SU_SSMA(8, 16, opd); \
+  } else if(sew == e16){ \
+    VI_WIDE_SU_SSMA(16, 32, opd); \
+  } else if(sew == e32){ \
+    VI_WIDE_SU_SSMA(32, 64, opd); \
+  } \
+  VI_LOOP_WIDEN_END \
+  }
+
+#define VI_WIDE_US_SSMA(sew1, sew2, opd) \
+  int##sew2##_t *vd = vector_elt_int##sew2##_t(VECTOR, rd_num, i); \
+  uint##sew1##_t vs1; \
+  int##sew1##_t vs2 = *vector_elt_int##sew1##_t(VECTOR, rs2_num, i); \
+  uint##sew1##_t rs1; \
+  int##sew2##_t res; \
+  bool sat = false; \
+  const int gb = sew1 / 2; \
+  VRM vrm = VECTOR->vxrm; \
+  rs1 = (uint##sew1##_t)RS1; \
+  vs1 = *vector_elt_uint##sew1##_t(VECTOR, rs1_num, i); \
+  res = (int##sew2##_t)vs2 * (uint##sew2##_t)opd; \
+  INT_ROUNDING(res, vrm, gb); \
+  \
+  res = res >> gb; \
+  *vd = sat_sub_int##sew2##_t_uint##sew2##_t(*vd, res, &sat); \
+  VECTOR->vxsat |= sat;
+
+#define VI_VVX_LOOP_WIDE_US_SSMA(opd) \
+  VI_WIDE_CHECK_COMMON \
+  { \
+  VI_LOOP_BASE \
+  if (sew == e8){ \
+    VI_WIDE_US_SSMA(8, 16, opd); \
+  } else if(sew == e16){ \
+    VI_WIDE_US_SSMA(16, 32, opd); \
+  } else if(sew == e32){ \
+    VI_WIDE_US_SSMA(32, 64, opd); \
+  } \
+  VI_LOOP_WIDEN_END \
+  }
+
+// wide reduction loop - signed
+#define VI_LOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num = insn_rs1(insn); \
+  reg_t rs2_num = rs2(insn); \
+  int##sew1##_t vs2; \
+  int##sew2##_t *vd_0_des = vector_elt_int##sew2##_t(VECTOR, rd_num, 0); \
+  int##sew2##_t vd_0_res = *vector_elt_int##sew2##_t(VECTOR, rs1_num, 0); \
+  reg_t i;\
+  VI_CHECK_DSS(false); \
+  for (i=VECTOR->vstart; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP(); \
+    vs2 = *vector_elt_int##sew1##_t(VECTOR, rs2_num, i);
+
+#define WIDE_REDUCTION_LOOP(sew1, sew2, BODY) \
+  VI_LOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
+  BODY; \
+  VI_LOOP_REDUCTION_END(sew2)
+
+#define VI_VV_LOOP_WIDE_REDUCTION(BODY) \
+  reg_t sew = VECTOR->vsew; \
+  require(!VECTOR->vill);\
+  if (sew == e8){ \
+    WIDE_REDUCTION_LOOP(8, 16, BODY) \
+  } else if(sew == e16){ \
+    WIDE_REDUCTION_LOOP(16, 32, BODY) \
+  } else if(sew == e32){ \
+    WIDE_REDUCTION_LOOP(32, 64, BODY) \
+  }
+
+// wide reduction loop - unsigned
+#define VI_ULOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num = insn_rs1(insn); \
+  reg_t rs2_num = rs2(insn); \
+  uint##sew2##_t *vd_0_des = vector_elt_uint##sew2##_t(VECTOR, rd_num, 0); \
+  uint##sew2##_t vd_0_res = *vector_elt_uint##sew2##_t(VECTOR, rs1_num, 0); \
+  reg_t i;\
+  VI_CHECK_DSS(false); \
+  for (i =VECTOR->vstart; i<vl; ++i) { \
+	uint##sew1##_t vs2; \
+    VI_LOOP_ELEMENT_SKIP(); \
+    vs2 = *vector_elt_uint##sew1##_t(VECTOR, rs2_num, i);
+
+#define WIDE_REDUCTION_ULOOP(sew1, sew2, BODY) \
+  VI_ULOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
+  BODY; \
+  VI_LOOP_REDUCTION_END(sew2)
+
+#define VI_VV_ULOOP_WIDE_REDUCTION(BODY) \
+  reg_t sew = VECTOR->vsew; \
+  require(!VECTOR->vill);\
+  if (sew == e8){ \
+    WIDE_REDUCTION_ULOOP(8, 16, BODY) \
+  } else if(sew == e16){ \
+    WIDE_REDUCTION_ULOOP(16, 32, BODY) \
+  } else if(sew == e32){ \
+    WIDE_REDUCTION_ULOOP(32, 64, BODY) \
+  }
+
+// carry/borrow bit loop
+#define VI_VV_LOOP_CARRY(BODY) \
+  VI_LOOP_BASE \
+    if (sew == e8){ \
+      VV_CARRY_PARAMS(8) \
+      BODY; \
+    } else if (sew == e16) { \
+      VV_CARRY_PARAMS(16) \
+      BODY; \
+    } else if (sew == e32) { \
+      VV_CARRY_PARAMS(32) \
+      BODY; \
+    } else if (sew == e64) { \
+      VV_CARRY_PARAMS(64) \
+      BODY; \
+    } \
+  } \
+  VI_TAIL_ZERO_MASK(rd_num);
+
+#define VI_XI_LOOP_CARRY(BODY) \
+  VI_LOOP_BASE \
+    if (sew == e8){ \
+      XI_CARRY_PARAMS(8) \
+      BODY; \
+    } else if (sew == e16) { \
+      XI_CARRY_PARAMS(16) \
+      BODY; \
+    } else if (sew == e32) { \
+      XI_CARRY_PARAMS(32) \
+      BODY; \
+    } else if (sew == e64) { \
+      XI_CARRY_PARAMS(64) \
+      BODY; \
+    } \
+  } \
+  VI_TAIL_ZERO_MASK(rd_num);
+
+// average loop
+#define VI_VVX_LOOP_AVG(opd, op) \
+{ \
+VRM xrm = VECTOR->vxrm; \
+VI_LOOP_BASE \
+  switch(sew) { \
+    case e8: { \
+        int8_t rs1; \
+        int32_t res; \
+     VV_PARAMS(8); \
+     rs1 = RS1; \
+     res = (int32_t)vs2 op opd; \
+     INT_ROUNDING(res, xrm, 1); \
+     *vd = res >> 1; \
+     break; \
+    } \
+    case e16: { \
+     int16_t rs1; \
+     int32_t res; \
+     VV_PARAMS(16); \
+     rs1 = RS1; \
+     res = (int32_t)vs2 op opd; \
+     INT_ROUNDING(res, xrm, 1); \
+     *vd = res >> 1; \
+     break; \
+    } \
+    case e32: { \
+    int32_t rs1; \
+    int64_t res; \
+     VV_PARAMS(32); \
+     rs1 = RS1; \
+     res = (int64_t)vs2 op opd; \
+     INT_ROUNDING(res, xrm, 1); \
+     *vd = res >> 1; \
+     break; \
+    } \
+    default: { \
+     int64_t rs1; \
+     int128_t res; \
+     VV_PARAMS(64); \
+     rs1 = RS1; \
+     res = (int128_t)vs2 op opd; \
+     INT_ROUNDING(res, xrm, 1); \
+     *vd = res >> 1; \
+     break; \
+    } \
+  } \
+VI_LOOP_END \
+}
+
+//
+// vector: load/store helper 
+//
+#define VI_STRIP(inx) \
+  reg_t elems_per_strip = VECTOR->SLEN / VECTOR->vsew; \
+  reg_t elems_per_vreg = VECTOR->VLEN /VECTOR->vsew; \
+  reg_t elems_per_lane = VECTOR->vlmul * elems_per_strip; \
+  reg_t strip_index = (inx) / elems_per_lane; \
+  reg_t index_in_strip = (inx) % elems_per_strip; \
+  int32_t lmul_inx = (int32_t)(((inx) % elems_per_lane) / elems_per_strip); \
+  reg_t vreg_inx = lmul_inx * elems_per_vreg + strip_index * elems_per_strip + index_in_strip;
+
+
+#define VI_DUPLICATE_VREG(v, vlmax) \
+reg_t index[32]; \
+reg_t i = 0;\
+for (; i < vlmax; ++i) { \
+  switch(VECTOR->vsew) { \
+    case e32: \
+      index[i] = *vector_elt_int32_t(VECTOR, v, i); \
+      break; \
+    case e64: \
+      index[i] = *vector_elt_int64_t(VECTOR, v, i); \
+      break; \
+    default: \
+	  require(0); \
+  } \
+}
+
+#define VI_ST_WITH_I(stride, offset, st_width, elt_byte) \
+  const reg_t nf = v_nf(insn) + 1; \
+  const reg_t vl = VECTOR->vl; \
+  const reg_t baseAddr = RS1; \
+  const reg_t vs3 = rd(insn); \
+  const reg_t vlmax = VECTOR->vlmax; \
+  const reg_t vlmul = VECTOR->vlmul; \
+  i = 0;\
+  require((nf * VECTOR->vlmul) <= (NVPR / 4)); \
+  for (; i < vlmax && vl != 0; ++i) { \
+    bool is_valid = true; \
+    reg_t fn = 0;\
+    VI_STRIP(i) \
+    VI_ELEMENT_SKIP(i); \
+    if (!is_valid) \
+      continue; \
+    for (; fn < nf; ++fn) { \
+      st_width##_t val = 0; \
+      switch (VECTOR->vsew) { \
+      case e8: \
+        val = *vector_elt_uint8_t(VECTOR, vs3 + fn * vlmul, vreg_inx); \
+        break; \
+      case e16: \
+        val = *vector_elt_uint16_t(VECTOR, vs3 + fn * vlmul, vreg_inx); \
+        break; \
+      case e32: \
+        val = *vector_elt_uint32_t(VECTOR, vs3 + fn * vlmul, vreg_inx); \
+        break; \
+      default: \
+        val = *vector_elt_uint64_t(VECTOR, vs3 + fn * vlmul, vreg_inx); \
+        break; \
+      } \
+      store_##st_width(baseAddr + (stride) + (offset) * elt_byte, val); \
+    } \
+  } \
+  VECTOR->vstart = 0; 
+
+#define VI_ST(stride, offset, st_width, elt_byte) \
+  reg_t i; \
+  VI_ST_WITH_I(stride, offset, st_width, elt_byte)
+
+#define VI_LD_WITH_I(stride, offset, ld_width, elt_byte) \
+  const reg_t nf = v_nf(insn) + 1; \
+  const reg_t vl = VECTOR->vl; \
+  const reg_t baseAddr = RS1; \
+  const reg_t vd = rd(insn); \
+  const reg_t vlmax = VECTOR->vlmax; \
+  const reg_t vlmul = VECTOR->vlmul; \
+  i = 0; \
+  require((nf * VECTOR->vlmul) <= (NVPR / 4)); \
+  for (; i < vlmax && vl != 0; ++i) { \
+    bool is_valid = true; \
+    VI_ELEMENT_SKIP(i); \
+    { \
+    reg_t fn = 0; \
+    VI_STRIP(i); \
+    for (; fn < nf; ++fn) { \
+      ld_width##_t val = load_##ld_width(baseAddr + (stride) + (offset) * elt_byte); \
+      if (vd + fn >= NVPR){ \
+         VECTOR->vstart = vreg_inx;\
+         require(false); \
+      } \
+      switch(VECTOR->vsew){ \
+        case e8: \
+          *vector_elt_uint8_t(VECTOR, vd + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+          break; \
+        case e16: \
+          *vector_elt_uint16_t(VECTOR, vd + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+          break; \
+        case e32: \
+          *vector_elt_uint32_t(VECTOR, vd + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+          break; \
+        default: \
+          *vector_elt_uint64_t(VECTOR, vd + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+      } \
+    } \
+    } \
+  } \
+  VECTOR->vstart = 0;
+
+#define VI_LD(stride, offset, ld_width, elt_byte) \
+  reg_t i; \
+  VI_LD_WITH_I(stride, offset, ld_width, elt_byte)
+
+
+#define VI_LDST_FF(itype, tsew) \
+  const reg_t nf = v_nf(insn) + 1; \
+  const reg_t sew = VECTOR->vsew; \
+  const reg_t vl = VECTOR->vl; \
+  const reg_t baseAddr = RS1; \
+  const reg_t rd_num = rd(insn); \
+  bool early_stop = false; \
+  const reg_t vlmax = VECTOR->vlmax; \
+  const reg_t vlmul = VECTOR->vlmul; \
+  reg_t i = 0; \
+  require(VECTOR->vsew >= e##tsew && VECTOR->vsew <= e64); \
+  require((nf * VECTOR->vlmul) <= (NVPR / 4)); \
+  for (; i < vlmax && vl != 0; ++i) { \
+    bool is_valid = true; \
+    VI_STRIP(i); \
+    VI_ELEMENT_SKIP(i); \
+    { \
+    reg_t fn = 0; \
+    for (; fn < nf; ++fn) { \
+      itype##64_t val = load_##itype##tsew(baseAddr + (i * nf + fn) * (tsew / 8)); \
+      \
+      switch (sew) { \
+      case e8: \
+        *vector_elt_uint8_t(VECTOR, rd_num + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+        break; \
+      case e16: \
+        *vector_elt_uint16_t(VECTOR, rd_num + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+        break; \
+      case e32: \
+        *vector_elt_uint32_t(VECTOR, rd_num + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+        break; \
+      case e64: \
+        *vector_elt_uint64_t(VECTOR, rd_num + fn * vlmul, vreg_inx) = is_valid ? val : 0; \
+        break; \
+      } \
+       \
+      if (val == 0 && is_valid) { \
+        VECTOR->vl = i; \
+        early_stop = true; \
+        break; \
+      } \
+    } \
+    }\
+    if (early_stop) { \
+      break; \
+    } \
+  } \
+  VECTOR->vstart = 0;
+
+
+//
+// vector: vfp helper
+//
+#define VI_VFP_COMMON \
+  reg_t vl = VECTOR->vl; \
+  reg_t rd_num = rd(insn); \
+  reg_t rs1_num; \
+  reg_t rs2_num; \
+  rs2_num = rs2(insn); \
+  rs1_num = insn_rs1(insn); \
+  softfloat_roundingMode = STATE.frm; \
+  require_fp; \
+  require((VECTOR->vsew == e32 && supports_extension(p, 'F')) || \
+          (VECTOR->vsew == e64 && supports_extension(p, 'D'))); \
+  require(!VECTOR->vill);
+
+#define VI_VFP_LOOP_BASE \
+  VI_VFP_COMMON \
+  { \
+  reg_t i=VECTOR->vstart; \
+  for (; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP();
+
+#define VI_VFP_LOOP_CMP_BASE \
+  VI_VFP_COMMON \
+  { \
+  reg_t i = VECTOR->vstart; \
+  for (; i < vl; ++i) { \
+	uint64_t mmask, res; \
+	uint64_t *vdi; \
+    float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+    float64_t vs1 = *vector_elt_float64_t(VECTOR, rs1_num, i); \
+    float64_t rs1 = f64_f(READ_FREG(rs1_num)); \
+    VI_LOOP_ELEMENT_SKIP(); \
+    mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+    vdi = vector_elt_uint64_t(VECTOR, rd_num, midx); \
+    res = 0;
+
+#define VI_VFP_LOOP_REDUCTION_BASE \
+  VI_VFP_COMMON \
+  { \
+  float64_t vd_0 = *vector_elt_float64_t(VECTOR, rd_num, 0); \
+  float64_t vs1_0 = *vector_elt_float64_t(VECTOR, rs1_num, 0); \
+  reg_t i = VECTOR->vstart; \
+  vd_0 = vs1_0;\
+  for (; i<vl; ++i){ \
+    VI_LOOP_ELEMENT_SKIP(); \
+
+#define VI_VFP_LOOP_WIDE_REDUCTION_BASE \
+  VI_VFP_COMMON \
+  { \
+  float64_t vd_0 = f64(vector_elt_float64_t(VECTOR, rs1_num, 0)->v); \
+  reg_t i =VECTOR->vstart; \
+  for (; i<vl; ++i) { \
+    VI_LOOP_ELEMENT_SKIP();
+
+#define VI_VFP_LOOP_END \
+  } \
+  } \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING){ \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((VECTOR->vsew >> 3) * 1)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((VECTOR->vsew >> 3) * 1)); \
+  }\
+  VECTOR->vstart = 0; \
+
+#define VI_VFP_LOOP_WIDE_END \
+  } \
+  } \
+  if (vl != 0 && vl < VECTOR->vlmax && TAIL_ZEROING){ \
+    uint8_t *tail = vector_elt_uint8_t(VECTOR, rd_num, vl * ((VECTOR->vsew >> 3) * 2)); \
+    memset(tail, 0, (VECTOR->vlmax - vl) * ((VECTOR->vsew >> 3) * 2)); \
+  }\
+  VECTOR->vstart = 0; \
+  set_fp_exceptions;
+
+#define VI_VFP_LOOP_REDUCTION_END(x) \
+  } \
+  VECTOR->vstart = 0; \
+  set_fp_exceptions; \
+  *vector_elt_int##x##_t(VECTOR, rd_num, 0) = vd_0.v; \
+  if (vl > 0 && TAIL_ZEROING) { \
+    for (i = 1; i < (VECTOR->VLEN / x); ++i) { \
+       *vector_elt_int##x##_t(VECTOR, rd_num, i) = 0; \
+    } \
+  } \
+  }
+
+#define VI_VFP_LOOP_CMP_END \
+  switch(VECTOR->vsew) { \
+    case e64: \
+    case e32: { \
+      *vdi = (*vdi & ~mmask) | (((res) << mpos) & mmask); \
+      break; \
+    } \
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+    }; \
+    rs1.v = vs1.v = 0; \
+  } \
+  if (vl != 0 && TAIL_ZEROING){ \
+    for (i=vl; i<VECTOR->vlmax; ++i){ \
+      const int mlen = VECTOR->vmlen; \
+      const int midx = (mlen * i) / 64; \
+      const int mpos = (mlen * i) % 64; \
+      uint64_t mmask = (UINT64_MAX << (64 - mlen)) >> (64 - mlen - mpos); \
+      uint64_t *vdi = vector_elt_uint64_t(VECTOR, rd(insn), midx); \
+      *vdi = (*vdi & ~mmask);\
+    }\
+  }\
+  }\
+  VECTOR->vstart = 0; \
+  set_fp_exceptions;
+
+#define VI_VFP_VV_LOOP(BODY32, BODY64) \
+{ \
+  VI_VFP_LOOP_BASE \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float32_t *vd; \
+      float32_t vs1, vs2; \
+      vs1 = *vector_elt_float32_t(VECTOR, rs1_num, i); \
+      vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i); \
+      vd = vector_elt_float32_t(VECTOR, rd_num, i); \
+      BODY32; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e64: {\
+      float64_t *vd; \
+      float64_t vs1, vs2; \
+      vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+      vs1 = *vector_elt_float64_t(VECTOR, rs1_num, i); \
+      vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      BODY64; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_END \
+}
+
+#define VI_VFP_VV_LOOP_REDUCTION(BODY) \
+{ \
+  VI_VFP_LOOP_REDUCTION_BASE \
+  { \
+  float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+  BODY; \
+  DEBUG_RVV_FP_VV; \
+  } \
+  VI_VFP_LOOP_REDUCTION_END(64) \
+}
+
+#define VI_VFP_VV_LOOP_WIDE_REDUCTION(BODY) \
+{ \
+  VI_VFP_LOOP_WIDE_REDUCTION_BASE \
+  { \
+  float64_t vs2 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs2_num, i)); \
+  BODY; \
+  DEBUG_RVV_FP_VV; \
+  } \
+  VI_VFP_LOOP_REDUCTION_END(64) \
+}
+
+#define VI_VFP_VF_LOOP(BODY32, BODY64) \
+{ \
+  VI_VFP_LOOP_BASE \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float32_t *vd = vector_elt_float32_t(VECTOR, rd_num, i); \
+      float32_t rs1 = f32_f(READ_FREG(rs1_num)); \
+      float32_t vs2 = *vector_elt_float32_t(VECTOR, rs2_num, i); \
+      BODY32; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e64: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t rs1 = f64_f(READ_FREG(rs1_num)); \
+      float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+      BODY64; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+  }; \
+  DEBUG_RVV_FP_VF; \
+  VI_VFP_LOOP_END \
+}
+
+#define VI_VFP_LOOP_CMP(BODY) \
+{ \
+  VI_VFP_LOOP_CMP_BASE \
+  BODY; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_CMP_END \
+}
+
+#define VI_VFP_VF_LOOP_WIDE(BODY) \
+{ \
+  VI_VFP_LOOP_BASE \
+  VI_CHECK_DSS(false); \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t vs2 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs2_num, i)); \
+      float64_t rs1 = f32_to_f64(f32_f(READ_FREG(rs1_num))); \
+      BODY; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_WIDE_END \
+}
+
+#define VI_VFP_VV_LOOP_WIDE(BODY) \
+{ \
+  VI_VFP_LOOP_BASE \
+  VI_CHECK_DSS(true); \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t vs2 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs2_num, i)); \
+      float64_t vs1 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs1_num, i)); \
+      BODY; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+      break; \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_WIDE_END \
+}
+
+#define VI_VFP_WF_LOOP_WIDE(BODY) \
+{ \
+  VI_VFP_LOOP_BASE \
+  VI_CHECK_DDS(false); \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+      float64_t rs1 = f32_to_f64(f32_f(READ_FREG(rs1_num))); \
+      BODY; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_WIDE_END \
+}
+
+#define VI_VFP_WV_LOOP_WIDE(BODY) \
+{ \
+  VI_VFP_LOOP_BASE \
+  VI_CHECK_DDS(true); \
+  switch(VECTOR->vsew) { \
+    case e32: {\
+      float64_t *vd = vector_elt_float64_t(VECTOR, rd_num, i); \
+      float64_t vs2 = *vector_elt_float64_t(VECTOR, rs2_num, i); \
+      float64_t vs1 = f32_to_f64(*vector_elt_float32_t(VECTOR, rs1_num, i)); \
+      BODY; \
+      set_fp_exceptions; \
+      break; \
+    }\
+    case e16: \
+    case e8: \
+    default: \
+      require(0); \
+  }; \
+  DEBUG_RVV_FP_VV; \
+  VI_VFP_LOOP_WIDE_END \
+}
+
+#define VI_AMO(op, type) \
+  const reg_t vl = VECTOR->vl; \
+  const reg_t baseAddr = RS1; \
+  const reg_t vd = rd(insn); \
+  require(!VECTOR->vill);\
+  require(rd(insn) + VECTOR->vlmul <= 32); \
+  if (v_vm(insn) == 0) \
+	require(rd(insn) != 0); \
+  require(VECTOR->vsew <= get_xlen() && VECTOR->vsew >= 32 && VECTOR->vsew >= type); \
+  { \
+  VI_DUPLICATE_VREG(rs2(insn), VECTOR->vsew); \
+  for (i = VECTOR->vstart; i < vl; ++i) { \
+    bool is_valid = true; \
+    VI_ELEMENT_SKIP(i); \
+    { \
+    VI_STRIP(i); \
+    switch (VECTOR->vsew) { \
+    case e32: {\
+      int32_t vs3 = *vector_elt_int32_t(VECTOR, vd, vreg_inx); \
+      int32_t lhs = load_int##type(baseAddr + index[i]); \
+      int32_t val; \
+      op\
+      store_int##type(baseAddr + index[i], val); \
+      if (v_wd(insn)) \
+        *vector_elt_int32_t(VECTOR, vd, vreg_inx) = lhs; \
+      } \
+      break; \
+    case e64: {\
+      int64_t vs3 = *vector_elt_int64_t(VECTOR, vd, vreg_inx); \
+      int64_t lhs = load_int##type(baseAddr + index[i]); \
+      int64_t val; \
+      op\
+      store_int##type(baseAddr + index[i], val); \
+      if (v_wd(insn)) \
+        *vector_elt_int64_t(VECTOR, vd, vreg_inx) = lhs; \
+      } \
+      break; \
+    default: \
+      require(0); \
+      break; \
+    } \
+    } \
+  } \
+  } \
+  VECTOR->vstart = 0;
+
+#define DEFINE_INSN(name) \
+   reg_t rv32_##name(processor_t* p, insn_t insn); \
+   reg_t rv64_##name(processor_t* p, insn_t insn); \
+   
+#include "insn_list.h"
+#undef DEFINE_INSN
+// Seems that 0x0 doesn't work.
+#define DEBUG_START             0x100
+#define DEBUG_END               (0x1000 - 1)
+#endif
diff --git a/arch/riscv/kernel/soft_vector/softfloat/Makefile b/arch/riscv/kernel/soft_vector/softfloat/Makefile
new file mode 100644
index 000000000000..7166d6f518e3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/Makefile
@@ -0,0 +1,227 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the RISC-V Linux kernel
+#
+obj-$(CONFIG_VECTOR_EMU)+= f128_add.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_classify.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_div.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_eq.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_eq_signaling.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_isSignalingNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_le.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_le_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_lt.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_lt_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_mulAdd.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_mul.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_rem.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_roundToInt.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_sqrt.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_sub.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_i32.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_i32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_i64.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_i64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_ui32.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_ui32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_ui64.o
+obj-$(CONFIG_VECTOR_EMU)+= f128_to_ui64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_add.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_classify.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_div.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_eq.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_eq_signaling.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_isSignalingNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_le.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_le_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_lt.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_lt_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_mulAdd.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_mul.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_rem.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_roundToInt.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_sqrt.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_sub.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i8.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i16.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i32.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i64.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_i64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui8.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui16.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui32.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui64.o
+obj-$(CONFIG_VECTOR_EMU)+= f16_to_ui64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_add.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_classify.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_div.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_eq.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_eq_signaling.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_isSignalingNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_le.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_le_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_lt.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_lt_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_mulAdd.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_mul.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_rem.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_roundToInt.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_sqrt.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_sub.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i16.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i32.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i64.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_i64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui16.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui32.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui64.o
+obj-$(CONFIG_VECTOR_EMU)+= f32_to_ui64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_add.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_classify.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_div.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_eq.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_eq_signaling.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_isSignalingNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_le.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_le_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_lt.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_lt_quiet.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_mulAdd.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_mul.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_rem.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_roundToInt.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_sqrt.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_sub.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_i32.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_i32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_i64.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_i64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_ui32.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_ui32_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_ui64.o
+obj-$(CONFIG_VECTOR_EMU)+= f64_to_ui64_r_minMag.o
+obj-$(CONFIG_VECTOR_EMU)+= fall_maxmin.o
+obj-$(CONFIG_VECTOR_EMU)+= i32_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= i32_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= i32_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= i32_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= i64_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= i64_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= i64_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= i64_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_add128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_add256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addCarryM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addComplCarryM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addMagsF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addMagsF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addMagsF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addMagsF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_addM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_approxRecip_1Ks.o
+obj-$(CONFIG_VECTOR_EMU)+= s_approxRecip32_1.o
+obj-$(CONFIG_VECTOR_EMU)+= s_approxRecipSqrt_1Ks.o
+obj-$(CONFIG_VECTOR_EMU)+= s_approxRecipSqrt32_1.o
+obj-$(CONFIG_VECTOR_EMU)+= s_commonNaNToF32UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_commonNaNToF64UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_compare128M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_compare96M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_countLeadingZeros16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_countLeadingZeros32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_countLeadingZeros64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_countLeadingZeros8.o
+obj-$(CONFIG_VECTOR_EMU)+= s_eq128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_f32UIToCommonNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= s_f64UIToCommonNaN.o
+obj-$(CONFIG_VECTOR_EMU)+= s_le128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_lt128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul128By32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul128MTo256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul128To256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul64ByShifted32To128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul64To128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mul64To128M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mulAddF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mulAddF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mulAddF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_mulAddF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_negXM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normRoundPackToF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normRoundPackToF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normRoundPackToF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normRoundPackToF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normSubnormalF128Sig.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normSubnormalF16Sig.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normSubnormalF32Sig.o
+obj-$(CONFIG_VECTOR_EMU)+= s_normSubnormalF64Sig.o
+obj-$(CONFIG_VECTOR_EMU)+= softfloat_raiseFlags.o
+obj-$(CONFIG_VECTOR_EMU)+= softfloat_state.o
+obj-$(CONFIG_VECTOR_EMU)+= s_propagateNaNF16UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_propagateNaNF32UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_propagateNaNF64UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_propagateNaNF128UI.o
+obj-$(CONFIG_VECTOR_EMU)+= s_remStepMBy32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundMToI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundMToUI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackMToI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackMToUI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToI32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToUI32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundPackToUI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundToI32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundToI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundToUI32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_roundToUI64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam128Extra.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shiftRightJam64Extra.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftLeft128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftLeft64To96M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRight128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightExtendM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightJam128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightJam128Extra.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightJam64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightJam64Extra.o
+obj-$(CONFIG_VECTOR_EMU)+= s_shortShiftRightM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_sub128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_sub1XM.o
+obj-$(CONFIG_VECTOR_EMU)+= s_sub256M.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subMagsF128.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subMagsF16.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subMagsF32.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subMagsF64.o
+obj-$(CONFIG_VECTOR_EMU)+= s_subM.o
+obj-$(CONFIG_VECTOR_EMU)+= ui32_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= ui32_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= ui32_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= ui32_to_f64.o
+obj-$(CONFIG_VECTOR_EMU)+= ui64_to_f128.o
+obj-$(CONFIG_VECTOR_EMU)+= ui64_to_f16.o
+obj-$(CONFIG_VECTOR_EMU)+= ui64_to_f32.o
+obj-$(CONFIG_VECTOR_EMU)+= ui64_to_f64.o
+clean:
diff --git a/arch/riscv/kernel/soft_vector/softfloat/config.h b/arch/riscv/kernel/soft_vector/softfloat/config.h
new file mode 100644
index 000000000000..f425615d3489
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/config.h
@@ -0,0 +1,107 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Default value for --isa switch */
+#define DEFAULT_ISA "RV64IMAFDC"
+
+/* Default value for --priv switch */
+#define DEFAULT_PRIV "MSU"
+
+/* Default value for --vector switch */
+#define DEFAULT_VARCH "vlen:128,elen:64,slen:128"
+
+/* Path to the device-tree-compiler */
+#define DTC "dtc"
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+/* #undef DUMMY_ROCC_ENABLED */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `fesvr' library (-lfesvr). */
+/* #undef HAVE_LIBFESVR */
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+#define HAVE_LIBPTHREAD 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "Andrew Waterman"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "RISC-V ISA Simulator"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "RISC-V ISA Simulator ?"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "spike"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "?"
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#define RISCV_ENABLED /**/
+
+/* Enable commit log generation */
+/* #undef RISCV_ENABLE_COMMITLOG */
+
+/* Enable hardware management of PTE accessed and dirty bits */
+/* #undef RISCV_ENABLE_DIRTY */
+
+/* Enable PC histogram generation */
+/* #undef RISCV_ENABLE_HISTOGRAM */
+
+/* Enable hardware support for misaligned loads and stores */
+/* #undef RISCV_ENABLE_MISALIGNED */
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#define SOFTFLOAT_ENABLED /**/
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#define SPIKE_MAIN_ENABLED /**/
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_add.c b/arch/riscv/kernel/soft_vector/softfloat/f128_add.c
new file mode 100644
index 000000000000..94cea13434e8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_add.c
@@ -0,0 +1,78 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t f128_add( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
+    float128_t
+        (*magsFuncPtr)(
+            uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast64_t, bool );
+#endif
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    signB = signF128UI64( uiB64 );
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+    if ( signA == signB ) {
+        return softfloat_addMagsF128( uiA64, uiA0, uiB64, uiB0, signA );
+    } else {
+        return softfloat_subMagsF128( uiA64, uiA0, uiB64, uiB0, signA );
+    }
+#else
+    magsFuncPtr =
+        (signA == signB) ? softfloat_addMagsF128 : softfloat_subMagsF128;
+    return (*magsFuncPtr)( uiA64, uiA0, uiB64, uiB0, signA );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_classify.c b/arch/riscv/kernel/soft_vector/softfloat/f128_classify.c
new file mode 100644
index 000000000000..df2297395536
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_classify.c
@@ -0,0 +1,37 @@
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f128_classify( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+
+    uint_fast16_t infOrNaN = expF128UI64( uiA64 ) == 0x7FFF;
+    uint_fast16_t subnormalOrZero = expF128UI64( uiA64 ) == 0;
+    bool sign = signF128UI64( uiA64 );
+    bool fracZero = fracF128UI64( uiA64 ) == 0 && uiA0 == 0;
+    bool isNaN = isNaNF128UI( uiA64, uiA0 );
+    bool isSNaN = softfloat_isSigNaNF128UI( uiA64, uiA0 );
+
+    return
+        (  sign && infOrNaN && fracZero )          << 0 |
+        (  sign && !infOrNaN && !subnormalOrZero ) << 1 |
+        (  sign && subnormalOrZero && !fracZero )  << 2 |
+        (  sign && subnormalOrZero && fracZero )   << 3 |
+        ( !sign && infOrNaN && fracZero )          << 7 |
+        ( !sign && !infOrNaN && !subnormalOrZero ) << 6 |
+        ( !sign && subnormalOrZero && !fracZero )  << 5 |
+        ( !sign && subnormalOrZero && fracZero )   << 4 |
+        ( isNaN &&  isSNaN )                       << 8 |
+        ( isNaN && !isSNaN )                       << 9;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_div.c b/arch/riscv/kernel/soft_vector/softfloat/f128_div.c
new file mode 100644
index 000000000000..b95375b9a693
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_div.c
@@ -0,0 +1,199 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f128_div( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signB;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    bool signZ;
+    struct exp32_sig128 normExpSig;
+    int_fast32_t expZ;
+    struct uint128 rem;
+    uint_fast32_t recip32;
+    int ix;
+    uint_fast64_t q64;
+    uint_fast32_t q;
+    struct uint128 term;
+    uint_fast32_t qs[3];
+    uint_fast64_t sigZExtra;
+    struct uint128 sigZ, uiZ;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    signB = signF128UI64( uiB64 );
+    expB  = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if ( sigA.v64 | sigA.v0 ) goto propagateNaN;
+        if ( expB == 0x7FFF ) {
+            if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+            goto invalid;
+        }
+        goto infinity;
+    }
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+        goto zero;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! (sigB.v64 | sigB.v0) ) {
+            if ( ! (expA | sigA.v64 | sigA.v0) ) goto invalid;
+            softfloat_raiseFlags( softfloat_flag_infinite );
+            goto infinity;
+        }
+        normExpSig = softfloat_normSubnormalF128Sig( sigB.v64, sigB.v0 );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) goto zero;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA - expB + 0x3FFE;
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sigB.v64 |= UINT64_C( 0x0001000000000000 );
+    rem = sigA;
+    if ( softfloat_lt128( sigA.v64, sigA.v0, sigB.v64, sigB.v0 ) ) {
+        --expZ;
+        rem = softfloat_add128( sigA.v64, sigA.v0, sigA.v64, sigA.v0 );
+    }
+    recip32 = softfloat_approxRecip32_1( sigB.v64>>17 );
+    ix = 3;
+    for (;;) {
+        q64 = (uint_fast64_t) (uint32_t) (rem.v64>>19) * recip32;
+        q = (q64 + 0x80000000)>>32;
+        --ix;
+        if ( ix < 0 ) break;
+        rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+        term = softfloat_mul128By32( sigB.v64, sigB.v0, q );
+        rem = softfloat_sub128( rem.v64, rem.v0, term.v64, term.v0 );
+        if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+            --q;
+            rem = softfloat_add128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+        }
+        qs[ix] = q;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ((q + 1) & 7) < 2 ) {
+        rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+        term = softfloat_mul128By32( sigB.v64, sigB.v0, q );
+        rem = softfloat_sub128( rem.v64, rem.v0, term.v64, term.v0 );
+        if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+            --q;
+            rem = softfloat_add128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+        } else if ( softfloat_le128( sigB.v64, sigB.v0, rem.v64, rem.v0 ) ) {
+            ++q;
+            rem = softfloat_sub128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+        }
+        if ( rem.v64 | rem.v0 ) q |= 1;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sigZExtra = (uint64_t) ((uint_fast64_t) q<<60);
+    term = softfloat_shortShiftLeft128( 0, qs[1], 54 );
+    sigZ =
+        softfloat_add128(
+            (uint_fast64_t) qs[2]<<19, ((uint_fast64_t) qs[0]<<25) + (q>>4),
+            term.v64, term.v0
+        );
+    return
+        softfloat_roundPackToF128( signZ, expZ, sigZ.v64, sigZ.v0, sigZExtra );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infinity:
+    uiZ.v64 = packToF128UI64( signZ, 0x7FFF, 0 );
+    goto uiZ0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ.v64 = packToF128UI64( signZ, 0, 0 );
+ uiZ0:
+    uiZ.v0 = 0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_eq.c b/arch/riscv/kernel/soft_vector/softfloat/f128_eq.c
new file mode 100644
index 000000000000..de10a2598ec3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_eq.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f128_eq( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        if (
+               softfloat_isSigNaNF128UI( uiA64, uiA0 )
+            || softfloat_isSigNaNF128UI( uiB64, uiB0 )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    return
+           (uiA0 == uiB0)
+        && (   (uiA64 == uiB64)
+            || (! uiA0 && ! ((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF )))
+           );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_eq_signaling.c b/arch/riscv/kernel/soft_vector/softfloat/f128_eq_signaling.c
new file mode 100644
index 000000000000..fcf661229b14
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_eq_signaling.c
@@ -0,0 +1,67 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f128_eq_signaling( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    return
+           (uiA0 == uiB0)
+        && (   (uiA64 == uiB64)
+            || (! uiA0 && ! ((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF )))
+           );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_isSignalingNaN.c b/arch/riscv/kernel/soft_vector/softfloat/f128_isSignalingNaN.c
new file mode 100644
index 000000000000..bec24c5c2867
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_isSignalingNaN.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f128_isSignalingNaN( float128_t a )
+{
+    union ui128_f128 uA;
+
+    uA.f = a;
+    return softfloat_isSigNaNF128UI( uA.ui.v64, uA.ui.v0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_le.c b/arch/riscv/kernel/soft_vector/softfloat/f128_le.c
new file mode 100644
index 000000000000..38ffaf36de6a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_le.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f128_le( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF128UI64( uiA64 );
+    signB = signF128UI64( uiB64 );
+    return
+        (signA != signB)
+            ? signA
+                  || ! (((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                            | uiA0 | uiB0)
+            : ((uiA64 == uiB64) && (uiA0 == uiB0))
+                  || (signA ^ softfloat_lt128( uiA64, uiA0, uiB64, uiB0 ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_le_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f128_le_quiet.c
new file mode 100644
index 000000000000..b2a9048bf542
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_le_quiet.c
@@ -0,0 +1,78 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f128_le_quiet( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        if (
+               softfloat_isSigNaNF128UI( uiA64, uiA0 )
+            || softfloat_isSigNaNF128UI( uiB64, uiB0 )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF128UI64( uiA64 );
+    signB = signF128UI64( uiB64 );
+    return
+        (signA != signB)
+            ? signA
+                  || ! (((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                            | uiA0 | uiB0)
+            : ((uiA64 == uiB64) && (uiA0 == uiB0))
+                  || (signA ^ softfloat_lt128( uiA64, uiA0, uiB64, uiB0 ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_lt.c b/arch/riscv/kernel/soft_vector/softfloat/f128_lt.c
new file mode 100644
index 000000000000..3722db711890
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_lt.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f128_lt( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF128UI64( uiA64 );
+    signB = signF128UI64( uiB64 );
+    return
+        (signA != signB)
+            ? signA
+                  && (((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                          | uiA0 | uiB0)
+            : ((uiA64 != uiB64) || (uiA0 != uiB0))
+                  && (signA ^ softfloat_lt128( uiA64, uiA0, uiB64, uiB0 ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_lt_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f128_lt_quiet.c
new file mode 100644
index 000000000000..b05431d3693c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_lt_quiet.c
@@ -0,0 +1,78 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f128_lt_quiet( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    if ( isNaNF128UI( uiA64, uiA0 ) || isNaNF128UI( uiB64, uiB0 ) ) {
+        if (
+               softfloat_isSigNaNF128UI( uiA64, uiA0 )
+            || softfloat_isSigNaNF128UI( uiB64, uiB0 )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF128UI64( uiA64 );
+    signB = signF128UI64( uiB64 );
+    return
+        (signA != signB)
+            ? signA
+                  && (((uiA64 | uiB64) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                          | uiA0 | uiB0)
+            : ((uiA64 != uiB64) || (uiA0 != uiB0))
+                  && (signA ^ softfloat_lt128( uiA64, uiA0, uiB64, uiB0 ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_mul.c b/arch/riscv/kernel/soft_vector/softfloat/f128_mul.c
new file mode 100644
index 000000000000..e5dc189a5043
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_mul.c
@@ -0,0 +1,163 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f128_mul( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signB;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    bool signZ;
+    uint_fast64_t magBits;
+    struct exp32_sig128 normExpSig;
+    int_fast32_t expZ;
+    uint64_t sig256Z[4];
+    uint_fast64_t sigZExtra;
+    struct uint128 sigZ;
+    struct uint128_extra sig128Extra;
+    struct uint128 uiZ;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    signB = signF128UI64( uiB64 );
+    expB  = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if (
+            (sigA.v64 | sigA.v0) || ((expB == 0x7FFF) && (sigB.v64 | sigB.v0))
+        ) {
+            goto propagateNaN;
+        }
+        magBits = expB | sigB.v64 | sigB.v0;
+        goto infArg;
+    }
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+        magBits = expA | sigA.v64 | sigA.v0;
+        goto infArg;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) goto zero;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! (sigB.v64 | sigB.v0) ) goto zero;
+        normExpSig = softfloat_normSubnormalF128Sig( sigB.v64, sigB.v0 );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x4000;
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sigB = softfloat_shortShiftLeft128( sigB.v64, sigB.v0, 16 );
+    softfloat_mul128To256M( sigA.v64, sigA.v0, sigB.v64, sigB.v0, sig256Z );
+    sigZExtra = sig256Z[indexWord( 4, 1 )] | (sig256Z[indexWord( 4, 0 )] != 0);
+    sigZ =
+        softfloat_add128(
+            sig256Z[indexWord( 4, 3 )], sig256Z[indexWord( 4, 2 )],
+            sigA.v64, sigA.v0
+        );
+    if ( UINT64_C( 0x0002000000000000 ) <= sigZ.v64 ) {
+        ++expZ;
+        sig128Extra =
+            softfloat_shortShiftRightJam128Extra(
+                sigZ.v64, sigZ.v0, sigZExtra, 1 );
+        sigZ = sig128Extra.v;
+        sigZExtra = sig128Extra.extra;
+    }
+    return
+        softfloat_roundPackToF128( signZ, expZ, sigZ.v64, sigZ.v0, sigZExtra );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infArg:
+    if ( ! magBits ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ.v64 = defaultNaNF128UI64;
+        uiZ.v0  = defaultNaNF128UI0;
+        goto uiZ;
+    }
+    uiZ.v64 = packToF128UI64( signZ, 0x7FFF, 0 );
+    goto uiZ0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ.v64 = packToF128UI64( signZ, 0, 0 );
+ uiZ0:
+    uiZ.v0 = 0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_mulAdd.c b/arch/riscv/kernel/soft_vector/softfloat/f128_mulAdd.c
new file mode 100644
index 000000000000..d4fd9e0eeb04
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_mulAdd.c
@@ -0,0 +1,63 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t f128_mulAdd( float128_t a, float128_t b, float128_t c )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    union ui128_f128 uC;
+    uint_fast64_t uiC64, uiC0;
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    uC.f = c;
+    uiC64 = uC.ui.v64;
+    uiC0  = uC.ui.v0;
+    return softfloat_mulAddF128( uiA64, uiA0, uiB64, uiB0, uiC64, uiC0, 0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_rem.c b/arch/riscv/kernel/soft_vector/softfloat/f128_rem.c
new file mode 100644
index 000000000000..eee31096d884
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_rem.c
@@ -0,0 +1,190 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f128_rem( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    struct exp32_sig128 normExpSig;
+    struct uint128 rem;
+    int_fast32_t expDiff;
+    uint_fast32_t q, recip32;
+    uint_fast64_t q64;
+    struct uint128 term, altRem, meanRem;
+    bool signRem;
+    struct uint128 uiZ;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    expB  = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if (
+            (sigA.v64 | sigA.v0) || ((expB == 0x7FFF) && (sigB.v64 | sigB.v0))
+        ) {
+            goto propagateNaN;
+        }
+        goto invalid;
+    }
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! (sigB.v64 | sigB.v0) ) goto invalid;
+        normExpSig = softfloat_normSubnormalF128Sig( sigB.v64, sigB.v0 );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) return a;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sigB.v64 |= UINT64_C( 0x0001000000000000 );
+    rem = sigA;
+    expDiff = expA - expB;
+    if ( expDiff < 1 ) {
+        if ( expDiff < -1 ) return a;
+        if ( expDiff ) {
+            --expB;
+            sigB = softfloat_add128( sigB.v64, sigB.v0, sigB.v64, sigB.v0 );
+            q = 0;
+        } else {
+            q = softfloat_le128( sigB.v64, sigB.v0, rem.v64, rem.v0 );
+            if ( q ) {
+                rem = softfloat_sub128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+            }
+        }
+    } else {
+        recip32 = softfloat_approxRecip32_1( sigB.v64>>17 );
+        expDiff -= 30;
+        for (;;) {
+            q64 = (uint_fast64_t) (uint32_t) (rem.v64>>19) * recip32;
+            if ( expDiff < 0 ) break;
+            q = (q64 + 0x80000000)>>32;
+            rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+            term = softfloat_mul128By32( sigB.v64, sigB.v0, q );
+            rem = softfloat_sub128( rem.v64, rem.v0, term.v64, term.v0 );
+            if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+                rem = softfloat_add128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+            }
+            expDiff -= 29;
+        }
+        /*--------------------------------------------------------------------
+        | (`expDiff' cannot be less than -29 here.)
+        *--------------------------------------------------------------------*/
+        q = (uint32_t) (q64>>32)>>(~expDiff & 31);
+        rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, expDiff + 30 );
+        term = softfloat_mul128By32( sigB.v64, sigB.v0, q );
+        rem = softfloat_sub128( rem.v64, rem.v0, term.v64, term.v0 );
+        if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+            altRem = softfloat_add128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+            goto selectRem;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    do {
+        altRem = rem;
+        ++q;
+        rem = softfloat_sub128( rem.v64, rem.v0, sigB.v64, sigB.v0 );
+    } while ( ! (rem.v64 & UINT64_C( 0x8000000000000000 )) );
+ selectRem:
+    meanRem = softfloat_add128( rem.v64, rem.v0, altRem.v64, altRem.v0 );
+    if (
+        (meanRem.v64 & UINT64_C( 0x8000000000000000 ))
+            || (! (meanRem.v64 | meanRem.v0) && (q & 1))
+    ) {
+        rem = altRem;
+    }
+    signRem = signA;
+    if ( rem.v64 & UINT64_C( 0x8000000000000000 ) ) {
+        signRem = ! signRem;
+        rem = softfloat_sub128( 0, 0, rem.v64, rem.v0 );
+    }
+    return softfloat_normRoundPackToF128( signRem, expB - 1, rem.v64, rem.v0 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_roundToInt.c b/arch/riscv/kernel/soft_vector/softfloat/f128_roundToInt.c
new file mode 100644
index 000000000000..88330b60996a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_roundToInt.c
@@ -0,0 +1,160 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t
+ f128_roundToInt( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    int_fast32_t exp;
+    struct uint128 uiZ;
+    uint_fast64_t lastBitMask, roundBitsMask;
+    bool roundNearEven;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    exp = expF128UI64( uiA64 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x402F <= exp ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( 0x406F <= exp ) {
+            if ( (exp == 0x7FFF) && (fracF128UI64( uiA64 ) | uiA0) ) {
+                uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, 0, 0 );
+                goto uiZ;
+            }
+            return a;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        lastBitMask = (uint_fast64_t) 2<<(0x406E - exp);
+        roundBitsMask = lastBitMask - 1;
+        uiZ.v64 = uiA64;
+        uiZ.v0  = uiA0;
+        roundNearEven = (roundingMode == softfloat_round_near_even);
+        if ( roundNearEven || (roundingMode == softfloat_round_near_maxMag) ) {
+            if ( exp == 0x402F ) {
+                if ( UINT64_C( 0x8000000000000000 ) <= uiZ.v0 ) {
+                    ++uiZ.v64;
+                    if (
+                        roundNearEven
+                            && (uiZ.v0 == UINT64_C( 0x8000000000000000 ))
+                    ) {
+                        uiZ.v64 &= ~1;
+                    }
+                }
+            } else {
+                uiZ = softfloat_add128( uiZ.v64, uiZ.v0, 0, lastBitMask>>1 );
+                if ( roundNearEven && ! (uiZ.v0 & roundBitsMask) ) {
+                    uiZ.v0 &= ~lastBitMask;
+                }
+            }
+        } else if (
+            roundingMode
+                == (signF128UI64( uiZ.v64 ) ? softfloat_round_min
+                        : softfloat_round_max)
+        ) {
+            uiZ = softfloat_add128( uiZ.v64, uiZ.v0, 0, roundBitsMask );
+        }
+        uiZ.v0 &= ~roundBitsMask;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( exp < 0x3FFF ) {
+            if ( ! ((uiA64 & UINT64_C( 0x7FFFFFFFFFFFFFFF )) | uiA0) ) {
+                return a;
+            }
+            if ( exact ) softfloat_exceptionFlags |= softfloat_flag_inexact;
+            uiZ.v64 = uiA64 & packToF128UI64( 1, 0, 0 );
+            uiZ.v0  = 0;
+            switch ( roundingMode ) {
+             case softfloat_round_near_even:
+                if ( ! (fracF128UI64( uiA64 ) | uiA0) ) break;
+             case softfloat_round_near_maxMag:
+                if ( exp == 0x3FFE ) uiZ.v64 |= packToF128UI64( 0, 0x3FFF, 0 );
+                break;
+             case softfloat_round_min:
+                if ( uiZ.v64 ) uiZ.v64 = packToF128UI64( 1, 0x3FFF, 0 );
+                break;
+             case softfloat_round_max:
+                if ( ! uiZ.v64 ) uiZ.v64 = packToF128UI64( 0, 0x3FFF, 0 );
+                break;
+            }
+            goto uiZ;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        uiZ.v64 = uiA64;
+        uiZ.v0  = 0;
+        lastBitMask = (uint_fast64_t) 1<<(0x402F - exp);
+        roundBitsMask = lastBitMask - 1;
+        if ( roundingMode == softfloat_round_near_maxMag ) {
+            uiZ.v64 += lastBitMask>>1;
+        } else if ( roundingMode == softfloat_round_near_even ) {
+            uiZ.v64 += lastBitMask>>1;
+            if ( ! ((uiZ.v64 & roundBitsMask) | uiA0) ) {
+                uiZ.v64 &= ~lastBitMask;
+            }
+        } else if (
+            roundingMode
+                == (signF128UI64( uiZ.v64 ) ? softfloat_round_min
+                        : softfloat_round_max)
+        ) {
+            uiZ.v64 = (uiZ.v64 | (uiA0 != 0)) + roundBitsMask;
+        }
+        uiZ.v64 &= ~roundBitsMask;
+    }
+    if ( exact && ((uiZ.v64 != uiA64) || (uiZ.v0 != uiA0)) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_sqrt.c b/arch/riscv/kernel/soft_vector/softfloat/f128_sqrt.c
new file mode 100644
index 000000000000..20094106a21a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_sqrt.c
@@ -0,0 +1,201 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f128_sqrt( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA, uiZ;
+    struct exp32_sig128 normExpSig;
+    int_fast32_t expZ;
+    uint_fast32_t sig32A, recipSqrt32, sig32Z;
+    struct uint128 rem;
+    uint32_t qs[3];
+    uint_fast32_t q;
+    uint_fast64_t x64, sig64Z;
+    struct uint128 y, term;
+    uint_fast64_t sigZExtra;
+    struct uint128 sigZ;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if ( sigA.v64 | sigA.v0 ) {
+            uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, 0, 0 );
+            goto uiZ;
+        }
+        if ( ! signA ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signA ) {
+        if ( ! (expA | sigA.v64 | sigA.v0) ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) return a;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    | (`sig32Z' is guaranteed to be a lower bound on the square root of
+    | `sig32A', which makes `sig32Z' also a lower bound on the square root of
+    | `sigA'.)
+    *------------------------------------------------------------------------*/
+    expZ = ((expA - 0x3FFF)>>1) + 0x3FFE;
+    expA &= 1;
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sig32A = sigA.v64>>17;
+    recipSqrt32 = softfloat_approxRecipSqrt32_1( expA, sig32A );
+    sig32Z = ((uint_fast64_t) sig32A * recipSqrt32)>>32;
+    if ( expA ) {
+        sig32Z >>= 1;
+        rem = softfloat_shortShiftLeft128( sigA.v64, sigA.v0, 12 );
+    } else {
+        rem = softfloat_shortShiftLeft128( sigA.v64, sigA.v0, 13 );
+    }
+    qs[2] = sig32Z;
+    rem.v64 -= (uint_fast64_t) sig32Z * sig32Z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    q = ((uint32_t) (rem.v64>>2) * (uint_fast64_t) recipSqrt32)>>32;
+    x64 = (uint_fast64_t) sig32Z<<32;
+    sig64Z = x64 + ((uint_fast64_t) q<<3);
+    y = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+    /*------------------------------------------------------------------------
+    | (Repeating this loop is a rare occurrence.)
+    *------------------------------------------------------------------------*/
+    for (;;) {
+        term = softfloat_mul64ByShifted32To128( x64 + sig64Z, q );
+        rem = softfloat_sub128( y.v64, y.v0, term.v64, term.v0 );
+        if ( ! (rem.v64 & UINT64_C( 0x8000000000000000 )) ) break;
+        --q;
+        sig64Z -= 1<<3;
+    }
+    qs[1] = q;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    q = ((rem.v64>>2) * recipSqrt32)>>32;
+    y = softfloat_shortShiftLeft128( rem.v64, rem.v0, 29 );
+    sig64Z <<= 1;
+    /*------------------------------------------------------------------------
+    | (Repeating this loop is a rare occurrence.)
+    *------------------------------------------------------------------------*/
+    for (;;) {
+        term = softfloat_shortShiftLeft128( 0, sig64Z, 32 );
+        term = softfloat_add128( term.v64, term.v0, 0, (uint_fast64_t) q<<6 );
+        term = softfloat_mul128By32( term.v64, term.v0, q );
+        rem = softfloat_sub128( y.v64, y.v0, term.v64, term.v0 );
+        if ( ! (rem.v64 & UINT64_C( 0x8000000000000000 )) ) break;
+        --q;
+    }
+    qs[0] = q;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    q = (((rem.v64>>2) * recipSqrt32)>>32) + 2;
+    sigZExtra = (uint64_t) ((uint_fast64_t) q<<59);
+    term = softfloat_shortShiftLeft128( 0, qs[1], 53 );
+    sigZ =
+        softfloat_add128(
+            (uint_fast64_t) qs[2]<<18, ((uint_fast64_t) qs[0]<<24) + (q>>5),
+            term.v64, term.v0
+        );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( (q & 0xF) <= 2 ) {
+        q &= ~3;
+        sigZExtra = (uint64_t) ((uint_fast64_t) q<<59);
+        y = softfloat_shortShiftLeft128( sigZ.v64, sigZ.v0, 6 );
+        y.v0 |= sigZExtra>>58;
+        term = softfloat_sub128( y.v64, y.v0, 0, q );
+        y    = softfloat_mul64ByShifted32To128( term.v0,  q );
+        term = softfloat_mul64ByShifted32To128( term.v64, q );
+        term = softfloat_add128( term.v64, term.v0, 0, y.v64 );
+        rem = softfloat_shortShiftLeft128( rem.v64, rem.v0, 20 );
+        term = softfloat_sub128( term.v64, term.v0, rem.v64, rem.v0 );
+        /*--------------------------------------------------------------------
+        | The concatenation of `term' and `y.v0' is now the negative remainder
+        | (3 words altogether).
+        *--------------------------------------------------------------------*/
+        if ( term.v64 & UINT64_C( 0x8000000000000000 ) ) {
+            sigZExtra |= 1;
+        } else {
+            if ( term.v64 | term.v0 | y.v0 ) {
+                if ( sigZExtra ) {
+                    --sigZExtra;
+                } else {
+                    sigZ = softfloat_sub128( sigZ.v64, sigZ.v0, 0, 1 );
+                    sigZExtra = ~0;
+                }
+            }
+        }
+    }
+    return softfloat_roundPackToF128( 0, expZ, sigZ.v64, sigZ.v0, sigZExtra );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_sub.c b/arch/riscv/kernel/soft_vector/softfloat/f128_sub.c
new file mode 100644
index 000000000000..da433b24d271
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_sub.c
@@ -0,0 +1,78 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t f128_sub( float128_t a, float128_t b )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool signA;
+    union ui128_f128 uB;
+    uint_fast64_t uiB64, uiB0;
+    bool signB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
+    float128_t
+        (*magsFuncPtr)(
+            uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast64_t, bool );
+#endif
+
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    signA = signF128UI64( uiA64 );
+    uB.f = b;
+    uiB64 = uB.ui.v64;
+    uiB0  = uB.ui.v0;
+    signB = signF128UI64( uiB64 );
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+    if ( signA == signB ) {
+        return softfloat_subMagsF128( uiA64, uiA0, uiB64, uiB0, signA );
+    } else {
+        return softfloat_addMagsF128( uiA64, uiA0, uiB64, uiB0, signA );
+    }
+#else
+    magsFuncPtr =
+        (signA == signB) ? softfloat_subMagsF128 : softfloat_addMagsF128;
+    return (*magsFuncPtr)( uiA64, uiA0, uiB64, uiB0, signA );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f16.c
new file mode 100644
index 000000000000..cfcc646f71b9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f16.c
@@ -0,0 +1,95 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f128_to_f16( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t frac64;
+    struct commonNaN commonNaN;
+    uint_fast16_t uiZ, frac16;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    frac64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FFF ) {
+        if ( frac64 ) {
+            softfloat_f128UIToCommonNaN( uiA64, uiA0, &commonNaN );
+            uiZ = softfloat_commonNaNToF16UI( &commonNaN );
+        } else {
+            uiZ = packToF16UI( sign, 0x1F, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac16 = softfloat_shortShiftRightJam64( frac64, 34 );
+    if ( ! (exp | frac16) ) {
+        uiZ = packToF16UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    exp -= 0x3FF1;
+    if ( sizeof (int_fast16_t) < sizeof (int_fast32_t) ) {
+        if ( exp < -0x40 ) exp = -0x40;
+    }
+    return softfloat_roundPackToF16( sign, exp, frac16 | 0x4000 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f32.c
new file mode 100644
index 000000000000..58aaada58b95
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f32.c
@@ -0,0 +1,95 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f128_to_f32( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t frac64;
+    struct commonNaN commonNaN;
+    uint_fast32_t uiZ, frac32;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    frac64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FFF ) {
+        if ( frac64 ) {
+            softfloat_f128UIToCommonNaN( uiA64, uiA0, &commonNaN );
+            uiZ = softfloat_commonNaNToF32UI( &commonNaN );
+        } else {
+            uiZ = packToF32UI( sign, 0xFF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac32 = softfloat_shortShiftRightJam64( frac64, 18 );
+    if ( ! (exp | frac32) ) {
+        uiZ = packToF32UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    exp -= 0x3F81;
+    if ( sizeof (int_fast16_t) < sizeof (int_fast32_t) ) {
+        if ( exp < -0x1000 ) exp = -0x1000;
+    }
+    return softfloat_roundPackToF32( sign, exp, frac32 | 0x40000000 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f64.c
new file mode 100644
index 000000000000..c6ad8f2e84b1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_f64.c
@@ -0,0 +1,100 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f128_to_f64( float128_t a )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t frac64, frac0;
+    struct commonNaN commonNaN;
+    uint_fast64_t uiZ;
+    struct uint128 frac128;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    frac64 = fracF128UI64( uiA64 );
+    frac0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FFF ) {
+        if ( frac64 | frac0 ) {
+            softfloat_f128UIToCommonNaN( uiA64, uiA0, &commonNaN );
+            uiZ = softfloat_commonNaNToF64UI( &commonNaN );
+        } else {
+            uiZ = packToF64UI( sign, 0x7FF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac128 = softfloat_shortShiftLeft128( frac64, frac0, 14 );
+    frac64 = frac128.v64 | (frac128.v0 != 0);
+    if ( ! (exp | frac64) ) {
+        uiZ = packToF64UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    exp -= 0x3C01;
+    if ( sizeof (int_fast16_t) < sizeof (int_fast32_t) ) {
+        if ( exp < -0x1000 ) exp = -0x1000;
+    }
+    return
+        softfloat_roundPackToF64(
+            sign, exp, frac64 | UINT64_C( 0x4000000000000000 ) );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32.c
new file mode 100644
index 000000000000..3f0a8a3fcb63
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32.c
@@ -0,0 +1,85 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f128_to_i32( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (i32_fromNaN != i32_fromPosOverflow) || (i32_fromNaN != i32_fromNegOverflow)
+    if ( (exp == 0x7FFF) && (sig64 | sig0) ) {
+#if (i32_fromNaN == i32_fromPosOverflow)
+        sign = 0;
+#elif (i32_fromNaN == i32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return i32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig64 |= UINT64_C( 0x0001000000000000 );
+    sig64 |= (sig0 != 0);
+    shiftDist = 0x4023 - exp;
+    if ( 0 < shiftDist ) sig64 = softfloat_shiftRightJam64( sig64, shiftDist );
+    return softfloat_roundToI32( sign, sig64, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32_r_minMag.c
new file mode 100644
index 000000000000..17334331c24d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i32_r_minMag.c
@@ -0,0 +1,100 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f128_to_i32_r_minMag( float128_t a, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    int_fast32_t exp;
+    uint_fast64_t sig64;
+    int_fast32_t shiftDist;
+    bool sign;
+    int_fast32_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( 49 <= shiftDist ) {
+        if ( exact && (exp | sig64) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF128UI64( uiA64 );
+    if ( shiftDist < 18 ) {
+        if (
+            sign && (shiftDist == 17)
+                && (sig64 < UINT64_C( 0x0000000000020000 ))
+        ) {
+            if ( exact && sig64 ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return -0x7FFFFFFF - 1;
+        }
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x7FFF) && sig64 ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig64 |= UINT64_C( 0x0001000000000000 );
+    absZ = sig64>>shiftDist;
+    if (
+        exact && ((uint_fast64_t) (uint_fast32_t) absZ<<shiftDist != sig64)
+    ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64.c
new file mode 100644
index 000000000000..dc2115100d6b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64.c
@@ -0,0 +1,95 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f128_to_i64( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+    struct uint128 sig128;
+    struct uint64_extra sigExtra;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( shiftDist <= 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( shiftDist < -15 ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            return
+                (exp == 0x7FFF) && (sig64 | sig0) ? i64_fromNaN
+                    : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        if ( shiftDist ) {
+            sig128 = softfloat_shortShiftLeft128( sig64, sig0, -shiftDist );
+            sig64 = sig128.v64;
+            sig0  = sig128.v0;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( exp ) sig64 |= UINT64_C( 0x0001000000000000 );
+        sigExtra = softfloat_shiftRightJam64Extra( sig64, sig0, shiftDist );
+        sig64 = sigExtra.v;
+        sig0  = sigExtra.extra;
+    }
+    return softfloat_roundToI64( sign, sig64, sig0, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64_r_minMag.c
new file mode 100644
index 000000000000..42313a3fbe5d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_i64_r_minMag.c
@@ -0,0 +1,113 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f128_to_i64_r_minMag( float128_t a, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+    int_fast8_t negShiftDist;
+    int_fast64_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( shiftDist < 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( shiftDist < -14 ) {
+            if (
+                   (uiA64 == UINT64_C( 0xC03E000000000000 ))
+                && (sig0 < UINT64_C( 0x0002000000000000 ))
+            ) {
+                if ( exact && sig0 ) {
+                    softfloat_exceptionFlags |= softfloat_flag_inexact;
+                }
+                return -INT64_C( 0x7FFFFFFFFFFFFFFF ) - 1;
+            }
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            return
+                (exp == 0x7FFF) && (sig64 | sig0) ? i64_fromNaN
+                    : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        negShiftDist = -shiftDist;
+        absZ = sig64<<negShiftDist | sig0>>(shiftDist & 63);
+        if ( exact && (uint64_t) (sig0<<negShiftDist) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( 49 <= shiftDist ) {
+            if ( exact && (exp | sig64 | sig0) ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return 0;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        absZ = sig64>>shiftDist;
+        if ( exact && (sig0 || (absZ<<shiftDist != sig64)) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32.c
new file mode 100644
index 000000000000..463d87288597
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32.c
@@ -0,0 +1,86 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t
+ f128_to_ui32( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64;
+    int_fast32_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (ui32_fromNaN != ui32_fromPosOverflow) || (ui32_fromNaN != ui32_fromNegOverflow)
+    if ( (exp == 0x7FFF) && sig64 ) {
+#if (ui32_fromNaN == ui32_fromPosOverflow)
+        sign = 0;
+#elif (ui32_fromNaN == ui32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return ui32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig64 |= UINT64_C( 0x0001000000000000 );
+    shiftDist = 0x4023 - exp;
+    if ( 0 < shiftDist ) {
+        sig64 = softfloat_shiftRightJam64( sig64, shiftDist );
+    }
+    return softfloat_roundToUI32( sign, sig64, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32_r_minMag.c
new file mode 100644
index 000000000000..3e4c4c8c3e60
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui32_r_minMag.c
@@ -0,0 +1,89 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f128_to_ui32_r_minMag( float128_t a, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    int_fast32_t exp;
+    uint_fast64_t sig64;
+    int_fast32_t shiftDist;
+    bool sign;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 ) | (uiA0 != 0);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( 49 <= shiftDist ) {
+        if ( exact && (exp | sig64) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF128UI64( uiA64 );
+    if ( sign || (shiftDist < 17) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x7FFF) && sig64 ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig64 |= UINT64_C( 0x0001000000000000 );
+    z = sig64>>shiftDist;
+    if ( exact && ((uint_fast64_t) z<<shiftDist != sig64) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64.c
new file mode 100644
index 000000000000..53d5ef2c9496
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ f128_to_ui64( float128_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+    struct uint128 sig128;
+    struct uint64_extra sigExtra;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( shiftDist <= 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( shiftDist < -15 ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            return
+                (exp == 0x7FFF) && (sig64 | sig0) ? ui64_fromNaN
+                    : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        if ( shiftDist ) {
+            sig128 = softfloat_shortShiftLeft128( sig64, sig0, -shiftDist );
+            sig64 = sig128.v64;
+            sig0  = sig128.v0;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( exp ) sig64 |= UINT64_C( 0x0001000000000000 );
+        sigExtra = softfloat_shiftRightJam64Extra( sig64, sig0, shiftDist );
+        sig64 = sigExtra.v;
+        sig0  = sigExtra.extra;
+    }
+    return softfloat_roundToUI64( sign, sig64, sig0, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64_r_minMag.c
new file mode 100644
index 000000000000..fb478012c953
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f128_to_ui64_r_minMag.c
@@ -0,0 +1,105 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f128_to_ui64_r_minMag( float128_t a, bool exact )
+{
+    union ui128_f128 uA;
+    uint_fast64_t uiA64, uiA0;
+    bool sign;
+    int_fast32_t exp;
+    uint_fast64_t sig64, sig0;
+    int_fast32_t shiftDist;
+    int_fast8_t negShiftDist;
+    uint_fast64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA64 = uA.ui.v64;
+    uiA0  = uA.ui.v0;
+    sign  = signF128UI64( uiA64 );
+    exp   = expF128UI64( uiA64 );
+    sig64 = fracF128UI64( uiA64 );
+    sig0  = uiA0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x402F - exp;
+    if ( shiftDist < 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( sign || (shiftDist < -15) ) goto invalid;
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        negShiftDist = -shiftDist;
+        z = sig64<<negShiftDist | sig0>>(shiftDist & 63);
+        if ( exact && (uint64_t) (sig0<<negShiftDist) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( 49 <= shiftDist ) {
+            if ( exact && (exp | sig64 | sig0) ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return 0;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( sign ) goto invalid;
+        sig64 |= UINT64_C( 0x0001000000000000 );
+        z = sig64>>shiftDist;
+        if ( exact && (sig0 || (z<<shiftDist != sig64)) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return
+        (exp == 0x7FFF) && (sig64 | sig0) ? ui64_fromNaN
+            : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_add.c b/arch/riscv/kernel/soft_vector/softfloat/f16_add.c
new file mode 100644
index 000000000000..c89b55ffde6d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_add.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t f16_add( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 1)
+    float16_t (*magsFuncPtr)( uint_fast16_t, uint_fast16_t );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+    if ( signF16UI( uiA ^ uiB ) ) {
+        return softfloat_subMagsF16( uiA, uiB );
+    } else {
+        return softfloat_addMagsF16( uiA, uiB );
+    }
+#else
+    magsFuncPtr =
+        signF16UI( uiA ^ uiB ) ? softfloat_subMagsF16 : softfloat_addMagsF16;
+    return (*magsFuncPtr)( uiA, uiB );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_classify.c b/arch/riscv/kernel/soft_vector/softfloat/f16_classify.c
new file mode 100644
index 000000000000..4a1191679123
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_classify.c
@@ -0,0 +1,36 @@
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f16_classify( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+
+    uA.f = a;
+    uiA = uA.ui;
+
+    uint_fast16_t infOrNaN = expF16UI( uiA ) == 0x1F;
+    uint_fast16_t subnormalOrZero = expF16UI( uiA ) == 0;
+    bool sign = signF16UI( uiA );
+    bool fracZero = fracF16UI( uiA ) == 0;
+    bool isNaN = isNaNF16UI( uiA );
+    bool isSNaN = softfloat_isSigNaNF16UI( uiA );
+
+    return
+        (  sign && infOrNaN && fracZero )          << 0 |
+        (  sign && !infOrNaN && !subnormalOrZero ) << 1 |
+        (  sign && subnormalOrZero && !fracZero )  << 2 |
+        (  sign && subnormalOrZero && fracZero )   << 3 |
+        ( !sign && infOrNaN && fracZero )          << 7 |
+        ( !sign && !infOrNaN && !subnormalOrZero ) << 6 |
+        ( !sign && subnormalOrZero && !fracZero )  << 5 |
+        ( !sign && subnormalOrZero && fracZero )   << 4 |
+        ( isNaN &&  isSNaN )                       << 8 |
+        ( isNaN && !isSNaN )                       << 9;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_div.c b/arch/riscv/kernel/soft_vector/softfloat/f16_div.c
new file mode 100644
index 000000000000..9c5d33b2874e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_div.c
@@ -0,0 +1,186 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+extern const uint16_t softfloat_approxRecip_1k0s[];
+extern const uint16_t softfloat_approxRecip_1k1s[];
+
+float16_t f16_div( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signB;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    bool signZ;
+    struct exp8_sig16 normExpSig;
+    int_fast8_t expZ;
+#ifdef SOFTFLOAT_FAST_DIV32TO16
+    uint_fast32_t sig32A;
+    uint_fast16_t sigZ;
+#else
+    int index;
+    uint16_t r0;
+    uint_fast16_t sigZ, rem;
+#endif
+    uint_fast16_t uiZ;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF16UI( uiB );
+    expB  = expF16UI( uiB );
+    sigB  = fracF16UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA ) goto propagateNaN;
+        if ( expB == 0x1F ) {
+            if ( sigB ) goto propagateNaN;
+            goto invalid;
+        }
+        goto infinity;
+    }
+    if ( expB == 0x1F ) {
+        if ( sigB ) goto propagateNaN;
+        goto zero;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) {
+            if ( ! (expA | sigA) ) goto invalid;
+            softfloat_raiseFlags( softfloat_flag_infinite );
+            goto infinity;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA - expB + 0xE;
+    sigA |= 0x0400;
+    sigB |= 0x0400;
+#ifdef SOFTFLOAT_FAST_DIV32TO16
+    if ( sigA < sigB ) {
+        --expZ;
+        sig32A = (uint_fast32_t) sigA<<15;
+    } else {
+        sig32A = (uint_fast32_t) sigA<<14;
+    }
+    sigZ = sig32A / sigB;
+    if ( ! (sigZ & 7) ) sigZ |= ((uint_fast32_t) sigB * sigZ != sig32A);
+#else
+    if ( sigA < sigB ) {
+        --expZ;
+        sigA <<= 5;
+    } else {
+        sigA <<= 4;
+    }
+    index = sigB>>6 & 0xF;
+    r0 = softfloat_approxRecip_1k0s[index]
+             - (((uint_fast32_t) softfloat_approxRecip_1k1s[index]
+                     * (sigB & 0x3F))
+                    >>10);
+    sigZ = ((uint_fast32_t) sigA * r0)>>16;
+    rem = (sigA<<10) - sigZ * sigB;
+    sigZ += (rem * (uint_fast32_t) r0)>>26;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    ++sigZ;
+    if ( ! (sigZ & 7) ) {
+        sigZ &= ~1;
+        rem = (sigA<<10) - sigZ * sigB;
+        if ( rem & 0x8000 ) {
+            sigZ -= 2;
+        } else {
+            if ( rem ) sigZ |= 1;
+        }
+    }
+#endif
+    return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF16UI;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infinity:
+    uiZ = packToF16UI( signZ, 0x1F, 0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF16UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_eq.c b/arch/riscv/kernel/soft_vector/softfloat/f16_eq.c
new file mode 100644
index 000000000000..057354b209ff
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_eq.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f16_eq( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF16UI( uiA ) || softfloat_isSigNaNF16UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    return (uiA == uiB) || ! (uint16_t) ((uiA | uiB)<<1);
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_eq_signaling.c b/arch/riscv/kernel/soft_vector/softfloat/f16_eq_signaling.c
new file mode 100644
index 000000000000..ad6fe11f93a2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_eq_signaling.c
@@ -0,0 +1,61 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f16_eq_signaling( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    return (uiA == uiB) || ! (uint16_t) ((uiA | uiB)<<1);
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_isSignalingNaN.c b/arch/riscv/kernel/soft_vector/softfloat/f16_isSignalingNaN.c
new file mode 100644
index 000000000000..81082a26a929
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_isSignalingNaN.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f16_isSignalingNaN( float16_t a )
+{
+    union ui16_f16 uA;
+
+    uA.f = a;
+    return softfloat_isSigNaNF16UI( uA.ui );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_le.c b/arch/riscv/kernel/soft_vector/softfloat/f16_le.c
new file mode 100644
index 000000000000..736d3c35ab30
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_le.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f16_le( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF16UI( uiA );
+    signB = signF16UI( uiB );
+    return
+        (signA != signB) ? signA || ! (uint16_t) ((uiA | uiB)<<1)
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_le_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f16_le_quiet.c
new file mode 100644
index 000000000000..22430d0b5a69
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_le_quiet.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f16_le_quiet( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF16UI( uiA ) || softfloat_isSigNaNF16UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF16UI( uiA );
+    signB = signF16UI( uiB );
+    return
+        (signA != signB) ? signA || ! (uint16_t) ((uiA | uiB)<<1)
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_lt.c b/arch/riscv/kernel/soft_vector/softfloat/f16_lt.c
new file mode 100644
index 000000000000..d0e6a31d038f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_lt.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f16_lt( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF16UI( uiA );
+    signB = signF16UI( uiB );
+    return
+        (signA != signB) ? signA && ((uint16_t) ((uiA | uiB)<<1) != 0)
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_lt_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f16_lt_quiet.c
new file mode 100644
index 000000000000..14c9a1c58aa9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_lt_quiet.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f16_lt_quiet( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF16UI( uiA ) || isNaNF16UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF16UI( uiA ) || softfloat_isSigNaNF16UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF16UI( uiA );
+    signB = signF16UI( uiB );
+    return
+        (signA != signB) ? signA && ((uint16_t) ((uiA | uiB)<<1) != 0)
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_mul.c b/arch/riscv/kernel/soft_vector/softfloat/f16_mul.c
new file mode 100644
index 000000000000..c0d4177acdd4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_mul.c
@@ -0,0 +1,140 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f16_mul( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    bool signB;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    bool signZ;
+    uint_fast16_t magBits;
+    struct exp8_sig16 normExpSig;
+    int_fast8_t expZ;
+    uint_fast32_t sig32Z;
+    uint_fast16_t sigZ, uiZ;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF16UI( uiB );
+    expB  = expF16UI( uiB );
+    sigB  = fracF16UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA || ((expB == 0x1F) && sigB) ) goto propagateNaN;
+        magBits = expB | sigB;
+        goto infArg;
+    }
+    if ( expB == 0x1F ) {
+        if ( sigB ) goto propagateNaN;
+        magBits = expA | sigA;
+        goto infArg;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zero;
+        normExpSig = softfloat_normSubnormalF16Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0xF;
+    sigA = (sigA | 0x0400)<<4;
+    sigB = (sigB | 0x0400)<<5;
+    sig32Z = (uint_fast32_t) sigA * sigB;
+    sigZ = sig32Z>>16;
+    if ( sig32Z & 0xFFFF ) sigZ |= 1;
+    if ( sigZ < 0x4000 ) {
+        --expZ;
+        sigZ <<= 1;
+    }
+    return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infArg:
+    if ( ! magBits ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ = defaultNaNF16UI;
+    } else {
+        uiZ = packToF16UI( signZ, 0x1F, 0 );
+    }
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF16UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_mulAdd.c b/arch/riscv/kernel/soft_vector/softfloat/f16_mulAdd.c
new file mode 100644
index 000000000000..42d94f3f0e21
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_mulAdd.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t f16_mulAdd( float16_t a, float16_t b, float16_t c )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    union ui16_f16 uC;
+    uint_fast16_t uiC;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    uC.f = c;
+    uiC = uC.ui;
+    return softfloat_mulAddF16( uiA, uiB, uiC, 0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_rem.c b/arch/riscv/kernel/soft_vector/softfloat/f16_rem.c
new file mode 100644
index 000000000000..d3601be6df0c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_rem.c
@@ -0,0 +1,171 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f16_rem( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    struct exp8_sig16 normExpSig;
+    uint16_t rem;
+    int_fast8_t expDiff;
+    uint_fast16_t q;
+    uint32_t recip32, q32;
+    uint16_t altRem, meanRem;
+    bool signRem;
+    uint_fast16_t uiZ;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    expB = expF16UI( uiB );
+    sigB = fracF16UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA || ((expB == 0x1F) && sigB) ) goto propagateNaN;
+        goto invalid;
+    }
+    if ( expB == 0x1F ) {
+        if ( sigB ) goto propagateNaN;
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) goto invalid;
+        normExpSig = softfloat_normSubnormalF16Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    rem = sigA | 0x0400;
+    sigB |= 0x0400;
+    expDiff = expA - expB;
+    if ( expDiff < 1 ) {
+        if ( expDiff < -1 ) return a;
+        sigB <<= 3;
+        if ( expDiff ) {
+            rem <<= 2;
+            q = 0;
+        } else {
+            rem <<= 3;
+            q = (sigB <= rem);
+            if ( q ) rem -= sigB;
+        }
+    } else {
+        recip32 = softfloat_approxRecip32_1( (uint_fast32_t) sigB<<21 );
+        /*--------------------------------------------------------------------
+        | Changing the shift of `rem' here requires also changing the initial
+        | subtraction from `expDiff'.
+        *--------------------------------------------------------------------*/
+        rem <<= 4;
+        expDiff -= 31;
+        /*--------------------------------------------------------------------
+        | The scale of `sigB' affects how many bits are obtained during each
+        | cycle of the loop.  Currently this is 29 bits per loop iteration,
+        | which is believed to be the maximum possible.
+        *--------------------------------------------------------------------*/
+        sigB <<= 3;
+        for (;;) {
+            q32 = (rem * (uint_fast64_t) recip32)>>16;
+            if ( expDiff < 0 ) break;
+            rem = -((uint_fast16_t) q32 * sigB);
+            expDiff -= 29;
+        }
+        /*--------------------------------------------------------------------
+        | (`expDiff' cannot be less than -30 here.)
+        *--------------------------------------------------------------------*/
+        q32 >>= ~expDiff & 31;
+        q = q32;
+        rem = (rem<<(expDiff + 30)) - q * sigB;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    do {
+        altRem = rem;
+        ++q;
+        rem -= sigB;
+    } while ( ! (rem & 0x8000) );
+    meanRem = rem + altRem;
+    if ( (meanRem & 0x8000) || (! meanRem && (q & 1)) ) rem = altRem;
+    signRem = signA;
+    if ( 0x8000 <= rem ) {
+        signRem = ! signRem;
+        rem = -rem;
+    }
+    return softfloat_normRoundPackToF16( signRem, expB, rem );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF16UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_roundToInt.c b/arch/riscv/kernel/soft_vector/softfloat/f16_roundToInt.c
new file mode 100644
index 000000000000..ce66adf48b9e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_roundToInt.c
@@ -0,0 +1,112 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f16_roundToInt( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t uiZ, lastBitMask, roundBitsMask;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp <= 0xE ) {
+        if ( ! (uint16_t) (uiA<<1) ) return a;
+        if ( exact ) softfloat_exceptionFlags |= softfloat_flag_inexact;
+        uiZ = uiA & packToF16UI( 1, 0, 0 );
+        switch ( roundingMode ) {
+         case softfloat_round_near_even:
+            if ( ! fracF16UI( uiA ) ) break;
+         case softfloat_round_near_maxMag:
+            if ( exp == 0xE ) uiZ |= packToF16UI( 0, 0xF, 0 );
+            break;
+         case softfloat_round_min:
+            if ( uiZ ) uiZ = packToF16UI( 1, 0xF, 0 );
+            break;
+         case softfloat_round_max:
+            if ( ! uiZ ) uiZ = packToF16UI( 0, 0xF, 0 );
+            break;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x19 <= exp ) {
+        if ( (exp == 0x1F) && fracF16UI( uiA ) ) {
+            uiZ = softfloat_propagateNaNF16UI( uiA, 0 );
+            goto uiZ;
+        }
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = uiA;
+    lastBitMask = (uint_fast16_t) 1<<(0x19 - exp);
+    roundBitsMask = lastBitMask - 1;
+    if ( roundingMode == softfloat_round_near_maxMag ) {
+        uiZ += lastBitMask>>1;
+    } else if ( roundingMode == softfloat_round_near_even ) {
+        uiZ += lastBitMask>>1;
+        if ( ! (uiZ & roundBitsMask) ) uiZ &= ~lastBitMask;
+    } else if (
+        roundingMode
+            == (signF16UI( uiZ ) ? softfloat_round_min : softfloat_round_max)
+    ) {
+        uiZ += roundBitsMask;
+    }
+    uiZ &= ~roundBitsMask;
+    if ( exact && (uiZ != uiA) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_sqrt.c b/arch/riscv/kernel/soft_vector/softfloat/f16_sqrt.c
new file mode 100644
index 000000000000..90302dcf601a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_sqrt.c
@@ -0,0 +1,136 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+extern const uint16_t softfloat_approxRecipSqrt_1k0s[];
+extern const uint16_t softfloat_approxRecipSqrt_1k1s[];
+
+float16_t f16_sqrt( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA, uiZ;
+    struct exp8_sig16 normExpSig;
+    int_fast8_t expZ;
+    int index;
+    uint_fast16_t r0;
+    uint_fast32_t ESqrR0;
+    uint16_t sigma0;
+    uint_fast16_t recipSqrt16, sigZ, shiftedSigZ;
+    uint16_t negRem;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA ) {
+            uiZ = softfloat_propagateNaNF16UI( uiA, 0 );
+            goto uiZ;
+        }
+        if ( ! signA ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signA ) {
+        if ( ! (expA | sigA) ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = ((expA - 0xF)>>1) + 0xE;
+    expA &= 1;
+    sigA |= 0x0400;
+    index = (sigA>>6 & 0xE) + expA;
+    r0 = softfloat_approxRecipSqrt_1k0s[index]
+             - (((uint_fast32_t) softfloat_approxRecipSqrt_1k1s[index]
+                     * (sigA & 0x7F))
+                    >>11);
+    ESqrR0 = ((uint_fast32_t) r0 * r0)>>1;
+    if ( expA ) ESqrR0 >>= 1;
+    sigma0 = ~(uint_fast16_t) ((ESqrR0 * sigA)>>16);
+    recipSqrt16 = r0 + (((uint_fast32_t) r0 * sigma0)>>25);
+    if ( ! (recipSqrt16 & 0x8000) ) recipSqrt16 = 0x8000;
+    sigZ = ((uint_fast32_t) (sigA<<5) * recipSqrt16)>>16;
+    if ( expA ) sigZ >>= 1;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    ++sigZ;
+    if ( ! (sigZ & 7) ) {
+        shiftedSigZ = sigZ>>1;
+        negRem = shiftedSigZ * shiftedSigZ;
+        sigZ &= ~1;
+        if ( negRem & 0x8000 ) {
+            sigZ |= 1;
+        } else {
+            if ( negRem ) --sigZ;
+        }
+    }
+    return softfloat_roundPackToF16( 0, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF16UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_sub.c b/arch/riscv/kernel/soft_vector/softfloat/f16_sub.c
new file mode 100644
index 000000000000..17e09cc7edde
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_sub.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t f16_sub( float16_t a, float16_t b )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    union ui16_f16 uB;
+    uint_fast16_t uiB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 1)
+    float16_t (*magsFuncPtr)( uint_fast16_t, uint_fast16_t );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+    if ( signF16UI( uiA ^ uiB ) ) {
+        return softfloat_addMagsF16( uiA, uiB );
+    } else {
+        return softfloat_subMagsF16( uiA, uiB );
+    }
+#else
+    magsFuncPtr =
+        signF16UI( uiA ^ uiB ) ? softfloat_addMagsF16 : softfloat_subMagsF16;
+    return (*magsFuncPtr)( uiA, uiB );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f128.c
new file mode 100644
index 000000000000..1f9f15052a67
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f128.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f16_to_f128( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    struct commonNaN commonNaN;
+    struct uint128 uiZ;
+    struct exp8_sig16 normExpSig;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        if ( frac ) {
+            softfloat_f16UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF128UI( &commonNaN );
+        } else {
+            uiZ.v64 = packToF128UI64( sign, 0x7FFF, 0 );
+            uiZ.v0  = 0;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ.v64 = packToF128UI64( sign, 0, 0 );
+            uiZ.v0  = 0;
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ.v64 = packToF128UI64( sign, exp + 0x3FF0, (uint_fast64_t) frac<<38 );
+    uiZ.v0  = 0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f32.c
new file mode 100644
index 000000000000..9618d72d2067
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f32.c
@@ -0,0 +1,93 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f16_to_f32( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    struct commonNaN commonNaN;
+    uint_fast32_t uiZ;
+    struct exp8_sig16 normExpSig;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        if ( frac ) {
+            softfloat_f16UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF32UI( &commonNaN );
+        } else {
+            uiZ = packToF32UI( sign, 0xFF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ = packToF32UI( sign, 0, 0 );
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = packToF32UI( sign, exp + 0x70, (uint_fast32_t) frac<<13 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f64.c
new file mode 100644
index 000000000000..87e768b33249
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_f64.c
@@ -0,0 +1,93 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f16_to_f64( float16_t a )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    struct commonNaN commonNaN;
+    uint_fast64_t uiZ;
+    struct exp8_sig16 normExpSig;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        if ( frac ) {
+            softfloat_f16UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF64UI( &commonNaN );
+        } else {
+            uiZ = packToF64UI( sign, 0x7FF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ = packToF64UI( sign, 0, 0 );
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = packToF64UI( sign, exp + 0x3F0, (uint_fast64_t) frac<<42 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i16.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i16.c
new file mode 100644
index 000000000000..9e71a4acd94a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i16.c
@@ -0,0 +1,57 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast16_t f16_to_i16( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    int_fast32_t sig32 = f16_to_i32(a, roundingMode, exact);
+
+    if (sig32 > INT16_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i16_fromPosOverflow;
+    } else if (sig32 < INT16_MIN) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i16_fromNegOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32.c
new file mode 100644
index 000000000000..a2c9440e239e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32.c
@@ -0,0 +1,87 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f16_to_i32( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast32_t sig32;
+    int_fast8_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            frac ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig32 = frac;
+    if ( exp ) {
+        sig32 |= 0x0400;
+        shiftDist = exp - 0x19;
+        if ( 0 <= shiftDist ) {
+            sig32 <<= shiftDist;
+            return sign ? -sig32 : sig32;
+        }
+        shiftDist = exp - 0x0D;
+        if ( 0 < shiftDist ) sig32 <<= shiftDist;
+    }
+    return
+        softfloat_roundToI32(
+            sign, (uint_fast32_t) sig32, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32_r_minMag.c
new file mode 100644
index 000000000000..dd230c334c14
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i32_r_minMag.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f16_to_i32_r_minMag( float16_t a, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast8_t shiftDist;
+    bool sign;
+    int_fast32_t alignedSig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = exp - 0x0F;
+    if ( shiftDist < 0 ) {
+        if ( exact && (exp | frac) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF16UI( uiA );
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x1F) && frac ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    alignedSig = (int_fast32_t) (frac | 0x0400)<<shiftDist;
+    if ( exact && (alignedSig & 0x3FF) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    alignedSig >>= 10;
+    return sign ? -alignedSig : alignedSig;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64.c
new file mode 100644
index 000000000000..87b4d5c06a90
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64.c
@@ -0,0 +1,87 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f16_to_i64( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast32_t sig32;
+    int_fast8_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            frac ? i64_fromNaN
+                : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig32 = frac;
+    if ( exp ) {
+        sig32 |= 0x0400;
+        shiftDist = exp - 0x19;
+        if ( 0 <= shiftDist ) {
+            sig32 <<= shiftDist;
+            return sign ? -sig32 : sig32;
+        }
+        shiftDist = exp - 0x0D;
+        if ( 0 < shiftDist ) sig32 <<= shiftDist;
+    }
+    return
+        softfloat_roundToI32(
+            sign, (uint_fast32_t) sig32, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64_r_minMag.c
new file mode 100644
index 000000000000..6bf63d0c07f4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i64_r_minMag.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f16_to_i64_r_minMag( float16_t a, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast8_t shiftDist;
+    bool sign;
+    int_fast32_t alignedSig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = exp - 0x0F;
+    if ( shiftDist < 0 ) {
+        if ( exact && (exp | frac) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF16UI( uiA );
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x1F) && frac ? i64_fromNaN
+                : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    alignedSig = (int_fast32_t) (frac | 0x0400)<<shiftDist;
+    if ( exact && (alignedSig & 0x3FF) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    alignedSig >>= 10;
+    return sign ? -alignedSig : alignedSig;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_i8.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i8.c
new file mode 100644
index 000000000000..280bffbbc1f2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_i8.c
@@ -0,0 +1,57 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast8_t f16_to_i8( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    int_fast32_t sig32 = f16_to_i32(a, roundingMode, exact);
+
+    if (sig32 > INT8_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i8_fromPosOverflow;
+    } else if (sig32 < INT8_MIN) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i8_fromNegOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui16.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui16.c
new file mode 100644
index 000000000000..9f5e1c57fdff
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui16.c
@@ -0,0 +1,54 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f16_to_ui16( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    uint_fast32_t sig32 = f16_to_ui32(a, roundingMode, exact);
+
+    if (sig32 > UINT16_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return ui16_fromPosOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32.c
new file mode 100644
index 000000000000..ce1aa184dcf8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f16_to_ui32( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    uint_fast32_t sig32;
+    int_fast8_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            frac ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig32 = frac;
+    if ( exp ) {
+        sig32 |= 0x0400;
+        shiftDist = exp - 0x19;
+        if ( (0 <= shiftDist) && ! sign ) {
+            return sig32<<shiftDist;
+        }
+        shiftDist = exp - 0x0D;
+        if ( 0 < shiftDist ) sig32 <<= shiftDist;
+    }
+    return softfloat_roundToUI32( sign, sig32, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32_r_minMag.c
new file mode 100644
index 000000000000..c05e88267292
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui32_r_minMag.c
@@ -0,0 +1,87 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f16_to_ui32_r_minMag( float16_t a, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast8_t shiftDist;
+    bool sign;
+    uint_fast32_t alignedSig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = exp - 0x0F;
+    if ( shiftDist < 0 ) {
+        if ( exact && (exp | frac) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF16UI( uiA );
+    if ( sign || (exp == 0x1F) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x1F) && frac ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    alignedSig = (uint_fast32_t) (frac | 0x0400)<<shiftDist;
+    if ( exact && (alignedSig & 0x3FF) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return alignedSig>>10;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64.c
new file mode 100644
index 000000000000..a2d0ce80a1f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f16_to_ui64( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    bool sign;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    uint_fast32_t sig32;
+    int_fast8_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF16UI( uiA );
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x1F ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            frac ? ui64_fromNaN
+                : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig32 = frac;
+    if ( exp ) {
+        sig32 |= 0x0400;
+        shiftDist = exp - 0x19;
+        if ( (0 <= shiftDist) && ! sign ) {
+            return sig32<<shiftDist;
+        }
+        shiftDist = exp - 0x0D;
+        if ( 0 < shiftDist ) sig32 <<= shiftDist;
+    }
+    return softfloat_roundToUI32( sign, sig32, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64_r_minMag.c
new file mode 100644
index 000000000000..a4994412225f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui64_r_minMag.c
@@ -0,0 +1,87 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f16_to_ui64_r_minMag( float16_t a, bool exact )
+{
+    union ui16_f16 uA;
+    uint_fast16_t uiA;
+    int_fast8_t exp;
+    uint_fast16_t frac;
+    int_fast8_t shiftDist;
+    bool sign;
+    uint_fast32_t alignedSig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp  = expF16UI( uiA );
+    frac = fracF16UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = exp - 0x0F;
+    if ( shiftDist < 0 ) {
+        if ( exact && (exp | frac) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF16UI( uiA );
+    if ( sign || (exp == 0x1F) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x1F) && frac ? ui64_fromNaN
+                : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    alignedSig = (uint_fast32_t) (frac | 0x0400)<<shiftDist;
+    if ( exact && (alignedSig & 0x3FF) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return alignedSig>>10;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui8.c b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui8.c
new file mode 100644
index 000000000000..cda41b5607a4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f16_to_ui8.c
@@ -0,0 +1,54 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast8_t f16_to_ui8( float16_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    uint_fast32_t sig32 = f16_to_ui32(a, roundingMode, exact);
+
+    if (sig32 > UINT8_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return ui8_fromPosOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_add.c b/arch/riscv/kernel/soft_vector/softfloat/f32_add.c
new file mode 100644
index 000000000000..9829d5e31cd1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_add.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t f32_add( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 1)
+    float32_t (*magsFuncPtr)( uint_fast32_t, uint_fast32_t );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+    if ( signF32UI( uiA ^ uiB ) ) {
+        return softfloat_subMagsF32( uiA, uiB );
+    } else {
+        return softfloat_addMagsF32( uiA, uiB );
+    }
+#else
+    magsFuncPtr =
+        signF32UI( uiA ^ uiB ) ? softfloat_subMagsF32 : softfloat_addMagsF32;
+    return (*magsFuncPtr)( uiA, uiB );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_classify.c b/arch/riscv/kernel/soft_vector/softfloat/f32_classify.c
new file mode 100644
index 000000000000..9f0b0f2d16bd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_classify.c
@@ -0,0 +1,36 @@
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f32_classify( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+
+    uA.f = a;
+    uiA = uA.ui;
+
+    uint_fast16_t infOrNaN = expF32UI( uiA ) == 0xFF;
+    uint_fast16_t subnormalOrZero = expF32UI( uiA ) == 0;
+    bool sign = signF32UI( uiA );
+    bool fracZero = fracF32UI( uiA ) == 0;
+    bool isNaN = isNaNF32UI( uiA );
+    bool isSNaN = softfloat_isSigNaNF32UI( uiA );
+
+    return
+        (  sign && infOrNaN && fracZero )          << 0 |
+        (  sign && !infOrNaN && !subnormalOrZero ) << 1 |
+        (  sign && subnormalOrZero && !fracZero )  << 2 |
+        (  sign && subnormalOrZero && fracZero )   << 3 |
+        ( !sign && infOrNaN && fracZero )          << 7 |
+        ( !sign && !infOrNaN && !subnormalOrZero ) << 6 |
+        ( !sign && subnormalOrZero && !fracZero )  << 5 |
+        ( !sign && subnormalOrZero && fracZero )   << 4 |
+        ( isNaN &&  isSNaN )                       << 8 |
+        ( isNaN && !isSNaN )                       << 9;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_div.c b/arch/riscv/kernel/soft_vector/softfloat/f32_div.c
new file mode 100644
index 000000000000..6f297eb0f46e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_div.c
@@ -0,0 +1,180 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_div( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    bool signZ;
+    struct exp16_sig32 normExpSig;
+    int_fast16_t expZ;
+#ifdef SOFTFLOAT_FAST_DIV64TO32
+    uint_fast64_t sig64A;
+    uint_fast32_t sigZ;
+#else
+    uint_fast32_t sigZ;
+    uint_fast64_t rem;
+#endif
+    uint_fast32_t uiZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF32UI( uiB );
+    expB  = expF32UI( uiB );
+    sigB  = fracF32UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA ) goto propagateNaN;
+        if ( expB == 0xFF ) {
+            if ( sigB ) goto propagateNaN;
+            goto invalid;
+        }
+        goto infinity;
+    }
+    if ( expB == 0xFF ) {
+        if ( sigB ) goto propagateNaN;
+        goto zero;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) {
+            if ( ! (expA | sigA) ) goto invalid;
+            softfloat_raiseFlags( softfloat_flag_infinite );
+            goto infinity;
+        }
+        normExpSig = softfloat_normSubnormalF32Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA - expB + 0x7E;
+    sigA |= 0x00800000;
+    sigB |= 0x00800000;
+#ifdef SOFTFLOAT_FAST_DIV64TO32
+    if ( sigA < sigB ) {
+        --expZ;
+        sig64A = (uint_fast64_t) sigA<<31;
+    } else {
+        sig64A = (uint_fast64_t) sigA<<30;
+    }
+    sigZ = sig64A / sigB;
+    if ( ! (sigZ & 0x3F) ) sigZ |= ((uint_fast64_t) sigB * sigZ != sig64A);
+#else
+    if ( sigA < sigB ) {
+        --expZ;
+        sigA <<= 8;
+    } else {
+        sigA <<= 7;
+    }
+    sigB <<= 8;
+    sigZ = ((uint_fast64_t) sigA * softfloat_approxRecip32_1( sigB ))>>32;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sigZ += 2;
+    if ( (sigZ & 0x3F) < 2 ) {
+        sigZ &= ~3;
+#ifdef SOFTFLOAT_FAST_INT64
+        rem = ((uint_fast64_t) sigA<<31) - (uint_fast64_t) sigZ * sigB;
+#else
+        rem = ((uint_fast64_t) sigA<<32) - (uint_fast64_t) (sigZ<<1) * sigB;
+#endif
+        if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+            sigZ -= 4;
+        } else {
+            if ( rem ) sigZ |= 1;
+        }
+    }
+#endif
+    return softfloat_roundPackToF32( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF32UI;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infinity:
+    uiZ = packToF32UI( signZ, 0xFF, 0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF32UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_eq.c b/arch/riscv/kernel/soft_vector/softfloat/f32_eq.c
new file mode 100644
index 000000000000..e13418926143
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_eq.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f32_eq( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF32UI( uiA ) || softfloat_isSigNaNF32UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    return (uiA == uiB) || ! (uint32_t) ((uiA | uiB)<<1);
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_eq_signaling.c b/arch/riscv/kernel/soft_vector/softfloat/f32_eq_signaling.c
new file mode 100644
index 000000000000..e86288e1a410
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_eq_signaling.c
@@ -0,0 +1,61 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f32_eq_signaling( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    return (uiA == uiB) || ! (uint32_t) ((uiA | uiB)<<1);
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_isSignalingNaN.c b/arch/riscv/kernel/soft_vector/softfloat/f32_isSignalingNaN.c
new file mode 100644
index 000000000000..196b0cd9cf33
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_isSignalingNaN.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f32_isSignalingNaN( float32_t a )
+{
+    union ui32_f32 uA;
+
+    uA.f = a;
+    return softfloat_isSigNaNF32UI( uA.ui );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_le.c b/arch/riscv/kernel/soft_vector/softfloat/f32_le.c
new file mode 100644
index 000000000000..0dd030eec010
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_le.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f32_le( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF32UI( uiA );
+    signB = signF32UI( uiB );
+    return
+        (signA != signB) ? signA || ! (uint32_t) ((uiA | uiB)<<1)
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_le_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f32_le_quiet.c
new file mode 100644
index 000000000000..5b4624974f2c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_le_quiet.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f32_le_quiet( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF32UI( uiA ) || softfloat_isSigNaNF32UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF32UI( uiA );
+    signB = signF32UI( uiB );
+    return
+        (signA != signB) ? signA || ! (uint32_t) ((uiA | uiB)<<1)
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_lt.c b/arch/riscv/kernel/soft_vector/softfloat/f32_lt.c
new file mode 100644
index 000000000000..7e6ebd8da769
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_lt.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f32_lt( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF32UI( uiA );
+    signB = signF32UI( uiB );
+    return
+        (signA != signB) ? signA && ((uint32_t) ((uiA | uiB)<<1) != 0)
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_lt_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f32_lt_quiet.c
new file mode 100644
index 000000000000..bc491c1b2a64
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_lt_quiet.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f32_lt_quiet( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF32UI( uiA ) || isNaNF32UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF32UI( uiA ) || softfloat_isSigNaNF32UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF32UI( uiA );
+    signB = signF32UI( uiB );
+    return
+        (signA != signB) ? signA && ((uint32_t) ((uiA | uiB)<<1) != 0)
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_mul.c b/arch/riscv/kernel/soft_vector/softfloat/f32_mul.c
new file mode 100644
index 000000000000..8d5225f06b60
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_mul.c
@@ -0,0 +1,137 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_mul( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    bool signZ;
+    uint_fast32_t magBits;
+    struct exp16_sig32 normExpSig;
+    int_fast16_t expZ;
+    uint_fast32_t sigZ, uiZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF32UI( uiB );
+    expB  = expF32UI( uiB );
+    sigB  = fracF32UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA || ((expB == 0xFF) && sigB) ) goto propagateNaN;
+        magBits = expB | sigB;
+        goto infArg;
+    }
+    if ( expB == 0xFF ) {
+        if ( sigB ) goto propagateNaN;
+        magBits = expA | sigA;
+        goto infArg;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zero;
+        normExpSig = softfloat_normSubnormalF32Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x7F;
+    sigA = (sigA | 0x00800000)<<7;
+    sigB = (sigB | 0x00800000)<<8;
+    sigZ = softfloat_shortShiftRightJam64( (uint_fast64_t) sigA * sigB, 32 );
+    if ( sigZ < 0x40000000 ) {
+        --expZ;
+        sigZ <<= 1;
+    }
+    return softfloat_roundPackToF32( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infArg:
+    if ( ! magBits ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ = defaultNaNF32UI;
+    } else {
+        uiZ = packToF32UI( signZ, 0xFF, 0 );
+    }
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF32UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_mulAdd.c b/arch/riscv/kernel/soft_vector/softfloat/f32_mulAdd.c
new file mode 100644
index 000000000000..f7d947db64d7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_mulAdd.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t f32_mulAdd( float32_t a, float32_t b, float32_t c )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    union ui32_f32 uC;
+    uint_fast32_t uiC;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    uC.f = c;
+    uiC = uC.ui;
+    return softfloat_mulAddF32( uiA, uiB, uiC, 0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_rem.c b/arch/riscv/kernel/soft_vector/softfloat/f32_rem.c
new file mode 100644
index 000000000000..a44dcff1b929
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_rem.c
@@ -0,0 +1,168 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_rem( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    struct exp16_sig32 normExpSig;
+    uint32_t rem;
+    int_fast16_t expDiff;
+    uint32_t q, recip32, altRem, meanRem;
+    bool signRem;
+    uint_fast32_t uiZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    expB = expF32UI( uiB );
+    sigB = fracF32UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA || ((expB == 0xFF) && sigB) ) goto propagateNaN;
+        goto invalid;
+    }
+    if ( expB == 0xFF ) {
+        if ( sigB ) goto propagateNaN;
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) goto invalid;
+        normExpSig = softfloat_normSubnormalF32Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    rem = sigA | 0x00800000;
+    sigB |= 0x00800000;
+    expDiff = expA - expB;
+    if ( expDiff < 1 ) {
+        if ( expDiff < -1 ) return a;
+        sigB <<= 6;
+        if ( expDiff ) {
+            rem <<= 5;
+            q = 0;
+        } else {
+            rem <<= 6;
+            q = (sigB <= rem);
+            if ( q ) rem -= sigB;
+        }
+    } else {
+        recip32 = softfloat_approxRecip32_1( sigB<<8 );
+        /*--------------------------------------------------------------------
+        | Changing the shift of `rem' here requires also changing the initial
+        | subtraction from `expDiff'.
+        *--------------------------------------------------------------------*/
+        rem <<= 7;
+        expDiff -= 31;
+        /*--------------------------------------------------------------------
+        | The scale of `sigB' affects how many bits are obtained during each
+        | cycle of the loop.  Currently this is 29 bits per loop iteration,
+        | which is believed to be the maximum possible.
+        *--------------------------------------------------------------------*/
+        sigB <<= 6;
+        for (;;) {
+            q = (rem * (uint_fast64_t) recip32)>>32;
+            if ( expDiff < 0 ) break;
+            rem = -(q * (uint32_t) sigB);
+            expDiff -= 29;
+        }
+        /*--------------------------------------------------------------------
+        | (`expDiff' cannot be less than -30 here.)
+        *--------------------------------------------------------------------*/
+        q >>= ~expDiff & 31;
+        rem = (rem<<(expDiff + 30)) - q * (uint32_t) sigB;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    do {
+        altRem = rem;
+        ++q;
+        rem -= sigB;
+    } while ( ! (rem & 0x80000000) );
+    meanRem = rem + altRem;
+    if ( (meanRem & 0x80000000) || (! meanRem && (q & 1)) ) rem = altRem;
+    signRem = signA;
+    if ( 0x80000000 <= rem ) {
+        signRem = ! signRem;
+        rem = -rem;
+    }
+    return softfloat_normRoundPackToF32( signRem, expB, rem );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+    goto uiZ;
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF32UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_roundToInt.c b/arch/riscv/kernel/soft_vector/softfloat/f32_roundToInt.c
new file mode 100644
index 000000000000..7eb80743560a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_roundToInt.c
@@ -0,0 +1,112 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_roundToInt( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t uiZ, lastBitMask, roundBitsMask;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp <= 0x7E ) {
+        if ( ! (uint32_t) (uiA<<1) ) return a;
+        if ( exact ) softfloat_exceptionFlags |= softfloat_flag_inexact;
+        uiZ = uiA & packToF32UI( 1, 0, 0 );
+        switch ( roundingMode ) {
+         case softfloat_round_near_even:
+            if ( ! fracF32UI( uiA ) ) break;
+         case softfloat_round_near_maxMag:
+            if ( exp == 0x7E ) uiZ |= packToF32UI( 0, 0x7F, 0 );
+            break;
+         case softfloat_round_min:
+            if ( uiZ ) uiZ = packToF32UI( 1, 0x7F, 0 );
+            break;
+         case softfloat_round_max:
+            if ( ! uiZ ) uiZ = packToF32UI( 0, 0x7F, 0 );
+            break;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x96 <= exp ) {
+        if ( (exp == 0xFF) && fracF32UI( uiA ) ) {
+            uiZ = softfloat_propagateNaNF32UI( uiA, 0 );
+            goto uiZ;
+        }
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = uiA;
+    lastBitMask = (uint_fast32_t) 1<<(0x96 - exp);
+    roundBitsMask = lastBitMask - 1;
+    if ( roundingMode == softfloat_round_near_maxMag ) {
+        uiZ += lastBitMask>>1;
+    } else if ( roundingMode == softfloat_round_near_even ) {
+        uiZ += lastBitMask>>1;
+        if ( ! (uiZ & roundBitsMask) ) uiZ &= ~lastBitMask;
+    } else if (
+        roundingMode
+            == (signF32UI( uiZ ) ? softfloat_round_min : softfloat_round_max)
+    ) {
+        uiZ += roundBitsMask;
+    }
+    uiZ &= ~roundBitsMask;
+    if ( exact && (uiZ != uiA) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_sqrt.c b/arch/riscv/kernel/soft_vector/softfloat/f32_sqrt.c
new file mode 100644
index 000000000000..533b3652cd97
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_sqrt.c
@@ -0,0 +1,121 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f32_sqrt( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA, uiZ;
+    struct exp16_sig32 normExpSig;
+    int_fast16_t expZ;
+    uint_fast32_t sigZ, shiftedSigZ;
+    uint32_t negRem;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA ) {
+            uiZ = softfloat_propagateNaNF32UI( uiA, 0 );
+            goto uiZ;
+        }
+        if ( ! signA ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signA ) {
+        if ( ! (expA | sigA) ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = ((expA - 0x7F)>>1) + 0x7E;
+    expA &= 1;
+    sigA = (sigA | 0x00800000)<<8;
+    sigZ =
+        ((uint_fast64_t) sigA * softfloat_approxRecipSqrt32_1( expA, sigA ))
+            >>32;
+    if ( expA ) sigZ >>= 1;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sigZ += 2;
+    if ( (sigZ & 0x3F) < 2 ) {
+        shiftedSigZ = sigZ>>2;
+        negRem = shiftedSigZ * shiftedSigZ;
+        sigZ &= ~3;
+        if ( negRem & 0x80000000 ) {
+            sigZ |= 1;
+        } else {
+            if ( negRem ) --sigZ;
+        }
+    }
+    return softfloat_roundPackToF32( 0, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF32UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_sub.c b/arch/riscv/kernel/soft_vector/softfloat/f32_sub.c
new file mode 100644
index 000000000000..6268552bea9b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_sub.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t f32_sub( float32_t a, float32_t b )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    union ui32_f32 uB;
+    uint_fast32_t uiB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 1)
+    float32_t (*magsFuncPtr)( uint_fast32_t, uint_fast32_t );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+    if ( signF32UI( uiA ^ uiB ) ) {
+        return softfloat_addMagsF32( uiA, uiB );
+    } else {
+        return softfloat_subMagsF32( uiA, uiB );
+    }
+#else
+    magsFuncPtr =
+        signF32UI( uiA ^ uiB ) ? softfloat_addMagsF32 : softfloat_subMagsF32;
+    return (*magsFuncPtr)( uiA, uiB );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f128.c
new file mode 100644
index 000000000000..ea58e8d0349f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f128.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f32_to_f128( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t frac;
+    struct commonNaN commonNaN;
+    struct uint128 uiZ;
+    struct exp16_sig32 normExpSig;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    frac = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0xFF ) {
+        if ( frac ) {
+            softfloat_f32UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF128UI( &commonNaN );
+        } else {
+            uiZ.v64 = packToF128UI64( sign, 0x7FFF, 0 );
+            uiZ.v0  = 0;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ.v64 = packToF128UI64( sign, 0, 0 );
+            uiZ.v0  = 0;
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF32Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ.v64 = packToF128UI64( sign, exp + 0x3F80, (uint_fast64_t) frac<<25 );
+    uiZ.v0  = 0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f16.c
new file mode 100644
index 000000000000..403ce34a5425
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f16.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f32_to_f16( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t frac;
+    struct commonNaN commonNaN;
+    uint_fast16_t uiZ, frac16;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    frac = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0xFF ) {
+        if ( frac ) {
+            softfloat_f32UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF16UI( &commonNaN );
+        } else {
+            uiZ = packToF16UI( sign, 0x1F, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac16 = frac>>9 | ((frac & 0x1FF) != 0);
+    if ( ! (exp | frac16) ) {
+        uiZ = packToF16UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    return softfloat_roundPackToF16( sign, exp - 0x71, frac16 | 0x4000 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f64.c
new file mode 100644
index 000000000000..12040185e6cd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_f64.c
@@ -0,0 +1,93 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f32_to_f64( float32_t a )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t frac;
+    struct commonNaN commonNaN;
+    uint_fast64_t uiZ;
+    struct exp16_sig32 normExpSig;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    frac = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0xFF ) {
+        if ( frac ) {
+            softfloat_f32UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF64UI( &commonNaN );
+        } else {
+            uiZ = packToF64UI( sign, 0x7FF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ = packToF64UI( sign, 0, 0 );
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF32Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = packToF64UI( sign, exp + 0x380, (uint_fast64_t) frac<<29 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i16.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i16.c
new file mode 100644
index 000000000000..eef8ff0eab2a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i16.c
@@ -0,0 +1,57 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast16_t f32_to_i16( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    int_fast32_t sig32 = f32_to_i32(a, roundingMode, exact);
+
+    if (sig32 > INT16_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i16_fromPosOverflow;
+    } else if (sig32 < INT16_MIN) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return i16_fromNegOverflow;
+    } else {
+        return sig32;
+    }
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32.c
new file mode 100644
index 000000000000..ded5c6def21b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f32_to_i32( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    uint_fast64_t sig64;
+    int_fast16_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    sig  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (i32_fromNaN != i32_fromPosOverflow) || (i32_fromNaN != i32_fromNegOverflow)
+    if ( (exp == 0xFF) && sig ) {
+#if (i32_fromNaN == i32_fromPosOverflow)
+        sign = 0;
+#elif (i32_fromNaN == i32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return i32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= 0x00800000;
+    sig64 = (uint_fast64_t) sig<<32;
+    shiftDist = 0xAA - exp;
+    if ( 0 < shiftDist ) sig64 = softfloat_shiftRightJam64( sig64, shiftDist );
+    return softfloat_roundToI32( sign, sig64, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32_r_minMag.c
new file mode 100644
index 000000000000..7b5fc1ad54aa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i32_r_minMag.c
@@ -0,0 +1,89 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f32_to_i32_r_minMag( float32_t a, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    int_fast32_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    sig = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x9E - exp;
+    if ( 32 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF32UI( uiA );
+    if ( shiftDist <= 0 ) {
+        if ( uiA == packToF32UI( 1, 0x9E, 0 ) ) return -0x7FFFFFFF - 1;
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig | 0x00800000)<<8;
+    absZ = sig>>shiftDist;
+    if ( exact && ((uint_fast32_t) absZ<<shiftDist != sig) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64.c
new file mode 100644
index 000000000000..cdc847da4995
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f32_to_i64( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+#ifdef SOFTFLOAT_FAST_INT64
+    uint_fast64_t sig64, extra;
+    struct uint64_extra sig64Extra;
+#else
+    uint32_t extSig[3];
+#endif
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    sig  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0xBE - exp;
+    if ( shiftDist < 0 ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? i64_fromNaN
+                : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= 0x00800000;
+#ifdef SOFTFLOAT_FAST_INT64
+    sig64 = (uint_fast64_t) sig<<40;
+    extra = 0;
+    if ( shiftDist ) {
+        sig64Extra = softfloat_shiftRightJam64Extra( sig64, 0, shiftDist );
+        sig64 = sig64Extra.v;
+        extra = sig64Extra.extra;
+    }
+    return softfloat_roundToI64( sign, sig64, extra, roundingMode, exact );
+#else
+    extSig[indexWord( 3, 2 )] = sig<<8;
+    extSig[indexWord( 3, 1 )] = 0;
+    extSig[indexWord( 3, 0 )] = 0;
+    if ( shiftDist ) softfloat_shiftRightJam96M( extSig, shiftDist, extSig );
+    return softfloat_roundMToI64( sign, extSig, roundingMode, exact );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64_r_minMag.c
new file mode 100644
index 000000000000..cf6f95d5959f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_i64_r_minMag.c
@@ -0,0 +1,94 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f32_to_i64_r_minMag( float32_t a, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast64_t sig64;
+    int_fast64_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    sig = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0xBE - exp;
+    if ( 64 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF32UI( uiA );
+    if ( shiftDist <= 0 ) {
+        if ( uiA == packToF32UI( 1, 0xBE, 0 ) ) {
+            return -INT64_C( 0x7FFFFFFFFFFFFFFF ) - 1;
+        }
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? i64_fromNaN
+                : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig |= 0x00800000;
+    sig64 = (uint_fast64_t) sig<<40;
+    absZ = sig64>>shiftDist;
+    shiftDist = 40 - shiftDist;
+    if ( exact && (shiftDist < 0) && (uint32_t) (sig<<(shiftDist & 31)) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui16.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui16.c
new file mode 100644
index 000000000000..5ca3c254e9b8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui16.c
@@ -0,0 +1,53 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f32_to_ui16( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    uint_fast8_t old_flags = softfloat_exceptionFlags;
+
+    uint_fast32_t sig32 = f32_to_ui32(a, roundingMode, exact);
+
+    if (sig32 > UINT16_MAX) {
+        softfloat_exceptionFlags = old_flags | softfloat_flag_invalid;
+        return ui16_fromPosOverflow;
+    } else {
+        return sig32;
+    }
+}
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32.c
new file mode 100644
index 000000000000..5df0576f8ab4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f32_to_ui32( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    uint_fast64_t sig64;
+    int_fast16_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    sig  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (ui32_fromNaN != ui32_fromPosOverflow) || (ui32_fromNaN != ui32_fromNegOverflow)
+    if ( (exp == 0xFF) && sig ) {
+#if (ui32_fromNaN == ui32_fromPosOverflow)
+        sign = 0;
+#elif (ui32_fromNaN == ui32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return ui32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= 0x00800000;
+    sig64 = (uint_fast64_t) sig<<32;
+    shiftDist = 0xAA - exp;
+    if ( 0 < shiftDist ) sig64 = softfloat_shiftRightJam64( sig64, shiftDist );
+    return softfloat_roundToUI32( sign, sig64, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32_r_minMag.c
new file mode 100644
index 000000000000..9f92cc0ff825
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui32_r_minMag.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f32_to_ui32_r_minMag( float32_t a, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    sig = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x9E - exp;
+    if ( 32 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF32UI( uiA );
+    if ( sign || (shiftDist < 0) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig | 0x00800000)<<8;
+    z = sig>>shiftDist;
+    if ( exact && (z<<shiftDist != sig) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64.c
new file mode 100644
index 000000000000..0fb61423b84d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f32_to_ui64( float32_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+#ifdef SOFTFLOAT_FAST_INT64
+    uint_fast64_t sig64, extra;
+    struct uint64_extra sig64Extra;
+#else
+    uint32_t extSig[3];
+#endif
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF32UI( uiA );
+    exp  = expF32UI( uiA );
+    sig  = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0xBE - exp;
+    if ( shiftDist < 0 ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? ui64_fromNaN
+                : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= 0x00800000;
+#ifdef SOFTFLOAT_FAST_INT64
+    sig64 = (uint_fast64_t) sig<<40;
+    extra = 0;
+    if ( shiftDist ) {
+        sig64Extra = softfloat_shiftRightJam64Extra( sig64, 0, shiftDist );
+        sig64 = sig64Extra.v;
+        extra = sig64Extra.extra;
+    }
+    return softfloat_roundToUI64( sign, sig64, extra, roundingMode, exact );
+#else
+    extSig[indexWord( 3, 2 )] = sig<<8;
+    extSig[indexWord( 3, 1 )] = 0;
+    extSig[indexWord( 3, 0 )] = 0;
+    if ( shiftDist ) softfloat_shiftRightJam96M( extSig, shiftDist, extSig );
+    return softfloat_roundMToUI64( sign, extSig, roundingMode, exact );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64_r_minMag.c
new file mode 100644
index 000000000000..2c3db1cc1d99
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f32_to_ui64_r_minMag.c
@@ -0,0 +1,90 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f32_to_ui64_r_minMag( float32_t a, bool exact )
+{
+    union ui32_f32 uA;
+    uint_fast32_t uiA;
+    int_fast16_t exp;
+    uint_fast32_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast64_t sig64, z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF32UI( uiA );
+    sig = fracF32UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0xBE - exp;
+    if ( 64 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF32UI( uiA );
+    if ( sign || (shiftDist < 0) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0xFF) && sig ? ui64_fromNaN
+                : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig |= 0x00800000;
+    sig64 = (uint_fast64_t) sig<<40;
+    z = sig64>>shiftDist;
+    shiftDist = 40 - shiftDist;
+    if ( exact && (shiftDist < 0) && (uint32_t) (sig<<(shiftDist & 31)) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_add.c b/arch/riscv/kernel/soft_vector/softfloat/f64_add.c
new file mode 100644
index 000000000000..190cdf53f1ec
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_add.c
@@ -0,0 +1,74 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t f64_add( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
+    float64_t (*magsFuncPtr)( uint_fast64_t, uint_fast64_t, bool );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF64UI( uiB );
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+    if ( signA == signB ) {
+        return softfloat_addMagsF64( uiA, uiB, signA );
+    } else {
+        return softfloat_subMagsF64( uiA, uiB, signA );
+    }
+#else
+    magsFuncPtr =
+        (signA == signB) ? softfloat_addMagsF64 : softfloat_subMagsF64;
+    return (*magsFuncPtr)( uiA, uiB, signA );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_classify.c b/arch/riscv/kernel/soft_vector/softfloat/f64_classify.c
new file mode 100644
index 000000000000..a6944c93ea77
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_classify.c
@@ -0,0 +1,36 @@
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast16_t f64_classify( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+
+    uA.f = a;
+    uiA = uA.ui;
+
+    uint_fast16_t infOrNaN = expF64UI( uiA ) == 0x7FF;
+    uint_fast16_t subnormalOrZero = expF64UI( uiA ) == 0;
+    bool sign = signF64UI( uiA );
+    bool fracZero = fracF64UI( uiA ) == 0;
+    bool isNaN = isNaNF64UI( uiA );
+    bool isSNaN = softfloat_isSigNaNF64UI( uiA );
+
+    return
+        (  sign && infOrNaN && fracZero )          << 0 |
+        (  sign && !infOrNaN && !subnormalOrZero ) << 1 |
+        (  sign && subnormalOrZero && !fracZero )  << 2 |
+        (  sign && subnormalOrZero && fracZero )   << 3 |
+        ( !sign && infOrNaN && fracZero )          << 7 |
+        ( !sign && !infOrNaN && !subnormalOrZero ) << 6 |
+        ( !sign && subnormalOrZero && !fracZero )  << 5 |
+        ( !sign && subnormalOrZero && fracZero )   << 4 |
+        ( isNaN &&  isSNaN )                       << 8 |
+        ( isNaN && !isSNaN )                       << 9;
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_div.c b/arch/riscv/kernel/soft_vector/softfloat/f64_div.c
new file mode 100644
index 000000000000..16befb2faa79
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_div.c
@@ -0,0 +1,172 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_div( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    bool signZ;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+    uint32_t recip32, sig32Z, doubleTerm;
+    uint_fast64_t rem;
+    uint32_t q;
+    uint_fast64_t sigZ;
+    uint_fast64_t uiZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF64UI( uiB );
+    expB  = expF64UI( uiB );
+    sigB  = fracF64UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA ) goto propagateNaN;
+        if ( expB == 0x7FF ) {
+            if ( sigB ) goto propagateNaN;
+            goto invalid;
+        }
+        goto infinity;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN;
+        goto zero;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) {
+            if ( ! (expA | sigA) ) goto invalid;
+            softfloat_raiseFlags( softfloat_flag_infinite );
+            goto infinity;
+        }
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA - expB + 0x3FE;
+    sigA |= UINT64_C( 0x0010000000000000 );
+    sigB |= UINT64_C( 0x0010000000000000 );
+    if ( sigA < sigB ) {
+        --expZ;
+        sigA <<= 11;
+    } else {
+        sigA <<= 10;
+    }
+    sigB <<= 11;
+    recip32 = softfloat_approxRecip32_1( sigB>>32 ) - 2;
+    sig32Z = ((uint32_t) (sigA>>32) * (uint_fast64_t) recip32)>>32;
+    doubleTerm = sig32Z<<1;
+    rem =
+        ((sigA - (uint_fast64_t) doubleTerm * (uint32_t) (sigB>>32))<<28)
+            - (uint_fast64_t) doubleTerm * ((uint32_t) sigB>>4);
+    q = (((uint32_t) (rem>>32) * (uint_fast64_t) recip32)>>32) + 4;
+    sigZ = ((uint_fast64_t) sig32Z<<32) + ((uint_fast64_t) q<<4);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( (sigZ & 0x1FF) < 4<<4 ) {
+        q &= ~7;
+        sigZ &= ~(uint_fast64_t) 0x7F;
+        doubleTerm = q<<1;
+        rem =
+            ((rem - (uint_fast64_t) doubleTerm * (uint32_t) (sigB>>32))<<28)
+                - (uint_fast64_t) doubleTerm * ((uint32_t) sigB>>4);
+        if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+            sigZ -= 1<<7;
+        } else {
+            if ( rem ) sigZ |= 1;
+        }
+    }
+    return softfloat_roundPackToF64( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infinity:
+    uiZ = packToF64UI( signZ, 0x7FF, 0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF64UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_eq.c b/arch/riscv/kernel/soft_vector/softfloat/f64_eq.c
new file mode 100644
index 000000000000..fe8eac0585bc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_eq.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f64_eq( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF64UI( uiA ) || softfloat_isSigNaNF64UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    return (uiA == uiB) || ! ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_eq_signaling.c b/arch/riscv/kernel/soft_vector/softfloat/f64_eq_signaling.c
new file mode 100644
index 000000000000..1e300930c8cb
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_eq_signaling.c
@@ -0,0 +1,61 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f64_eq_signaling( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    return (uiA == uiB) || ! ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_isSignalingNaN.c b/arch/riscv/kernel/soft_vector/softfloat/f64_isSignalingNaN.c
new file mode 100644
index 000000000000..0b81d4ae1c0d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_isSignalingNaN.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f64_isSignalingNaN( float64_t a )
+{
+    union ui64_f64 uA;
+
+    uA.f = a;
+    return softfloat_isSigNaNF64UI( uA.ui );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_le.c b/arch/riscv/kernel/soft_vector/softfloat/f64_le.c
new file mode 100644
index 000000000000..fabc1345983d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_le.c
@@ -0,0 +1,67 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f64_le( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF64UI( uiA );
+    signB = signF64UI( uiB );
+    return
+        (signA != signB)
+            ? signA || ! ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_le_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f64_le_quiet.c
new file mode 100644
index 000000000000..26d70f86f6b9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_le_quiet.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f64_le_quiet( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF64UI( uiA ) || softfloat_isSigNaNF64UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF64UI( uiA );
+    signB = signF64UI( uiB );
+    return
+        (signA != signB)
+            ? signA || ! ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+            : (uiA == uiB) || (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_lt.c b/arch/riscv/kernel/soft_vector/softfloat/f64_lt.c
new file mode 100644
index 000000000000..f42a91797847
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_lt.c
@@ -0,0 +1,67 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+bool f64_lt( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return false;
+    }
+    signA = signF64UI( uiA );
+    signB = signF64UI( uiB );
+    return
+        (signA != signB)
+            ? signA && ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_lt_quiet.c b/arch/riscv/kernel/soft_vector/softfloat/f64_lt_quiet.c
new file mode 100644
index 000000000000..ce683a3cd664
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_lt_quiet.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+bool f64_lt_quiet( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signA, signB;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    if ( isNaNF64UI( uiA ) || isNaNF64UI( uiB ) ) {
+        if (
+            softfloat_isSigNaNF64UI( uiA ) || softfloat_isSigNaNF64UI( uiB )
+        ) {
+            softfloat_raiseFlags( softfloat_flag_invalid );
+        }
+        return false;
+    }
+    signA = signF64UI( uiA );
+    signB = signF64UI( uiB );
+    return
+        (signA != signB)
+            ? signA && ((uiA | uiB) & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+            : (uiA != uiB) && (signA ^ (uiA < uiB));
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_mul.c b/arch/riscv/kernel/soft_vector/softfloat/f64_mul.c
new file mode 100644
index 000000000000..cfaa6977531c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_mul.c
@@ -0,0 +1,150 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_mul( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    bool signZ;
+    uint_fast64_t magBits;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+#ifdef SOFTFLOAT_FAST_INT64
+    struct uint128 sig128Z;
+#else
+    uint32_t sig128Z[4];
+#endif
+    uint_fast64_t sigZ, uiZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF64UI( uiB );
+    expB  = expF64UI( uiB );
+    sigB  = fracF64UI( uiB );
+    signZ = signA ^ signB;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA || ((expB == 0x7FF) && sigB) ) goto propagateNaN;
+        magBits = expB | sigB;
+        goto infArg;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN;
+        magBits = expA | sigA;
+        goto infArg;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zero;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zero;
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x3FF;
+    sigA = (sigA | UINT64_C( 0x0010000000000000 ))<<10;
+    sigB = (sigB | UINT64_C( 0x0010000000000000 ))<<11;
+#ifdef SOFTFLOAT_FAST_INT64
+    sig128Z = softfloat_mul64To128( sigA, sigB );
+    sigZ = sig128Z.v64 | (sig128Z.v0 != 0);
+#else
+    softfloat_mul64To128M( sigA, sigB, sig128Z );
+    sigZ =
+        (uint64_t) sig128Z[indexWord( 4, 3 )]<<32 | sig128Z[indexWord( 4, 2 )];
+    if ( sig128Z[indexWord( 4, 1 )] || sig128Z[indexWord( 4, 0 )] ) sigZ |= 1;
+#endif
+    if ( sigZ < UINT64_C( 0x4000000000000000 ) ) {
+        --expZ;
+        sigZ <<= 1;
+    }
+    return softfloat_roundPackToF64( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infArg:
+    if ( ! magBits ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ = defaultNaNF64UI;
+    } else {
+        uiZ = packToF64UI( signZ, 0x7FF, 0 );
+    }
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zero:
+    uiZ = packToF64UI( signZ, 0, 0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_mulAdd.c b/arch/riscv/kernel/soft_vector/softfloat/f64_mulAdd.c
new file mode 100644
index 000000000000..8123ef863dc4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_mulAdd.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t f64_mulAdd( float64_t a, float64_t b, float64_t c )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    union ui64_f64 uC;
+    uint_fast64_t uiC;
+
+    uA.f = a;
+    uiA = uA.ui;
+    uB.f = b;
+    uiB = uB.ui;
+    uC.f = c;
+    uiC = uC.ui;
+    return softfloat_mulAddF64( uiA, uiB, uiC, 0 );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_rem.c b/arch/riscv/kernel/soft_vector/softfloat/f64_rem.c
new file mode 100644
index 000000000000..041b8fe17116
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_rem.c
@@ -0,0 +1,189 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_rem( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    struct exp16_sig64 normExpSig;
+    uint64_t rem;
+    int_fast16_t expDiff;
+    uint32_t q, recip32;
+    uint_fast64_t q64;
+    uint64_t altRem, meanRem;
+    bool signRem;
+    uint_fast64_t uiZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    expB = expF64UI( uiB );
+    sigB = fracF64UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA || ((expB == 0x7FF) && sigB) ) goto propagateNaN;
+        goto invalid;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN;
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA < expB - 1 ) return a;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expB ) {
+        if ( ! sigB ) goto invalid;
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    rem = sigA | UINT64_C( 0x0010000000000000 );
+    sigB |= UINT64_C( 0x0010000000000000 );
+    expDiff = expA - expB;
+    if ( expDiff < 1 ) {
+        if ( expDiff < -1 ) return a;
+        sigB <<= 9;
+        if ( expDiff ) {
+            rem <<= 8;
+            q = 0;
+        } else {
+            rem <<= 9;
+            q = (sigB <= rem);
+            if ( q ) rem -= sigB;
+        }
+    } else {
+        recip32 = softfloat_approxRecip32_1( sigB>>21 );
+        /*--------------------------------------------------------------------
+        | Changing the shift of `rem' here requires also changing the initial
+        | subtraction from `expDiff'.
+        *--------------------------------------------------------------------*/
+        rem <<= 9;
+        expDiff -= 30;
+        /*--------------------------------------------------------------------
+        | The scale of `sigB' affects how many bits are obtained during each
+        | cycle of the loop.  Currently this is 29 bits per loop iteration,
+        | the maximum possible.
+        *--------------------------------------------------------------------*/
+        sigB <<= 9;
+        for (;;) {
+            q64 = (uint32_t) (rem>>32) * (uint_fast64_t) recip32;
+            if ( expDiff < 0 ) break;
+            q = (q64 + 0x80000000)>>32;
+#ifdef SOFTFLOAT_FAST_INT64
+            rem <<= 29;
+#else
+            rem = (uint_fast64_t) (uint32_t) (rem>>3)<<32;
+#endif
+            rem -= q * (uint64_t) sigB;
+            if ( rem & UINT64_C( 0x8000000000000000 ) ) rem += sigB;
+            expDiff -= 29;
+        }
+        /*--------------------------------------------------------------------
+        | (`expDiff' cannot be less than -29 here.)
+        *--------------------------------------------------------------------*/
+        q = (uint32_t) (q64>>32)>>(~expDiff & 31);
+        rem = (rem<<(expDiff + 30)) - q * (uint64_t) sigB;
+        if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+            altRem = rem + sigB;
+            goto selectRem;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    do {
+        altRem = rem;
+        ++q;
+        rem -= sigB;
+    } while ( ! (rem & UINT64_C( 0x8000000000000000 )) );
+ selectRem:
+    meanRem = rem + altRem;
+    if (
+        (meanRem & UINT64_C( 0x8000000000000000 )) || (! meanRem && (q & 1))
+    ) {
+        rem = altRem;
+    }
+    signRem = signA;
+    if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+        signRem = ! signRem;
+        rem = -rem;
+    }
+    return softfloat_normRoundPackToF64( signRem, expB, rem );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto uiZ;
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_roundToInt.c b/arch/riscv/kernel/soft_vector/softfloat/f64_roundToInt.c
new file mode 100644
index 000000000000..c3864bdfc8c7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_roundToInt.c
@@ -0,0 +1,112 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_roundToInt( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    int_fast16_t exp;
+    uint_fast64_t uiZ, lastBitMask, roundBitsMask;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp <= 0x3FE ) {
+        if ( ! (uiA & UINT64_C( 0x7FFFFFFFFFFFFFFF )) ) return a;
+        if ( exact ) softfloat_exceptionFlags |= softfloat_flag_inexact;
+        uiZ = uiA & packToF64UI( 1, 0, 0 );
+        switch ( roundingMode ) {
+         case softfloat_round_near_even:
+            if ( ! fracF64UI( uiA ) ) break;
+         case softfloat_round_near_maxMag:
+            if ( exp == 0x3FE ) uiZ |= packToF64UI( 0, 0x3FF, 0 );
+            break;
+         case softfloat_round_min:
+            if ( uiZ ) uiZ = packToF64UI( 1, 0x3FF, 0 );
+            break;
+         case softfloat_round_max:
+            if ( ! uiZ ) uiZ = packToF64UI( 0, 0x3FF, 0 );
+            break;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x433 <= exp ) {
+        if ( (exp == 0x7FF) && fracF64UI( uiA ) ) {
+            uiZ = softfloat_propagateNaNF64UI( uiA, 0 );
+            goto uiZ;
+        }
+        return a;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uiZ = uiA;
+    lastBitMask = (uint_fast64_t) 1<<(0x433 - exp);
+    roundBitsMask = lastBitMask - 1;
+    if ( roundingMode == softfloat_round_near_maxMag ) {
+        uiZ += lastBitMask>>1;
+    } else if ( roundingMode == softfloat_round_near_even ) {
+        uiZ += lastBitMask>>1;
+        if ( ! (uiZ & roundBitsMask) ) uiZ &= ~lastBitMask;
+    } else if (
+        roundingMode
+            == (signF64UI( uiZ ) ? softfloat_round_min : softfloat_round_max)
+    ) {
+        uiZ += roundBitsMask;
+    }
+    uiZ &= ~roundBitsMask;
+    if ( exact && (uiZ != uiA) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_sqrt.c b/arch/riscv/kernel/soft_vector/softfloat/f64_sqrt.c
new file mode 100644
index 000000000000..d6d18952608a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_sqrt.c
@@ -0,0 +1,133 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t f64_sqrt( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA, uiZ;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+    uint32_t sig32A, recipSqrt32, sig32Z;
+    uint_fast64_t rem;
+    uint32_t q;
+    uint_fast64_t sigZ, shiftedSigZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA ) {
+            uiZ = softfloat_propagateNaNF64UI( uiA, 0 );
+            goto uiZ;
+        }
+        if ( ! signA ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signA ) {
+        if ( ! (expA | sigA) ) return a;
+        goto invalid;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) return a;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    | (`sig32Z' is guaranteed to be a lower bound on the square root of
+    | `sig32A', which makes `sig32Z' also a lower bound on the square root of
+    | `sigA'.)
+    *------------------------------------------------------------------------*/
+    expZ = ((expA - 0x3FF)>>1) + 0x3FE;
+    expA &= 1;
+    sigA |= UINT64_C( 0x0010000000000000 );
+    sig32A = sigA>>21;
+    recipSqrt32 = softfloat_approxRecipSqrt32_1( expA, sig32A );
+    sig32Z = ((uint_fast64_t) sig32A * recipSqrt32)>>32;
+    if ( expA ) {
+        sigA <<= 8;
+        sig32Z >>= 1;
+    } else {
+        sigA <<= 9;
+    }
+    rem = sigA - (uint_fast64_t) sig32Z * sig32Z;
+    q = ((uint32_t) (rem>>2) * (uint_fast64_t) recipSqrt32)>>32;
+    sigZ = ((uint_fast64_t) sig32Z<<32 | 1<<5) + ((uint_fast64_t) q<<3);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( (sigZ & 0x1FF) < 0x22 ) {
+        sigZ &= ~(uint_fast64_t) 0x3F;
+        shiftedSigZ = sigZ>>6;
+        rem = (sigA<<52) - shiftedSigZ * shiftedSigZ;
+        if ( rem & UINT64_C( 0x8000000000000000 ) ) {
+            --sigZ;
+        } else {
+            if ( rem ) sigZ |= 1;
+        }
+    }
+    return softfloat_roundPackToF64( 0, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_sub.c b/arch/riscv/kernel/soft_vector/softfloat/f64_sub.c
new file mode 100644
index 000000000000..aa601055fcb7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_sub.c
@@ -0,0 +1,74 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t f64_sub( float64_t a, float64_t b )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool signA;
+    union ui64_f64 uB;
+    uint_fast64_t uiB;
+    bool signB;
+#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
+    float64_t (*magsFuncPtr)( uint_fast64_t, uint_fast64_t, bool );
+#endif
+
+    uA.f = a;
+    uiA = uA.ui;
+    signA = signF64UI( uiA );
+    uB.f = b;
+    uiB = uB.ui;
+    signB = signF64UI( uiB );
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+    if ( signA == signB ) {
+        return softfloat_subMagsF64( uiA, uiB, signA );
+    } else {
+        return softfloat_addMagsF64( uiA, uiB, signA );
+    }
+#else
+    magsFuncPtr =
+        (signA == signB) ? softfloat_subMagsF64 : softfloat_addMagsF64;
+    return (*magsFuncPtr)( uiA, uiB, signA );
+#endif
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f128.c
new file mode 100644
index 000000000000..361c24611326
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f128.c
@@ -0,0 +1,98 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t f64_to_f128( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t frac;
+    struct commonNaN commonNaN;
+    struct uint128 uiZ;
+    struct exp16_sig64 normExpSig;
+    struct uint128 frac128;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    frac = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FF ) {
+        if ( frac ) {
+            softfloat_f64UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF128UI( &commonNaN );
+        } else {
+            uiZ.v64 = packToF128UI64( sign, 0x7FFF, 0 );
+            uiZ.v0  = 0;
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! exp ) {
+        if ( ! frac ) {
+            uiZ.v64 = packToF128UI64( sign, 0, 0 );
+            uiZ.v0  = 0;
+            goto uiZ;
+        }
+        normExpSig = softfloat_normSubnormalF64Sig( frac );
+        exp = normExpSig.exp - 1;
+        frac = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac128 = softfloat_shortShiftLeft128( 0, frac, 60 );
+    uiZ.v64 = packToF128UI64( sign, exp + 0x3C00, frac128.v64 );
+    uiZ.v0  = frac128.v0;
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f16.c
new file mode 100644
index 000000000000..8b4fe6668b9e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f16.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t f64_to_f16( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t frac;
+    struct commonNaN commonNaN;
+    uint_fast16_t uiZ, frac16;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    frac = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FF ) {
+        if ( frac ) {
+            softfloat_f64UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF16UI( &commonNaN );
+        } else {
+            uiZ = packToF16UI( sign, 0x1F, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac16 = softfloat_shortShiftRightJam64( frac, 38 );
+    if ( ! (exp | frac16) ) {
+        uiZ = packToF16UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    return softfloat_roundPackToF16( sign, exp - 0x3F1, frac16 | 0x4000 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f32.c
new file mode 100644
index 000000000000..9d8412c7ba6d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_f32.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t f64_to_f32( float64_t a )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t frac;
+    struct commonNaN commonNaN;
+    uint_fast32_t uiZ, frac32;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    frac = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp == 0x7FF ) {
+        if ( frac ) {
+            softfloat_f64UIToCommonNaN( uiA, &commonNaN );
+            uiZ = softfloat_commonNaNToF32UI( &commonNaN );
+        } else {
+            uiZ = packToF32UI( sign, 0xFF, 0 );
+        }
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    frac32 = softfloat_shortShiftRightJam64( frac, 22 );
+    if ( ! (exp | frac32) ) {
+        uiZ = packToF32UI( sign, 0, 0 );
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    return softfloat_roundPackToF32( sign, exp - 0x381, frac32 | 0x40000000 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32.c
new file mode 100644
index 000000000000..aa3d673d53e7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32.c
@@ -0,0 +1,82 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f64_to_i32( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (i32_fromNaN != i32_fromPosOverflow) || (i32_fromNaN != i32_fromNegOverflow)
+    if ( (exp == 0x7FF) && sig ) {
+#if (i32_fromNaN == i32_fromPosOverflow)
+        sign = 0;
+#elif (i32_fromNaN == i32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return i32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= UINT64_C( 0x0010000000000000 );
+    shiftDist = 0x427 - exp;
+    if ( 0 < shiftDist ) sig = softfloat_shiftRightJam64( sig, shiftDist );
+    return softfloat_roundToI32( sign, sig, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32_r_minMag.c
new file mode 100644
index 000000000000..ec707a1dcb53
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i32_r_minMag.c
@@ -0,0 +1,96 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t f64_to_i32_r_minMag( float64_t a, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    int_fast32_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF64UI( uiA );
+    sig = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x433 - exp;
+    if ( 53 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF64UI( uiA );
+    if ( shiftDist < 22 ) {
+        if (
+            sign && (exp == 0x41E) && (sig < UINT64_C( 0x0000000000200000 ))
+        ) {
+            if ( exact && sig ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return -0x7FFFFFFF - 1;
+        }
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x7FF) && sig ? i32_fromNaN
+                : sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig |= UINT64_C( 0x0010000000000000 );
+    absZ = sig>>shiftDist;
+    if ( exact && ((uint_fast64_t) (uint_fast32_t) absZ<<shiftDist != sig) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64.c
new file mode 100644
index 000000000000..1119cfa412d5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64.c
@@ -0,0 +1,103 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f64_to_i64( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+#ifdef SOFTFLOAT_FAST_INT64
+    struct uint64_extra sigExtra;
+#else
+    uint32_t extSig[3];
+#endif
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= UINT64_C( 0x0010000000000000 );
+    shiftDist = 0x433 - exp;
+#ifdef SOFTFLOAT_FAST_INT64
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        sigExtra.v = sig<<-shiftDist;
+        sigExtra.extra = 0;
+    } else {
+        sigExtra = softfloat_shiftRightJam64Extra( sig, 0, shiftDist );
+    }
+    return
+        softfloat_roundToI64(
+            sign, sigExtra.v, sigExtra.extra, roundingMode, exact );
+#else
+    extSig[indexWord( 3, 0 )] = 0;
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        sig <<= -shiftDist;
+        extSig[indexWord( 3, 2 )] = sig>>32;
+        extSig[indexWord( 3, 1 )] = sig;
+    } else {
+        extSig[indexWord( 3, 2 )] = sig>>32;
+        extSig[indexWord( 3, 1 )] = sig;
+        softfloat_shiftRightJam96M( extSig, shiftDist, extSig );
+    }
+    return softfloat_roundMToI64( sign, extSig, roundingMode, exact );
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return
+        (exp == 0x7FF) && fracF64UI( uiA ) ? i64_fromNaN
+            : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64_r_minMag.c
new file mode 100644
index 000000000000..012dce40b016
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_i64_r_minMag.c
@@ -0,0 +1,100 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t f64_to_i64_r_minMag( float64_t a, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+    int_fast64_t absZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x433 - exp;
+    if ( shiftDist <= 0 ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( shiftDist < -10 ) {
+            if ( uiA == packToF64UI( 1, 0x43E, 0 ) ) {
+                return -INT64_C( 0x7FFFFFFFFFFFFFFF ) - 1;
+            }
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            return
+                (exp == 0x7FF) && sig ? i64_fromNaN
+                    : sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig |= UINT64_C( 0x0010000000000000 );
+        absZ = sig<<-shiftDist;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( 53 <= shiftDist ) {
+            if ( exact && (exp | sig) ) {
+                softfloat_exceptionFlags |= softfloat_flag_inexact;
+            }
+            return 0;
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig |= UINT64_C( 0x0010000000000000 );
+        absZ = sig>>shiftDist;
+        if ( exact && (absZ<<shiftDist != sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    }
+    return sign ? -absZ : absZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32.c
new file mode 100644
index 000000000000..6bc754f3fe62
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32.c
@@ -0,0 +1,82 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f64_to_ui32( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+#if (ui32_fromNaN != ui32_fromPosOverflow) || (ui32_fromNaN != ui32_fromNegOverflow)
+    if ( (exp == 0x7FF) && sig ) {
+#if (ui32_fromNaN == ui32_fromPosOverflow)
+        sign = 0;
+#elif (ui32_fromNaN == ui32_fromNegOverflow)
+        sign = 1;
+#else
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return ui32_fromNaN;
+#endif
+    }
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= UINT64_C( 0x0010000000000000 );
+    shiftDist = 0x427 - exp;
+    if ( 0 < shiftDist ) sig = softfloat_shiftRightJam64( sig, shiftDist );
+    return softfloat_roundToUI32( sign, sig, roundingMode, exact );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32_r_minMag.c
new file mode 100644
index 000000000000..f6cb542dfa6c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui32_r_minMag.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t f64_to_ui32_r_minMag( float64_t a, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF64UI( uiA );
+    sig = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x433 - exp;
+    if ( 53 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF64UI( uiA );
+    if ( sign || (shiftDist < 21) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        return
+            (exp == 0x7FF) && sig ? ui32_fromNaN
+                : sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig |= UINT64_C( 0x0010000000000000 );
+    z = sig>>shiftDist;
+    if ( exact && ((uint_fast64_t) z<<shiftDist != sig) ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64.c
new file mode 100644
index 000000000000..93097439beda
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64.c
@@ -0,0 +1,103 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f64_to_ui64( float64_t a, uint_fast8_t roundingMode, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    bool sign;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+#ifdef SOFTFLOAT_FAST_INT64
+    struct uint64_extra sigExtra;
+#else
+    uint32_t extSig[3];
+#endif
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    sign = signF64UI( uiA );
+    exp  = expF64UI( uiA );
+    sig  = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( exp ) sig |= UINT64_C( 0x0010000000000000 );
+    shiftDist = 0x433 - exp;
+#ifdef SOFTFLOAT_FAST_INT64
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        sigExtra.v = sig<<-shiftDist;
+        sigExtra.extra = 0;
+    } else {
+        sigExtra = softfloat_shiftRightJam64Extra( sig, 0, shiftDist );
+    }
+    return
+        softfloat_roundToUI64(
+            sign, sigExtra.v, sigExtra.extra, roundingMode, exact );
+#else
+    extSig[indexWord( 3, 0 )] = 0;
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        sig <<= -shiftDist;
+        extSig[indexWord( 3, 2 )] = sig>>32;
+        extSig[indexWord( 3, 1 )] = sig;
+    } else {
+        extSig[indexWord( 3, 2 )] = sig>>32;
+        extSig[indexWord( 3, 1 )] = sig;
+        softfloat_shiftRightJam96M( extSig, shiftDist, extSig );
+    }
+    return softfloat_roundMToUI64( sign, extSig, roundingMode, exact );
+#endif
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return
+        (exp == 0x7FF) && fracF64UI( uiA ) ? ui64_fromNaN
+            : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64_r_minMag.c b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64_r_minMag.c
new file mode 100644
index 000000000000..b8026022c8e8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/f64_to_ui64_r_minMag.c
@@ -0,0 +1,93 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t f64_to_ui64_r_minMag( float64_t a, bool exact )
+{
+    union ui64_f64 uA;
+    uint_fast64_t uiA;
+    int_fast16_t exp;
+    uint_fast64_t sig;
+    int_fast16_t shiftDist;
+    bool sign;
+    uint_fast64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    uA.f = a;
+    uiA = uA.ui;
+    exp = expF64UI( uiA );
+    sig = fracF64UI( uiA );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 0x433 - exp;
+    if ( 53 <= shiftDist ) {
+        if ( exact && (exp | sig) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+        return 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sign = signF64UI( uiA );
+    if ( sign ) goto invalid;
+    if ( shiftDist <= 0 ) {
+        if ( shiftDist < -11 ) goto invalid;
+        z = (sig | UINT64_C( 0x0010000000000000 ))<<-shiftDist;
+    } else {
+        sig |= UINT64_C( 0x0010000000000000 );
+        z = sig>>shiftDist;
+        if ( exact && (uint64_t) (sig<<(-shiftDist & 63)) ) {
+            softfloat_exceptionFlags |= softfloat_flag_inexact;
+        }
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return
+        (exp == 0x7FF) && sig ? ui64_fromNaN
+            : sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/fall_maxmin.c b/arch/riscv/kernel/soft_vector/softfloat/fall_maxmin.c
new file mode 100644
index 000000000000..064b7d555348
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/fall_maxmin.c
@@ -0,0 +1,80 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+#define COMPARE_MAX(a, b, bits) \
+float ## bits ## _t f ## bits ## _max( float ## bits ## _t a, float ## bits ## _t b )          \
+{                                                                                              \
+    bool greater = f ## bits ## _lt_quiet(b, a) ||                                             \
+               (f ## bits ## _eq(b, a) && signF ## bits ## UI(b.v));                           \
+                                                                                               \
+    if (isNaNF ## bits ## UI(a.v) && isNaNF ## bits ## UI(b.v)) {                              \
+        union ui ## bits ## _f ## bits  ui;                                                    \
+        ui.ui = defaultNaNF ## bits ## UI;                                                     \
+        return ui.f;                                                                           \
+    } else {                                                                                   \
+        return greater || isNaNF ## bits ## UI((b).v) ? a : b;                                 \
+    }                                                                                          \
+}
+
+#define COMPARE_MIN(a, b, bits) \
+float ## bits ## _t f ## bits ## _min( float ## bits ## _t a, float ## bits ## _t b )          \
+{                                                                                              \
+    bool less = f ## bits ## _lt_quiet(a, b) ||                                                \
+               (f ## bits ## _eq(a, b) && signF ## bits ## UI(a.v));                           \
+                                                                                               \
+    if (isNaNF ## bits ## UI(a.v) && isNaNF ## bits ## UI(b.v)) {                              \
+        union ui ## bits ## _f ## bits  ui;                                                    \
+        ui.ui = defaultNaNF ## bits ## UI;                                                     \
+        return ui.f;                                                                           \
+    } else {                                                                                   \
+        return less || isNaNF ## bits ## UI((b).v) ? a : b;                                    \
+    }                                                                                          \
+}
+
+COMPARE_MAX(a, b, 16);
+COMPARE_MAX(a, b, 32);
+COMPARE_MAX(a, b, 64);
+
+COMPARE_MIN(a, b, 16);
+COMPARE_MIN(a, b, 32);
+COMPARE_MIN(a, b, 64);
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i32_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f128.c
new file mode 100644
index 000000000000..8ad1b3a22662
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f128.c
@@ -0,0 +1,64 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t i32_to_f128( int32_t a )
+{
+    uint_fast64_t uiZ64;
+    bool sign;
+    uint_fast32_t absA;
+    int_fast8_t shiftDist;
+    union ui128_f128 uZ;
+
+    uiZ64 = 0;
+    if ( a ) {
+        sign = (a < 0);
+        absA = sign ? -(uint_fast32_t) a : (uint_fast32_t) a;
+        shiftDist = softfloat_countLeadingZeros32( absA ) + 17;
+        uiZ64 =
+            packToF128UI64(
+                sign, 0x402E - shiftDist, (uint_fast64_t) absA<<shiftDist );
+    }
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = 0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i32_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f16.c
new file mode 100644
index 000000000000..a2940d0ca9af
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f16.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t i32_to_f16( int32_t a )
+{
+    bool sign;
+    uint_fast32_t absA;
+    int_fast8_t shiftDist;
+    union ui16_f16 u;
+    uint_fast16_t sig;
+
+    sign = (a < 0);
+    absA = sign ? -(uint_fast32_t) a : (uint_fast32_t) a;
+    shiftDist = softfloat_countLeadingZeros32( absA ) - 21;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF16UI(
+                    sign, 0x18 - shiftDist, (uint_fast16_t) absA<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 4;
+        sig =
+            (shiftDist < 0)
+                ? absA>>(-shiftDist)
+                      | ((uint32_t) (absA<<(shiftDist & 31)) != 0)
+                : (uint_fast16_t) absA<<shiftDist;
+        return softfloat_roundPackToF16( sign, 0x1C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i32_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f32.c
new file mode 100644
index 000000000000..15ada6cf80a0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f32.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t i32_to_f32( int32_t a )
+{
+    bool sign;
+    union ui32_f32 uZ;
+    uint_fast32_t absA;
+
+    sign = (a < 0);
+    if ( ! (a & 0x7FFFFFFF) ) {
+        uZ.ui = sign ? packToF32UI( 1, 0x9E, 0 ) : 0;
+        return uZ.f;
+    }
+    absA = sign ? -(uint_fast32_t) a : (uint_fast32_t) a;
+    return softfloat_normRoundPackToF32( sign, 0x9C, absA );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i32_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f64.c
new file mode 100644
index 000000000000..17e4d7afb997
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i32_to_f64.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t i32_to_f64( int32_t a )
+{
+    uint_fast64_t uiZ;
+    bool sign;
+    uint_fast32_t absA;
+    int_fast8_t shiftDist;
+    union ui64_f64 uZ;
+
+    if ( ! a ) {
+        uiZ = 0;
+    } else {
+        sign = (a < 0);
+        absA = sign ? -(uint_fast32_t) a : (uint_fast32_t) a;
+        shiftDist = softfloat_countLeadingZeros32( absA ) + 21;
+        uiZ =
+            packToF64UI(
+                sign, 0x432 - shiftDist, (uint_fast64_t) absA<<shiftDist );
+    }
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i64_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f128.c
new file mode 100644
index 000000000000..5d7307994ee6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f128.c
@@ -0,0 +1,72 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t i64_to_f128( int64_t a )
+{
+    uint_fast64_t uiZ64, uiZ0;
+    bool sign;
+    uint_fast64_t absA;
+    int_fast8_t shiftDist;
+    struct uint128 zSig;
+    union ui128_f128 uZ;
+
+    if ( ! a ) {
+        uiZ64 = 0;
+        uiZ0  = 0;
+    } else {
+        sign = (a < 0);
+        absA = sign ? -(uint_fast64_t) a : (uint_fast64_t) a;
+        shiftDist = softfloat_countLeadingZeros64( absA ) + 49;
+        if ( 64 <= shiftDist ) {
+            zSig.v64 = absA<<(shiftDist - 64);
+            zSig.v0  = 0;
+        } else {
+            zSig = softfloat_shortShiftLeft128( 0, absA, shiftDist );
+        }
+        uiZ64 = packToF128UI64( sign, 0x406E - shiftDist, zSig.v64 );
+        uiZ0  = zSig.v0;
+    }
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = uiZ0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i64_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f16.c
new file mode 100644
index 000000000000..ba86b9b837af
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f16.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t i64_to_f16( int64_t a )
+{
+    bool sign;
+    uint_fast64_t absA;
+    int_fast8_t shiftDist;
+    union ui16_f16 u;
+    uint_fast16_t sig;
+
+    sign = (a < 0);
+    absA = sign ? -(uint_fast64_t) a : (uint_fast64_t) a;
+    shiftDist = softfloat_countLeadingZeros64( absA ) - 53;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF16UI(
+                    sign, 0x18 - shiftDist, (uint_fast16_t) absA<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 4;
+        sig =
+            (shiftDist < 0)
+                ? softfloat_shortShiftRightJam64( absA, -shiftDist )
+                : (uint_fast16_t) absA<<shiftDist;
+        return softfloat_roundPackToF16( sign, 0x1C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i64_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f32.c
new file mode 100644
index 000000000000..f2fc42c09bf0
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f32.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t i64_to_f32( int64_t a )
+{
+    bool sign;
+    uint_fast64_t absA;
+    int_fast8_t shiftDist;
+    union ui32_f32 u;
+    uint_fast32_t sig;
+
+    sign = (a < 0);
+    absA = sign ? -(uint_fast64_t) a : (uint_fast64_t) a;
+    shiftDist = softfloat_countLeadingZeros64( absA ) - 40;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF32UI(
+                    sign, 0x95 - shiftDist, (uint_fast32_t) absA<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 7;
+        sig =
+            (shiftDist < 0)
+                ? softfloat_shortShiftRightJam64( absA, -shiftDist )
+                : (uint_fast32_t) absA<<shiftDist;
+        return softfloat_roundPackToF32( sign, 0x9C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/i64_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f64.c
new file mode 100644
index 000000000000..52df1129f19e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/i64_to_f64.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t i64_to_f64( int64_t a )
+{
+    bool sign;
+    union ui64_f64 uZ;
+    uint_fast64_t absA;
+
+    sign = (a < 0);
+    if ( ! (a & UINT64_C( 0x7FFFFFFFFFFFFFFF )) ) {
+        uZ.ui = sign ? packToF64UI( 1, 0x43E, 0 ) : 0;
+        return uZ.f;
+    }
+    absA = sign ? -(uint_fast64_t) a : (uint_fast64_t) a;
+    return softfloat_normRoundPackToF64( sign, 0x43C, absA );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/internals.h b/arch/riscv/kernel/soft_vector/softfloat/internals.h
new file mode 100644
index 000000000000..16a848b2f9cd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/internals.h
@@ -0,0 +1,286 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef internals_h
+#define internals_h 1
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "primitives.h"
+#include "softfloat_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+union ui16_f16 { uint16_t ui; float16_t f; };
+union ui32_f32 { uint32_t ui; float32_t f; };
+union ui64_f64 { uint64_t ui; float64_t f; };
+
+#ifdef SOFTFLOAT_FAST_INT64
+union extF80M_extF80 { struct extFloat80M fM; extFloat80_t f; };
+union ui128_f128 { struct uint128 ui; float128_t f; };
+#endif
+
+enum {
+    softfloat_mulAdd_subC    = 1,
+    softfloat_mulAdd_subProd = 2
+};
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+uint_fast32_t softfloat_roundToUI32( bool, uint_fast64_t, uint_fast8_t, bool );
+
+#ifdef SOFTFLOAT_FAST_INT64
+uint_fast64_t
+ softfloat_roundToUI64(
+     bool, uint_fast64_t, uint_fast64_t, uint_fast8_t, bool );
+#else
+uint_fast64_t softfloat_roundMToUI64( bool, uint32_t *, uint_fast8_t, bool );
+#endif
+
+int_fast32_t softfloat_roundToI32( bool, uint_fast64_t, uint_fast8_t, bool );
+
+#ifdef SOFTFLOAT_FAST_INT64
+int_fast64_t
+ softfloat_roundToI64(
+     bool, uint_fast64_t, uint_fast64_t, uint_fast8_t, bool );
+#else
+int_fast64_t softfloat_roundMToI64( bool, uint32_t *, uint_fast8_t, bool );
+#endif
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF16UI( a ) ((bool) ((uint16_t) (a)>>15))
+#define expF16UI( a ) ((int_fast8_t) ((a)>>10) & 0x1F)
+#define fracF16UI( a ) ((a) & 0x03FF)
+#define packToF16UI( sign, exp, sig ) (((uint16_t) (sign)<<15) + ((uint16_t) (exp)<<10) + (sig))
+
+#define isNaNF16UI( a ) (((~(a) & 0x7C00) == 0) && ((a) & 0x03FF))
+
+struct exp8_sig16 { int_fast8_t exp; uint_fast16_t sig; };
+struct exp8_sig16 softfloat_normSubnormalF16Sig( uint_fast16_t );
+
+float16_t softfloat_roundPackToF16( bool, int_fast16_t, uint_fast16_t );
+float16_t softfloat_normRoundPackToF16( bool, int_fast16_t, uint_fast16_t );
+
+float16_t softfloat_addMagsF16( uint_fast16_t, uint_fast16_t );
+float16_t softfloat_subMagsF16( uint_fast16_t, uint_fast16_t );
+float16_t
+ softfloat_mulAddF16(
+     uint_fast16_t, uint_fast16_t, uint_fast16_t, uint_fast8_t );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF32UI( a ) ((bool) ((uint32_t) (a)>>31))
+#define expF32UI( a ) ((int_fast16_t) ((a)>>23) & 0xFF)
+#define fracF32UI( a ) ((a) & 0x007FFFFF)
+#define packToF32UI( sign, exp, sig ) (((uint32_t) (sign)<<31) + ((uint32_t) (exp)<<23) + (sig))
+
+#define isNaNF32UI( a ) (((~(a) & 0x7F800000) == 0) && ((a) & 0x007FFFFF))
+
+struct exp16_sig32 { int_fast16_t exp; uint_fast32_t sig; };
+struct exp16_sig32 softfloat_normSubnormalF32Sig( uint_fast32_t );
+
+float32_t softfloat_roundPackToF32( bool, int_fast16_t, uint_fast32_t );
+float32_t softfloat_normRoundPackToF32( bool, int_fast16_t, uint_fast32_t );
+
+float32_t softfloat_addMagsF32( uint_fast32_t, uint_fast32_t );
+float32_t softfloat_subMagsF32( uint_fast32_t, uint_fast32_t );
+float32_t
+ softfloat_mulAddF32(
+     uint_fast32_t, uint_fast32_t, uint_fast32_t, uint_fast8_t );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF64UI( a ) ((bool) ((uint64_t) (a)>>63))
+#define expF64UI( a ) ((int_fast16_t) ((a)>>52) & 0x7FF)
+#define fracF64UI( a ) ((a) & UINT64_C( 0x000FFFFFFFFFFFFF ))
+#define packToF64UI( sign, exp, sig ) ((uint64_t) (((uint_fast64_t) (sign)<<63) + ((uint_fast64_t) (exp)<<52) + (sig)))
+
+#define isNaNF64UI( a ) (((~(a) & UINT64_C( 0x7FF0000000000000 )) == 0) && ((a) & UINT64_C( 0x000FFFFFFFFFFFFF )))
+
+struct exp16_sig64 { int_fast16_t exp; uint_fast64_t sig; };
+struct exp16_sig64 softfloat_normSubnormalF64Sig( uint_fast64_t );
+
+float64_t softfloat_roundPackToF64( bool, int_fast16_t, uint_fast64_t );
+float64_t softfloat_normRoundPackToF64( bool, int_fast16_t, uint_fast64_t );
+
+float64_t softfloat_addMagsF64( uint_fast64_t, uint_fast64_t, bool );
+float64_t softfloat_subMagsF64( uint_fast64_t, uint_fast64_t, bool );
+float64_t
+ softfloat_mulAddF64(
+     uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast8_t );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signExtF80UI64( a64 ) ((bool) ((uint16_t) (a64)>>15))
+#define expExtF80UI64( a64 ) ((a64) & 0x7FFF)
+#define packToExtF80UI64( sign, exp ) ((uint_fast16_t) (sign)<<15 | (exp))
+
+#define isNaNExtF80UI( a64, a0 ) ((((a64) & 0x7FFF) == 0x7FFF) && ((a0) & UINT64_C( 0x7FFFFFFFFFFFFFFF )))
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+
+struct exp32_sig64 { int_fast32_t exp; uint64_t sig; };
+struct exp32_sig64 softfloat_normSubnormalExtF80Sig( uint_fast64_t );
+
+extFloat80_t
+ softfloat_roundPackToExtF80(
+     bool, int_fast32_t, uint_fast64_t, uint_fast64_t, uint_fast8_t );
+extFloat80_t
+ softfloat_normRoundPackToExtF80(
+     bool, int_fast32_t, uint_fast64_t, uint_fast64_t, uint_fast8_t );
+
+extFloat80_t
+ softfloat_addMagsExtF80(
+     uint_fast16_t, uint_fast64_t, uint_fast16_t, uint_fast64_t, bool );
+extFloat80_t
+ softfloat_subMagsExtF80(
+     uint_fast16_t, uint_fast64_t, uint_fast16_t, uint_fast64_t, bool );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF128UI64( a64 ) ((bool) ((uint64_t) (a64)>>63))
+#define expF128UI64( a64 ) ((int_fast32_t) ((a64)>>48) & 0x7FFF)
+#define fracF128UI64( a64 ) ((a64) & UINT64_C( 0x0000FFFFFFFFFFFF ))
+#define packToF128UI64( sign, exp, sig64 ) (((uint_fast64_t) (sign)<<63) + ((uint_fast64_t) (exp)<<48) + (sig64))
+
+#define isNaNF128UI( a64, a0 ) (((~(a64) & UINT64_C( 0x7FFF000000000000 )) == 0) && (a0 || ((a64) & UINT64_C( 0x0000FFFFFFFFFFFF ))))
+
+struct exp32_sig128 { int_fast32_t exp; struct uint128 sig; };
+struct exp32_sig128
+ softfloat_normSubnormalF128Sig( uint_fast64_t, uint_fast64_t );
+
+float128_t
+ softfloat_roundPackToF128(
+     bool, int_fast32_t, uint_fast64_t, uint_fast64_t, uint_fast64_t );
+float128_t
+ softfloat_normRoundPackToF128(
+     bool, int_fast32_t, uint_fast64_t, uint_fast64_t );
+
+float128_t
+ softfloat_addMagsF128(
+     uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast64_t, bool );
+float128_t
+ softfloat_subMagsF128(
+     uint_fast64_t, uint_fast64_t, uint_fast64_t, uint_fast64_t, bool );
+float128_t
+ softfloat_mulAddF128(
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast64_t,
+     uint_fast8_t
+ );
+
+#else
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+
+bool
+ softfloat_tryPropagateNaNExtF80M(
+     const struct extFloat80M *,
+     const struct extFloat80M *,
+     struct extFloat80M *
+ );
+void softfloat_invalidExtF80M( struct extFloat80M * );
+
+int softfloat_normExtF80SigM( uint64_t * );
+
+void
+ softfloat_roundPackMToExtF80M(
+     bool, int32_t, uint32_t *, uint_fast8_t, struct extFloat80M * );
+void
+ softfloat_normRoundPackMToExtF80M(
+     bool, int32_t, uint32_t *, uint_fast8_t, struct extFloat80M * );
+
+void
+ softfloat_addExtF80M(
+     const struct extFloat80M *,
+     const struct extFloat80M *,
+     struct extFloat80M *,
+     bool
+ );
+
+int
+ softfloat_compareNonnormExtF80M(
+     const struct extFloat80M *, const struct extFloat80M * );
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define signF128UI96( a96 ) ((bool) ((uint32_t) (a96)>>31))
+#define expF128UI96( a96 ) ((int32_t) ((a96)>>16) & 0x7FFF)
+#define fracF128UI96( a96 ) ((a96) & 0x0000FFFF)
+#define packToF128UI96( sign, exp, sig96 ) (((uint32_t) (sign)<<31) + ((uint32_t) (exp)<<16) + (sig96))
+
+bool softfloat_isNaNF128M( const uint32_t * );
+
+bool
+ softfloat_tryPropagateNaNF128M(
+     const uint32_t *, const uint32_t *, uint32_t * );
+void softfloat_invalidF128M( uint32_t * );
+
+int softfloat_shiftNormSigF128M( const uint32_t *, uint_fast8_t, uint32_t * );
+
+void softfloat_roundPackMToF128M( bool, int32_t, uint32_t *, uint32_t * );
+void softfloat_normRoundPackMToF128M( bool, int32_t, uint32_t *, uint32_t * );
+
+void
+ softfloat_addF128M( const uint32_t *, const uint32_t *, uint32_t *, bool );
+void
+ softfloat_mulAddF128M(
+     const uint32_t *,
+     const uint32_t *,
+     const uint32_t *,
+     uint32_t *,
+     uint_fast8_t
+ );
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/platform.h b/arch/riscv/kernel/soft_vector/softfloat/platform.h
new file mode 100644
index 000000000000..55de1941a725
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/platform.h
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#include "config.h"
+#ifndef WORDS_BIGENDIAN
+#define LITTLEENDIAN 1
+#endif
+
+#define INLINE_LEVEL 5
+#define SOFTFLOAT_FAST_INT64
+#define SOFTFLOAT_FAST_DIV64TO32
+#define SOFTFLOAT_ROUND_ODD
+
+/*----------------------------------------------------------------------------
+*----------------------------------------------------------------------------*/
+#define INLINE static inline
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/primitiveTypes.h b/arch/riscv/kernel/soft_vector/softfloat/primitiveTypes.h
new file mode 100644
index 000000000000..93951bcd9229
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/primitiveTypes.h
@@ -0,0 +1,86 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef primitiveTypes_h
+#define primitiveTypes_h 1
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+#ifdef LITTLEENDIAN
+struct uint128 { uint64_t v0, v64; };
+struct uint64_extra { uint64_t extra, v; };
+struct uint128_extra { uint64_t extra; struct uint128 v; };
+#else
+struct uint128 { uint64_t v64, v0; };
+struct uint64_extra { uint64_t v, extra; };
+struct uint128_extra { struct uint128 v; uint64_t extra; };
+#endif
+
+#endif
+
+/*----------------------------------------------------------------------------
+| These macros are used to isolate the differences in word order between big-
+| endian and little-endian platforms.
+*----------------------------------------------------------------------------*/
+#ifdef LITTLEENDIAN
+#define wordIncr 1
+#define indexWord( total, n ) (n)
+#define indexWordHi( total ) ((total) - 1)
+#define indexWordLo( total ) 0
+#define indexMultiword( total, m, n ) (n)
+#define indexMultiwordHi( total, n ) ((total) - (n))
+#define indexMultiwordLo( total, n ) 0
+#define indexMultiwordHiBut( total, n ) (n)
+#define indexMultiwordLoBut( total, n ) 0
+#define INIT_UINTM4( v3, v2, v1, v0 ) { v0, v1, v2, v3 }
+#else
+#define wordIncr -1
+#define indexWord( total, n ) ((total) - 1 - (n))
+#define indexWordHi( total ) 0
+#define indexWordLo( total ) ((total) - 1)
+#define indexMultiword( total, m, n ) ((total) - 1 - (m))
+#define indexMultiwordHi( total, n ) 0
+#define indexMultiwordLo( total, n ) ((total) - (n))
+#define indexMultiwordHiBut( total, n ) 0
+#define indexMultiwordLoBut( total, n ) (n)
+#define INIT_UINTM4( v3, v2, v1, v0 ) { v3, v2, v1, v0 }
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/primitives.h b/arch/riscv/kernel/soft_vector/softfloat/primitives.h
new file mode 100644
index 000000000000..b2bb4edbf427
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/primitives.h
@@ -0,0 +1,1168 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef primitives_h
+#define primitives_h 1
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "primitiveTypes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef softfloat_shortShiftRightJam64
+/*----------------------------------------------------------------------------
+| Shifts 'a' right by the number of bits given in 'dist', which must be in
+| the range 1 to 63.  If any nonzero bits are shifted off, they are "jammed"
+| into the least-significant bit of the shifted value by setting the least-
+| significant bit to 1.  This shifted-and-jammed value is returned.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+uint64_t softfloat_shortShiftRightJam64( uint64_t a, uint_fast8_t dist )
+    { return a>>dist | ((a & (((uint_fast64_t) 1<<dist) - 1)) != 0); }
+#else
+uint64_t softfloat_shortShiftRightJam64( uint64_t a, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shiftRightJam32
+/*----------------------------------------------------------------------------
+| Shifts 'a' right by the number of bits given in 'dist', which must not
+| be zero.  If any nonzero bits are shifted off, they are "jammed" into the
+| least-significant bit of the shifted value by setting the least-significant
+| bit to 1.  This shifted-and-jammed value is returned.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than 32, the result will be either 0 or 1, depending on whether 'a'
+| is zero or nonzero.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE uint32_t softfloat_shiftRightJam32( uint32_t a, uint_fast16_t dist )
+{
+    return
+        (dist < 31) ? a>>dist | ((uint32_t) (a<<(-dist & 31)) != 0) : (a != 0);
+}
+#else
+uint32_t softfloat_shiftRightJam32( uint32_t a, uint_fast16_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shiftRightJam64
+/*----------------------------------------------------------------------------
+| Shifts 'a' right by the number of bits given in 'dist', which must not
+| be zero.  If any nonzero bits are shifted off, they are "jammed" into the
+| least-significant bit of the shifted value by setting the least-significant
+| bit to 1.  This shifted-and-jammed value is returned.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than 64, the result will be either 0 or 1, depending on whether 'a'
+| is zero or nonzero.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE uint64_t softfloat_shiftRightJam64( uint64_t a, uint_fast32_t dist )
+{
+    return
+        (dist < 63) ? a>>dist | ((uint64_t) (a<<(-dist & 63)) != 0) : (a != 0);
+}
+#else
+uint64_t softfloat_shiftRightJam64( uint64_t a, uint_fast32_t dist );
+#endif
+#endif
+
+/*----------------------------------------------------------------------------
+| A constant table that translates an 8-bit unsigned integer (the array index)
+| into the number of leading 0 bits before the most-significant 1 of that
+| integer.  For integer zero (index 0), the corresponding table element is 8.
+*----------------------------------------------------------------------------*/
+extern const uint_least8_t softfloat_countLeadingZeros8[256];
+
+#ifndef softfloat_countLeadingZeros16
+/*----------------------------------------------------------------------------
+| Returns the number of leading 0 bits before the most-significant 1 bit of
+| 'a'.  If 'a' is zero, 16 is returned.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE uint_fast8_t softfloat_countLeadingZeros16( uint16_t a )
+{
+    uint_fast8_t count = 8;
+    if ( 0x100 <= a ) {
+        count = 0;
+        a >>= 8;
+    }
+    count += softfloat_countLeadingZeros8[a];
+    return count;
+}
+#else
+uint_fast8_t softfloat_countLeadingZeros16( uint16_t a );
+#endif
+#endif
+
+#ifndef softfloat_countLeadingZeros32
+/*----------------------------------------------------------------------------
+| Returns the number of leading 0 bits before the most-significant 1 bit of
+| 'a'.  If 'a' is zero, 32 is returned.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE uint_fast8_t softfloat_countLeadingZeros32( uint32_t a )
+{
+    uint_fast8_t count = 0;
+    if ( a < 0x10000 ) {
+        count = 16;
+        a <<= 16;
+    }
+    if ( a < 0x1000000 ) {
+        count += 8;
+        a <<= 8;
+    }
+    count += softfloat_countLeadingZeros8[a>>24];
+    return count;
+}
+#else
+uint_fast8_t softfloat_countLeadingZeros32( uint32_t a );
+#endif
+#endif
+
+#ifndef softfloat_countLeadingZeros64
+/*----------------------------------------------------------------------------
+| Returns the number of leading 0 bits before the most-significant 1 bit of
+| 'a'.  If 'a' is zero, 64 is returned.
+*----------------------------------------------------------------------------*/
+uint_fast8_t softfloat_countLeadingZeros64( uint64_t a );
+#endif
+
+extern const uint16_t softfloat_approxRecip_1k0s[16];
+extern const uint16_t softfloat_approxRecip_1k1s[16];
+
+#ifndef softfloat_approxRecip32_1
+/*----------------------------------------------------------------------------
+| Returns an approximation to the reciprocal of the number represented by 'a',
+| where 'a' is interpreted as an unsigned fixed-point number with one integer
+| bit and 31 fraction bits.  The 'a' input must be "normalized", meaning that
+| its most-significant bit (bit 31) must be 1.  Thus, if A is the value of
+| the fixed-point interpretation of 'a', then 1 <= A < 2.  The returned value
+| is interpreted as a pure unsigned fraction, having no integer bits and 32
+| fraction bits.  The approximation returned is never greater than the true
+| reciprocal 1/A, and it differs from the true reciprocal by at most 2.006 ulp
+| (units in the last place).
+*----------------------------------------------------------------------------*/
+#ifdef SOFTFLOAT_FAST_DIV64TO32
+#define softfloat_approxRecip32_1( a ) ((uint32_t) (UINT64_C( 0x7FFFFFFFFFFFFFFF ) / (uint32_t) (a)))
+#else
+uint32_t softfloat_approxRecip32_1( uint32_t a );
+#endif
+#endif
+
+extern const uint16_t softfloat_approxRecipSqrt_1k0s[16];
+extern const uint16_t softfloat_approxRecipSqrt_1k1s[16];
+
+#ifndef softfloat_approxRecipSqrt32_1
+/*----------------------------------------------------------------------------
+| Returns an approximation to the reciprocal of the square root of the number
+| represented by 'a', where 'a' is interpreted as an unsigned fixed-point
+| number either with one integer bit and 31 fraction bits or with two integer
+| bits and 30 fraction bits.  The format of 'a' is determined by 'oddExpA',
+| which must be either 0 or 1.  If 'oddExpA' is 1, 'a' is interpreted as
+| having one integer bit, and if 'oddExpA' is 0, 'a' is interpreted as having
+| two integer bits.  The 'a' input must be "normalized", meaning that its
+| most-significant bit (bit 31) must be 1.  Thus, if A is the value of the
+| fixed-point interpretation of 'a', it follows that 1 <= A < 2 when 'oddExpA'
+| is 1, and 2 <= A < 4 when 'oddExpA' is 0.
+|   The returned value is interpreted as a pure unsigned fraction, having
+| no integer bits and 32 fraction bits.  The approximation returned is never
+| greater than the true reciprocal 1/sqrt(A), and it differs from the true
+| reciprocal by at most 2.06 ulp (units in the last place).  The approximation
+| returned is also always within the range 0.5 to 1; thus, the most-
+| significant bit of the result is always set.
+*----------------------------------------------------------------------------*/
+uint32_t softfloat_approxRecipSqrt32_1( unsigned int oddExpA, uint32_t a );
+#endif
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when 'SOFTFLOAT_FAST_INT64' is
+| defined.
+*----------------------------------------------------------------------------*/
+
+#ifndef softfloat_eq128
+/*----------------------------------------------------------------------------
+| Returns true if the 128-bit unsigned integer formed by concatenating 'a64'
+| and 'a0' is equal to the 128-bit unsigned integer formed by concatenating
+| 'b64' and 'b0'.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (1 <= INLINE_LEVEL)
+INLINE
+bool softfloat_eq128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+    { return (a64 == b64) && (a0 == b0); }
+#else
+bool softfloat_eq128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_le128
+/*----------------------------------------------------------------------------
+| Returns true if the 128-bit unsigned integer formed by concatenating 'a64'
+| and 'a0' is less than or equal to the 128-bit unsigned integer formed by
+| concatenating 'b64' and 'b0'.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+bool softfloat_le128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+    { return (a64 < b64) || ((a64 == b64) && (a0 <= b0)); }
+#else
+bool softfloat_le128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_lt128
+/*----------------------------------------------------------------------------
+| Returns true if the 128-bit unsigned integer formed by concatenating 'a64'
+| and 'a0' is less than the 128-bit unsigned integer formed by concatenating
+| 'b64' and 'b0'.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+bool softfloat_lt128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+    { return (a64 < b64) || ((a64 == b64) && (a0 < b0)); }
+#else
+bool softfloat_lt128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftLeft128
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a64' and 'a0' left by the
+| number of bits given in 'dist', which must be in the range 1 to 63.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_shortShiftLeft128( uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    struct uint128 z;
+    z.v64 = a64<<dist | a0>>(-dist & 63);
+    z.v0 = a0<<dist;
+    return z;
+}
+#else
+struct uint128
+ softfloat_shortShiftLeft128( uint64_t a64, uint64_t a0, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftRight128
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a64' and 'a0' right by the
+| number of bits given in 'dist', which must be in the range 1 to 63.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_shortShiftRight128( uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    struct uint128 z;
+    z.v64 = a64>>dist;
+    z.v0 = a64<<(-dist & 63) | a0>>dist;
+    return z;
+}
+#else
+struct uint128
+ softfloat_shortShiftRight128( uint64_t a64, uint64_t a0, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftRightJam64Extra
+/*----------------------------------------------------------------------------
+| This function is the same as 'softfloat_shiftRightJam64Extra' (below),
+| except that 'dist' must be in the range 1 to 63.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint64_extra
+ softfloat_shortShiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast8_t dist )
+{
+    struct uint64_extra z;
+    z.v = a>>dist;
+    z.extra = a<<(-dist & 63) | (extra != 0);
+    return z;
+}
+#else
+struct uint64_extra
+ softfloat_shortShiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftRightJam128
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a64' and 'a0' right by the
+| number of bits given in 'dist', which must be in the range 1 to 63.  If any
+| nonzero bits are shifted off, they are "jammed" into the least-significant
+| bit of the shifted value by setting the least-significant bit to 1.  This
+| shifted-and-jammed value is returned.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_shortShiftRightJam128(
+     uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    uint_fast8_t negDist = -dist;
+    struct uint128 z;
+    z.v64 = a64>>dist;
+    z.v0 =
+        a64<<(negDist & 63) | a0>>dist
+            | ((uint64_t) (a0<<(negDist & 63)) != 0);
+    return z;
+}
+#else
+struct uint128
+ softfloat_shortShiftRightJam128(
+     uint64_t a64, uint64_t a0, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftRightJam128Extra
+/*----------------------------------------------------------------------------
+| This function is the same as 'softfloat_shiftRightJam128Extra' (below),
+| except that 'dist' must be in the range 1 to 63.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE
+struct uint128_extra
+ softfloat_shortShiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast8_t dist )
+{
+    uint_fast8_t negDist = -dist;
+    struct uint128_extra z;
+    z.v.v64 = a64>>dist;
+    z.v.v0 = a64<<(negDist & 63) | a0>>dist;
+    z.extra = a0<<(negDist & 63) | (extra != 0);
+    return z;
+}
+#else
+struct uint128_extra
+ softfloat_shortShiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast8_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shiftRightJam64Extra
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a' and 'extra' right by 64
+| _plus_ the number of bits given in 'dist', which must not be zero.  This
+| shifted value is at most 64 nonzero bits and is returned in the 'v' field
+| of the 'struct uint64_extra' result.  The 64-bit 'extra' field of the result
+| contains a value formed as follows from the bits that were shifted off:  The
+| _last_ bit shifted off is the most-significant bit of the 'extra' field, and
+| the other 63 bits of the 'extra' field are all zero if and only if _all_but_
+| _the_last_ bits shifted off were all zero.
+|   (This function makes more sense if 'a' and 'extra' are considered to form
+| an unsigned fixed-point number with binary point between 'a' and 'extra'.
+| This fixed-point value is shifted right by the number of bits given in
+| 'dist', and the integer part of this shifted value is returned in the 'v'
+| field of the result.  The fractional part of the shifted value is modified
+| as described above and returned in the 'extra' field of the result.)
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (4 <= INLINE_LEVEL)
+INLINE
+struct uint64_extra
+ softfloat_shiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast32_t dist )
+{
+    struct uint64_extra z;
+    if ( dist < 64 ) {
+        z.v = a>>dist;
+        z.extra = a<<(-dist & 63);
+    } else {
+        z.v = 0;
+        z.extra = (dist == 64) ? a : (a != 0);
+    }
+    z.extra |= (extra != 0);
+    return z;
+}
+#else
+struct uint64_extra
+ softfloat_shiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast32_t dist );
+#endif
+#endif
+
+#ifndef softfloat_shiftRightJam128
+/*----------------------------------------------------------------------------
+| Shifts the 128 bits formed by concatenating 'a64' and 'a0' right by the
+| number of bits given in 'dist', which must not be zero.  If any nonzero bits
+| are shifted off, they are "jammed" into the least-significant bit of the
+| shifted value by setting the least-significant bit to 1.  This shifted-and-
+| jammed value is returned.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than 128, the result will be either 0 or 1, depending on whether the
+| original 128 bits are all zeros.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_shiftRightJam128( uint64_t a64, uint64_t a0, uint_fast32_t dist );
+#endif
+
+#ifndef softfloat_shiftRightJam128Extra
+/*----------------------------------------------------------------------------
+| Shifts the 192 bits formed by concatenating 'a64', 'a0', and 'extra' right
+| by 64 _plus_ the number of bits given in 'dist', which must not be zero.
+| This shifted value is at most 128 nonzero bits and is returned in the 'v'
+| field of the 'struct uint128_extra' result.  The 64-bit 'extra' field of the
+| result contains a value formed as follows from the bits that were shifted
+| off:  The _last_ bit shifted off is the most-significant bit of the 'extra'
+| field, and the other 63 bits of the 'extra' field are all zero if and only
+| if _all_but_the_last_ bits shifted off were all zero.
+|   (This function makes more sense if 'a64', 'a0', and 'extra' are considered
+| to form an unsigned fixed-point number with binary point between 'a0' and
+| 'extra'.  This fixed-point value is shifted right by the number of bits
+| given in 'dist', and the integer part of this shifted value is returned
+| in the 'v' field of the result.  The fractional part of the shifted value
+| is modified as described above and returned in the 'extra' field of the
+| result.)
+*----------------------------------------------------------------------------*/
+struct uint128_extra
+ softfloat_shiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast32_t dist );
+#endif
+
+#ifndef softfloat_shiftRightJam256M
+/*----------------------------------------------------------------------------
+| Shifts the 256-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', which must not be zero.  If any nonzero bits are
+| shifted off, they are "jammed" into the least-significant bit of the shifted
+| value by setting the least-significant bit to 1.  This shifted-and-jammed
+| value is stored at the location pointed to by 'zPtr'.  Each of 'aPtr' and
+| 'zPtr' points to an array of four 64-bit elements that concatenate in the
+| platform's normal endian order to form a 256-bit integer.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist'
+| is greater than 256, the stored result will be either 0 or 1, depending on
+| whether the original 256 bits are all zeros.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shiftRightJam256M(
+     const uint64_t *aPtr, uint_fast32_t dist, uint64_t *zPtr );
+#endif
+
+#ifndef softfloat_add128
+/*----------------------------------------------------------------------------
+| Returns the sum of the 128-bit integer formed by concatenating 'a64' and
+| 'a0' and the 128-bit integer formed by concatenating 'b64' and 'b0'.  The
+| addition is modulo 2^128, so any carry out is lost.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_add128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+    struct uint128 z;
+    z.v0 = a0 + b0;
+    z.v64 = a64 + b64 + (z.v0 < a0);
+    return z;
+}
+#else
+struct uint128
+ softfloat_add128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_add256M
+/*----------------------------------------------------------------------------
+| Adds the two 256-bit integers pointed to by 'aPtr' and 'bPtr'.  The addition
+| is modulo 2^256, so any carry out is lost.  The sum is stored at the
+| location pointed to by 'zPtr'.  Each of 'aPtr', 'bPtr', and 'zPtr' points to
+| an array of four 64-bit elements that concatenate in the platform's normal
+| endian order to form a 256-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_add256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr );
+#endif
+
+#ifndef softfloat_sub128
+/*----------------------------------------------------------------------------
+| Returns the difference of the 128-bit integer formed by concatenating 'a64'
+| and 'a0' and the 128-bit integer formed by concatenating 'b64' and 'b0'.
+| The subtraction is modulo 2^128, so any borrow out (carry out) is lost.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+struct uint128
+ softfloat_sub128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+    struct uint128 z;
+    z.v0 = a0 - b0;
+    z.v64 = a64 - b64;
+    z.v64 -= (a0 < b0);
+    return z;
+}
+#else
+struct uint128
+ softfloat_sub128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 );
+#endif
+#endif
+
+#ifndef softfloat_sub256M
+/*----------------------------------------------------------------------------
+| Subtracts the 256-bit integer pointed to by 'bPtr' from the 256-bit integer
+| pointed to by 'aPtr'.  The addition is modulo 2^256, so any borrow out
+| (carry out) is lost.  The difference is stored at the location pointed to
+| by 'zPtr'.  Each of 'aPtr', 'bPtr', and 'zPtr' points to an array of four
+| 64-bit elements that concatenate in the platform's normal endian order to
+| form a 256-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_sub256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr );
+#endif
+
+#ifndef softfloat_mul64ByShifted32To128
+/*----------------------------------------------------------------------------
+| Returns the 128-bit product of 'a', 'b', and 2^32.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (3 <= INLINE_LEVEL)
+INLINE struct uint128 softfloat_mul64ByShifted32To128( uint64_t a, uint32_t b )
+{
+    uint_fast64_t mid;
+    struct uint128 z;
+    mid = (uint_fast64_t) (uint32_t) a * b;
+    z.v0 = mid<<32;
+    z.v64 = (uint_fast64_t) (uint32_t) (a>>32) * b + (mid>>32);
+    return z;
+}
+#else
+struct uint128 softfloat_mul64ByShifted32To128( uint64_t a, uint32_t b );
+#endif
+#endif
+
+#ifndef softfloat_mul64To128
+/*----------------------------------------------------------------------------
+| Returns the 128-bit product of 'a' and 'b'.
+*----------------------------------------------------------------------------*/
+struct uint128 softfloat_mul64To128( uint64_t a, uint64_t b );
+#endif
+
+#ifndef softfloat_mul128By32
+/*----------------------------------------------------------------------------
+| Returns the product of the 128-bit integer formed by concatenating 'a64' and
+| 'a0', multiplied by 'b'.  The multiplication is modulo 2^128; any overflow
+| bits are discarded.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (4 <= INLINE_LEVEL)
+INLINE
+struct uint128 softfloat_mul128By32( uint64_t a64, uint64_t a0, uint32_t b )
+{
+    struct uint128 z;
+    uint_fast64_t mid;
+    uint_fast32_t carry;
+    z.v0 = a0 * b;
+    mid = (uint_fast64_t) (uint32_t) (a0>>32) * b;
+    carry = (uint32_t) ((uint_fast32_t) (z.v0>>32) - (uint_fast32_t) mid);
+    z.v64 = a64 * b + (uint_fast32_t) ((mid + carry)>>32);
+    return z;
+}
+#else
+struct uint128 softfloat_mul128By32( uint64_t a64, uint64_t a0, uint32_t b );
+#endif
+#endif
+
+#ifndef softfloat_mul128To256M
+/*----------------------------------------------------------------------------
+| Multiplies the 128-bit unsigned integer formed by concatenating 'a64' and
+| 'a0' by the 128-bit unsigned integer formed by concatenating 'b64' and
+| 'b0'.  The 256-bit product is stored at the location pointed to by 'zPtr'.
+| Argument 'zPtr' points to an array of four 64-bit elements that concatenate
+| in the platform's normal endian order to form a 256-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_mul128To256M(
+     uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0, uint64_t *zPtr );
+#endif
+
+#else
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when 'SOFTFLOAT_FAST_INT64' is not
+| defined.
+*----------------------------------------------------------------------------*/
+
+#ifndef softfloat_compare96M
+/*----------------------------------------------------------------------------
+| Compares the two 96-bit unsigned integers pointed to by 'aPtr' and 'bPtr'.
+| Returns -1 if the first integer (A) is less than the second (B); returns 0
+| if the two integers are equal; and returns +1 if the first integer (A)
+| is greater than the second (B).  (The result is thus the signum of A - B.)
+| Each of 'aPtr' and 'bPtr' points to an array of three 32-bit elements that
+| concatenate in the platform's normal endian order to form a 96-bit integer.
+*----------------------------------------------------------------------------*/
+int_fast8_t softfloat_compare96M( const uint32_t *aPtr, const uint32_t *bPtr );
+#endif
+
+#ifndef softfloat_compare128M
+/*----------------------------------------------------------------------------
+| Compares the two 128-bit unsigned integers pointed to by 'aPtr' and 'bPtr'.
+| Returns -1 if the first integer (A) is less than the second (B); returns 0
+| if the two integers are equal; and returns +1 if the first integer (A)
+| is greater than the second (B).  (The result is thus the signum of A - B.)
+| Each of 'aPtr' and 'bPtr' points to an array of four 32-bit elements that
+| concatenate in the platform's normal endian order to form a 128-bit integer.
+*----------------------------------------------------------------------------*/
+int_fast8_t
+ softfloat_compare128M( const uint32_t *aPtr, const uint32_t *bPtr );
+#endif
+
+#ifndef softfloat_shortShiftLeft64To96M
+/*----------------------------------------------------------------------------
+| Extends 'a' to 96 bits and shifts the value left by the number of bits given
+| in 'dist', which must be in the range 1 to 31.  The result is stored at the
+| location pointed to by 'zPtr'.  Argument 'zPtr' points to an array of three
+| 32-bit elements that concatenate in the platform's normal endian order to
+| form a 96-bit integer.
+*----------------------------------------------------------------------------*/
+#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
+INLINE
+void
+ softfloat_shortShiftLeft64To96M(
+     uint64_t a, uint_fast8_t dist, uint32_t *zPtr )
+{
+    zPtr[indexWord( 3, 0 )] = (uint32_t) a<<dist;
+    a >>= 32 - dist;
+    zPtr[indexWord( 3, 2 )] = a>>32;
+    zPtr[indexWord( 3, 1 )] = a;
+}
+#else
+void
+ softfloat_shortShiftLeft64To96M(
+     uint64_t a, uint_fast8_t dist, uint32_t *zPtr );
+#endif
+#endif
+
+#ifndef softfloat_shortShiftLeftM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' left by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must be in the range 1 to 31.  Any nonzero bits shifted off are lost.  The
+| shifted N-bit result is stored at the location pointed to by 'zPtr'.  Each
+| of 'aPtr' and 'zPtr' points to a 'size_words'-long array of 32-bit elements
+| that concatenate in the platform's normal endian order to form an N-bit
+| integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shortShiftLeftM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shortShiftLeft96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftLeftM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftLeft96M( aPtr, dist, zPtr ) softfloat_shortShiftLeftM( 3, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftLeft128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftLeftM' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftLeft128M( aPtr, dist, zPtr ) softfloat_shortShiftLeftM( 4, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftLeft160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftLeftM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftLeft160M( aPtr, dist, zPtr ) softfloat_shortShiftLeftM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftLeftM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' left by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must not be zero.  Any nonzero bits shifted off are lost.  The shifted
+| N-bit result is stored at the location pointed to by 'zPtr'.  Each of 'aPtr'
+| and 'zPtr' points to a 'size_words'-long array of 32-bit elements that
+| concatenate in the platform's normal endian order to form an N-bit integer.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than N, the stored result will be 0.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shiftLeftM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint32_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shiftLeft96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftLeftM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftLeft96M( aPtr, dist, zPtr ) softfloat_shiftLeftM( 3, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftLeft128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftLeftM' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftLeft128M( aPtr, dist, zPtr ) softfloat_shiftLeftM( 4, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftLeft160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftLeftM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftLeft160M( aPtr, dist, zPtr ) softfloat_shiftLeftM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftRightM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must be in the range 1 to 31.  Any nonzero bits shifted off are lost.  The
+| shifted N-bit result is stored at the location pointed to by 'zPtr'.  Each
+| of 'aPtr' and 'zPtr' points to a 'size_words'-long array of 32-bit elements
+| that concatenate in the platform's normal endian order to form an N-bit
+| integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shortShiftRightM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shortShiftRight128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftRightM' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftRight128M( aPtr, dist, zPtr ) softfloat_shortShiftRightM( 4, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftRight160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftRightM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftRight160M( aPtr, dist, zPtr ) softfloat_shortShiftRightM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shortShiftRightJamM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must be in the range 1 to 31.  If any nonzero bits are shifted off, they are
+| "jammed" into the least-significant bit of the shifted value by setting the
+| least-significant bit to 1.  This shifted-and-jammed N-bit result is stored
+| at the location pointed to by 'zPtr'.  Each of 'aPtr' and 'zPtr' points
+| to a 'size_words'-long array of 32-bit elements that concatenate in the
+| platform's normal endian order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shortShiftRightJamM(
+     uint_fast8_t, const uint32_t *, uint_fast8_t, uint32_t * );
+#endif
+
+#ifndef softfloat_shortShiftRightJam160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shortShiftRightJamM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shortShiftRightJam160M( aPtr, dist, zPtr ) softfloat_shortShiftRightJamM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftRightM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must not be zero.  Any nonzero bits shifted off are lost.  The shifted
+| N-bit result is stored at the location pointed to by 'zPtr'.  Each of 'aPtr'
+| and 'zPtr' points to a 'size_words'-long array of 32-bit elements that
+| concatenate in the platform's normal endian order to form an N-bit integer.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
+| greater than N, the stored result will be 0.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shiftRightM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint32_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shiftRight96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftRightM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftRight96M( aPtr, dist, zPtr ) softfloat_shiftRightM( 3, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftRightJamM
+/*----------------------------------------------------------------------------
+| Shifts the N-bit unsigned integer pointed to by 'aPtr' right by the number
+| of bits given in 'dist', where N = 'size_words' * 32.  The value of 'dist'
+| must not be zero.  If any nonzero bits are shifted off, they are "jammed"
+| into the least-significant bit of the shifted value by setting the least-
+| significant bit to 1.  This shifted-and-jammed N-bit result is stored
+| at the location pointed to by 'zPtr'.  Each of 'aPtr' and 'zPtr' points
+| to a 'size_words'-long array of 32-bit elements that concatenate in the
+| platform's normal endian order to form an N-bit integer.
+|   The value of 'dist' can be arbitrarily large.  In particular, if 'dist'
+| is greater than N, the stored result will be either 0 or 1, depending on
+| whether the original N bits are all zeros.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_shiftRightJamM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint32_t dist,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_shiftRightJam96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftRightJamM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftRightJam96M( aPtr, dist, zPtr ) softfloat_shiftRightJamM( 3, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftRightJam128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftRightJamM' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftRightJam128M( aPtr, dist, zPtr ) softfloat_shiftRightJamM( 4, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_shiftRightJam160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_shiftRightJamM' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_shiftRightJam160M( aPtr, dist, zPtr ) softfloat_shiftRightJamM( 5, aPtr, dist, zPtr )
+#endif
+
+#ifndef softfloat_addM
+/*----------------------------------------------------------------------------
+| Adds the two N-bit integers pointed to by 'aPtr' and 'bPtr', where N =
+| 'size_words' * 32.  The addition is modulo 2^N, so any carry out is lost.
+| The N-bit sum is stored at the location pointed to by 'zPtr'.  Each of
+| 'aPtr', 'bPtr', and 'zPtr' points to a 'size_words'-long array of 32-bit
+| elements that concatenate in the platform's normal endian order to form an
+| N-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_addM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_add96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addM' with 'size_words'
+| = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_add96M( aPtr, bPtr, zPtr ) softfloat_addM( 3, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_add128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addM' with 'size_words'
+| = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_add128M( aPtr, bPtr, zPtr ) softfloat_addM( 4, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_add160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addM' with 'size_words'
+| = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_add160M( aPtr, bPtr, zPtr ) softfloat_addM( 5, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_addCarryM
+/*----------------------------------------------------------------------------
+| Adds the two N-bit unsigned integers pointed to by 'aPtr' and 'bPtr', where
+| N = 'size_words' * 32, plus 'carry', which must be either 0 or 1.  The N-bit
+| sum (modulo 2^N) is stored at the location pointed to by 'zPtr', and any
+| carry out is returned as the result.  Each of 'aPtr', 'bPtr', and 'zPtr'
+| points to a 'size_words'-long array of 32-bit elements that concatenate in
+| the platform's normal endian order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+uint_fast8_t
+ softfloat_addCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_addComplCarryM
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addCarryM', except that
+| the value of the unsigned integer pointed to by 'bPtr' is bit-wise completed
+| before the addition.
+*----------------------------------------------------------------------------*/
+uint_fast8_t
+ softfloat_addComplCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_addComplCarry96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_addComplCarryM' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_addComplCarry96M( aPtr, bPtr, carry, zPtr ) softfloat_addComplCarryM( 3, aPtr, bPtr, carry, zPtr )
+#endif
+
+#ifndef softfloat_negXM
+/*----------------------------------------------------------------------------
+| Replaces the N-bit unsigned integer pointed to by 'zPtr' by the
+| 2s-complement of itself, where N = 'size_words' * 32.  Argument 'zPtr'
+| points to a 'size_words'-long array of 32-bit elements that concatenate in
+| the platform's normal endian order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+void softfloat_negXM( uint_fast8_t size_words, uint32_t *zPtr );
+#endif
+
+#ifndef softfloat_negX96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_negXM' with 'size_words'
+| = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_negX96M( zPtr ) softfloat_negXM( 3, zPtr )
+#endif
+
+#ifndef softfloat_negX128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_negXM' with 'size_words'
+| = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_negX128M( zPtr ) softfloat_negXM( 4, zPtr )
+#endif
+
+#ifndef softfloat_negX160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_negXM' with 'size_words'
+| = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_negX160M( zPtr ) softfloat_negXM( 5, zPtr )
+#endif
+
+#ifndef softfloat_negX256M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_negXM' with 'size_words'
+| = 8 (N = 256).
+*----------------------------------------------------------------------------*/
+#define softfloat_negX256M( zPtr ) softfloat_negXM( 8, zPtr )
+#endif
+
+#ifndef softfloat_sub1XM
+/*----------------------------------------------------------------------------
+| Subtracts 1 from the N-bit integer pointed to by 'zPtr', where N =
+| 'size_words' * 32.  The subtraction is modulo 2^N, so any borrow out (carry
+| out) is lost.  Argument 'zPtr' points to a 'size_words'-long array of 32-bit
+| elements that concatenate in the platform's normal endian order to form an
+| N-bit integer.
+*----------------------------------------------------------------------------*/
+void softfloat_sub1XM( uint_fast8_t size_words, uint32_t *zPtr );
+#endif
+
+#ifndef softfloat_sub1X96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_sub1XM' with 'size_words'
+| = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub1X96M( zPtr ) softfloat_sub1XM( 3, zPtr )
+#endif
+
+#ifndef softfloat_sub1X160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_sub1XM' with 'size_words'
+| = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub1X160M( zPtr ) softfloat_sub1XM( 5, zPtr )
+#endif
+
+#ifndef softfloat_subM
+/*----------------------------------------------------------------------------
+| Subtracts the two N-bit integers pointed to by 'aPtr' and 'bPtr', where N =
+| 'size_words' * 32.  The subtraction is modulo 2^N, so any borrow out (carry
+| out) is lost.  The N-bit difference is stored at the location pointed to by
+| 'zPtr'.  Each of 'aPtr', 'bPtr', and 'zPtr' points to a 'size_words'-long
+| array of 32-bit elements that concatenate in the platform's normal endian
+| order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_subM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_sub96M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_subM' with 'size_words'
+| = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub96M( aPtr, bPtr, zPtr ) softfloat_subM( 3, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_sub128M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_subM' with 'size_words'
+| = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub128M( aPtr, bPtr, zPtr ) softfloat_subM( 4, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_sub160M
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_subM' with 'size_words'
+| = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_sub160M( aPtr, bPtr, zPtr ) softfloat_subM( 5, aPtr, bPtr, zPtr )
+#endif
+
+#ifndef softfloat_mul64To128M
+/*----------------------------------------------------------------------------
+| Multiplies 'a' and 'b' and stores the 128-bit product at the location
+| pointed to by 'zPtr'.  Argument 'zPtr' points to an array of four 32-bit
+| elements that concatenate in the platform's normal endian order to form a
+| 128-bit integer.
+*----------------------------------------------------------------------------*/
+void softfloat_mul64To128M( uint64_t a, uint64_t b, uint32_t *zPtr );
+#endif
+
+#ifndef softfloat_mul128MTo256M
+/*----------------------------------------------------------------------------
+| Multiplies the two 128-bit unsigned integers pointed to by 'aPtr' and
+| 'bPtr', and stores the 256-bit product at the location pointed to by 'zPtr'.
+| Each of 'aPtr' and 'bPtr' points to an array of four 32-bit elements that
+| concatenate in the platform's normal endian order to form a 128-bit integer.
+| Argument 'zPtr' points to an array of eight 32-bit elements that concatenate
+| to form a 256-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_mul128MTo256M(
+     const uint32_t *aPtr, const uint32_t *bPtr, uint32_t *zPtr );
+#endif
+
+#ifndef softfloat_remStepMBy32
+/*----------------------------------------------------------------------------
+| Performs a "remainder reduction step" as follows:  Arguments 'remPtr' and
+| 'bPtr' both point to N-bit unsigned integers, where N = 'size_words' * 32.
+| Defining R and B as the values of those integers, the expression (R<<'dist')
+| - B * q is computed modulo 2^N, and the N-bit result is stored at the
+| location pointed to by 'zPtr'.  Each of 'remPtr', 'bPtr', and 'zPtr' points
+| to a 'size_words'-long array of 32-bit elements that concatenate in the
+| platform's normal endian order to form an N-bit integer.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_remStepMBy32(
+     uint_fast8_t size_words,
+     const uint32_t *remPtr,
+     uint_fast8_t dist,
+     const uint32_t *bPtr,
+     uint32_t q,
+     uint32_t *zPtr
+ );
+#endif
+
+#ifndef softfloat_remStep96MBy32
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_remStepMBy32' with
+| 'size_words' = 3 (N = 96).
+*----------------------------------------------------------------------------*/
+#define softfloat_remStep96MBy32( remPtr, dist, bPtr, q, zPtr ) softfloat_remStepMBy32( 3, remPtr, dist, bPtr, q, zPtr )
+#endif
+
+#ifndef softfloat_remStep128MBy32
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_remStepMBy32' with
+| 'size_words' = 4 (N = 128).
+*----------------------------------------------------------------------------*/
+#define softfloat_remStep128MBy32( remPtr, dist, bPtr, q, zPtr ) softfloat_remStepMBy32( 4, remPtr, dist, bPtr, q, zPtr )
+#endif
+
+#ifndef softfloat_remStep160MBy32
+/*----------------------------------------------------------------------------
+| This function or macro is the same as 'softfloat_remStepMBy32' with
+| 'size_words' = 5 (N = 160).
+*----------------------------------------------------------------------------*/
+#define softfloat_remStep160MBy32( remPtr, dist, bPtr, q, zPtr ) softfloat_remStepMBy32( 5, remPtr, dist, bPtr, q, zPtr )
+#endif
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_add128.c b/arch/riscv/kernel/soft_vector/softfloat/s_add128.c
new file mode 100644
index 000000000000..216309912e16
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_add128.c
@@ -0,0 +1,55 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_add128
+
+struct uint128
+ softfloat_add128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+    struct uint128 z;
+
+    z.v0 = a0 + b0;
+    z.v64 = a64 + b64 + (z.v0 < a0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_add256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_add256M.c
new file mode 100644
index 000000000000..6dfff2fe99f8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_add256M.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_add256M
+
+void
+ softfloat_add256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr )
+{
+    unsigned int index;
+    uint_fast8_t carry;
+    uint64_t wordA, wordZ;
+
+    index = indexWordLo( 4 );
+    carry = 0;
+    for (;;) {
+        wordA = aPtr[index];
+        wordZ = wordA + bPtr[index] + carry;
+        zPtr[index] = wordZ;
+        if ( index == indexWordHi( 4 ) ) break;
+        if ( wordZ != wordA ) carry = (wordZ < wordA);
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addCarryM.c b/arch/riscv/kernel/soft_vector/softfloat/s_addCarryM.c
new file mode 100644
index 000000000000..caa595254112
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addCarryM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_addCarryM
+
+uint_fast8_t
+ softfloat_addCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA, wordZ;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    for (;;) {
+        wordA = aPtr[index];
+        wordZ = wordA + bPtr[index] + carry;
+        zPtr[index] = wordZ;
+        if ( wordZ != wordA ) carry = (wordZ < wordA);
+        if ( index == lastIndex ) break;
+        index += wordIncr;
+    }
+    return carry;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addComplCarryM.c b/arch/riscv/kernel/soft_vector/softfloat/s_addComplCarryM.c
new file mode 100644
index 000000000000..6f350ca2a973
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addComplCarryM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_addComplCarryM
+
+uint_fast8_t
+ softfloat_addComplCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA, wordZ;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    for (;;) {
+        wordA = aPtr[index];
+        wordZ = wordA + ~bPtr[index] + carry;
+        zPtr[index] = wordZ;
+        if ( wordZ != wordA ) carry = (wordZ < wordA);
+        if ( index == lastIndex ) break;
+        index += wordIncr;
+    }
+    return carry;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addM.c b/arch/riscv/kernel/soft_vector/softfloat/s_addM.c
new file mode 100644
index 000000000000..e114815e87a5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_addM
+
+void
+ softfloat_addM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint_fast8_t carry;
+    uint32_t wordA, wordZ;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    carry = 0;
+    for (;;) {
+        wordA = aPtr[index];
+        wordZ = wordA + bPtr[index] + carry;
+        zPtr[index] = wordZ;
+        if ( index == lastIndex ) break;
+        if ( wordZ != wordA ) carry = (wordZ < wordA);
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF128.c
new file mode 100644
index 000000000000..273753b1accc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF128.c
@@ -0,0 +1,154 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+
+float128_t
+ softfloat_addMagsF128(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0,
+     bool signZ
+ )
+{
+    int_fast32_t expA;
+    struct uint128 sigA;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    int_fast32_t expDiff;
+    struct uint128 uiZ, sigZ;
+    int_fast32_t expZ;
+    uint_fast64_t sigZExtra;
+    struct uint128_extra sig128Extra;
+    union ui128_f128 uZ;
+
+    expA = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    expB = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        if ( expA == 0x7FFF ) {
+            if ( sigA.v64 | sigA.v0 | sigB.v64 | sigB.v0 ) goto propagateNaN;
+            uiZ.v64 = uiA64;
+            uiZ.v0  = uiA0;
+            goto uiZ;
+        }
+        sigZ = softfloat_add128( sigA.v64, sigA.v0, sigB.v64, sigB.v0 );
+        if ( ! expA ) {
+            uiZ.v64 = packToF128UI64( signZ, 0, sigZ.v64 );
+            uiZ.v0  = sigZ.v0;
+            goto uiZ;
+        }
+        expZ = expA;
+        sigZ.v64 |= UINT64_C( 0x0002000000000000 );
+        sigZExtra = 0;
+        goto shiftRight1;
+    }
+    if ( expDiff < 0 ) {
+        if ( expB == 0x7FFF ) {
+            if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+            uiZ.v64 = packToF128UI64( signZ, 0x7FFF, 0 );
+            uiZ.v0  = 0;
+            goto uiZ;
+        }
+        expZ = expB;
+        if ( expA ) {
+            sigA.v64 |= UINT64_C( 0x0001000000000000 );
+        } else {
+            ++expDiff;
+            sigZExtra = 0;
+            if ( ! expDiff ) goto newlyAligned;
+        }
+        sig128Extra =
+            softfloat_shiftRightJam128Extra( sigA.v64, sigA.v0, 0, -expDiff );
+        sigA = sig128Extra.v;
+        sigZExtra = sig128Extra.extra;
+    } else {
+        if ( expA == 0x7FFF ) {
+            if ( sigA.v64 | sigA.v0 ) goto propagateNaN;
+            uiZ.v64 = uiA64;
+            uiZ.v0  = uiA0;
+            goto uiZ;
+        }
+        expZ = expA;
+        if ( expB ) {
+            sigB.v64 |= UINT64_C( 0x0001000000000000 );
+        } else {
+            --expDiff;
+            sigZExtra = 0;
+            if ( ! expDiff ) goto newlyAligned;
+        }
+        sig128Extra =
+            softfloat_shiftRightJam128Extra( sigB.v64, sigB.v0, 0, expDiff );
+        sigB = sig128Extra.v;
+        sigZExtra = sig128Extra.extra;
+    }
+ newlyAligned:
+    sigZ =
+        softfloat_add128(
+            sigA.v64 | UINT64_C( 0x0001000000000000 ),
+            sigA.v0,
+            sigB.v64,
+            sigB.v0
+        );
+    --expZ;
+    if ( sigZ.v64 < UINT64_C( 0x0002000000000000 ) ) goto roundAndPack;
+    ++expZ;
+ shiftRight1:
+    sig128Extra =
+        softfloat_shortShiftRightJam128Extra(
+            sigZ.v64, sigZ.v0, sigZExtra, 1 );
+    sigZ = sig128Extra.v;
+    sigZExtra = sig128Extra.extra;
+ roundAndPack:
+    return
+        softfloat_roundPackToF128( signZ, expZ, sigZ.v64, sigZ.v0, sigZExtra );
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF16.c
new file mode 100644
index 000000000000..58d42f5a0556
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF16.c
@@ -0,0 +1,183 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t softfloat_addMagsF16( uint_fast16_t uiA, uint_fast16_t uiB )
+{
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    int_fast8_t expDiff;
+    uint_fast16_t uiZ;
+    bool signZ;
+    int_fast8_t expZ;
+    uint_fast16_t sigZ;
+    uint_fast16_t sigX, sigY;
+    int_fast8_t shiftDist;
+    uint_fast32_t sig32Z;
+    int_fast8_t roundingMode;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF16UI( uiA );
+    sigA = fracF16UI( uiA );
+    expB = expF16UI( uiB );
+    sigB = fracF16UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( ! expA ) {
+            uiZ = uiA + sigB;
+            goto uiZ;
+        }
+        if ( expA == 0x1F ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            uiZ = uiA;
+            goto uiZ;
+        }
+        signZ = signF16UI( uiA );
+        expZ = expA;
+        sigZ = 0x0800 + sigA + sigB;
+        if ( ! (sigZ & 1) && (expZ < 0x1E) ) {
+            sigZ >>= 1;
+            goto pack;
+        }
+        sigZ <<= 3;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        signZ = signF16UI( uiA );
+        if ( expDiff < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            if ( expB == 0x1F ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF16UI( signZ, 0x1F, 0 );
+                goto uiZ;
+            }
+            if ( expDiff <= -13 ) {
+                uiZ = packToF16UI( signZ, expB, sigB );
+                if ( expA | sigA ) goto addEpsilon;
+                goto uiZ;
+            }
+            expZ = expB;
+            sigX = sigB | 0x0400;
+            sigY = sigA + (expA ? 0x0400 : sigA);
+            shiftDist = 19 + expDiff;
+        } else {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            uiZ = uiA;
+            if ( expA == 0x1F ) {
+                if ( sigA ) goto propagateNaN;
+                goto uiZ;
+            }
+            if ( 13 <= expDiff ) {
+                if ( expB | sigB ) goto addEpsilon;
+                goto uiZ;
+            }
+            expZ = expA;
+            sigX = sigA | 0x0400;
+            sigY = sigB + (expB ? 0x0400 : sigB);
+            shiftDist = 19 - expDiff;
+        }
+        sig32Z =
+            ((uint_fast32_t) sigX<<19) + ((uint_fast32_t) sigY<<shiftDist);
+        if ( sig32Z < 0x40000000 ) {
+            --expZ;
+            sig32Z <<= 1;
+        }
+        sigZ = sig32Z>>16;
+        if ( sig32Z & 0xFFFF ) {
+            sigZ |= 1;
+        } else {
+            if ( ! (sigZ & 0xF) && (expZ < 0x1E) ) {
+                sigZ >>= 4;
+                goto pack;
+            }
+        }
+    }
+    return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ addEpsilon:
+    roundingMode = softfloat_roundingMode;
+    if ( roundingMode != softfloat_round_near_even ) {
+        if (
+            roundingMode
+                == (signF16UI( uiZ ) ? softfloat_round_min
+                        : softfloat_round_max)
+        ) {
+            ++uiZ;
+            if ( (uint16_t) (uiZ<<1) == 0xF800 ) {
+                softfloat_raiseFlags(
+                    softfloat_flag_overflow | softfloat_flag_inexact );
+            }
+        }
+#ifdef SOFTFLOAT_ROUND_ODD
+        else if ( roundingMode == softfloat_round_odd ) {
+            uiZ |= 1;
+        }
+#endif
+    }
+    softfloat_exceptionFlags |= softfloat_flag_inexact;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ pack:
+    uiZ = packToF16UI( signZ, expZ, sigZ );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF32.c
new file mode 100644
index 000000000000..a96d0001dbd5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF32.c
@@ -0,0 +1,126 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+
+float32_t softfloat_addMagsF32( uint_fast32_t uiA, uint_fast32_t uiB )
+{
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    int_fast16_t expDiff;
+    uint_fast32_t uiZ;
+    bool signZ;
+    int_fast16_t expZ;
+    uint_fast32_t sigZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF32UI( uiA );
+    sigA = fracF32UI( uiA );
+    expB = expF32UI( uiB );
+    sigB = fracF32UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( ! expA ) {
+            uiZ = uiA + sigB;
+            goto uiZ;
+        }
+        if ( expA == 0xFF ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            uiZ = uiA;
+            goto uiZ;
+        }
+        signZ = signF32UI( uiA );
+        expZ = expA;
+        sigZ = 0x01000000 + sigA + sigB;
+        if ( ! (sigZ & 1) && (expZ < 0xFE) ) {
+            uiZ = packToF32UI( signZ, expZ, sigZ>>1 );
+            goto uiZ;
+        }
+        sigZ <<= 6;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        signZ = signF32UI( uiA );
+        sigA <<= 6;
+        sigB <<= 6;
+        if ( expDiff < 0 ) {
+            if ( expB == 0xFF ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF32UI( signZ, 0xFF, 0 );
+                goto uiZ;
+            }
+            expZ = expB;
+            sigA += expA ? 0x20000000 : sigA;
+            sigA = softfloat_shiftRightJam32( sigA, -expDiff );
+        } else {
+            if ( expA == 0xFF ) {
+                if ( sigA ) goto propagateNaN;
+                uiZ = uiA;
+                goto uiZ;
+            }
+            expZ = expA;
+            sigB += expB ? 0x20000000 : sigB;
+            sigB = softfloat_shiftRightJam32( sigB, expDiff );
+        }
+        sigZ = 0x20000000 + sigA + sigB;
+        if ( sigZ < 0x40000000 ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    }
+    return softfloat_roundPackToF32( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF64.c
new file mode 100644
index 000000000000..f3ade9dd71bd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_addMagsF64.c
@@ -0,0 +1,128 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+
+float64_t
+ softfloat_addMagsF64( uint_fast64_t uiA, uint_fast64_t uiB, bool signZ )
+{
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    int_fast16_t expDiff;
+    uint_fast64_t uiZ;
+    int_fast16_t expZ;
+    uint_fast64_t sigZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF64UI( uiA );
+    sigA = fracF64UI( uiA );
+    expB = expF64UI( uiB );
+    sigB = fracF64UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( ! expA ) {
+            uiZ = uiA + sigB;
+            goto uiZ;
+        }
+        if ( expA == 0x7FF ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            uiZ = uiA;
+            goto uiZ;
+        }
+        expZ = expA;
+        sigZ = UINT64_C( 0x0020000000000000 ) + sigA + sigB;
+        sigZ <<= 9;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sigA <<= 9;
+        sigB <<= 9;
+        if ( expDiff < 0 ) {
+            if ( expB == 0x7FF ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF64UI( signZ, 0x7FF, 0 );
+                goto uiZ;
+            }
+            expZ = expB;
+            if ( expA ) {
+                sigA += UINT64_C( 0x2000000000000000 );
+            } else {
+                sigA <<= 1;
+            }
+            sigA = softfloat_shiftRightJam64( sigA, -expDiff );
+        } else {
+            if ( expA == 0x7FF ) {
+                if ( sigA ) goto propagateNaN;
+                uiZ = uiA;
+                goto uiZ;
+            }
+            expZ = expA;
+            if ( expB ) {
+                sigB += UINT64_C( 0x2000000000000000 );
+            } else {
+                sigB <<= 1;
+            }
+            sigB = softfloat_shiftRightJam64( sigB, expDiff );
+        }
+        sigZ = UINT64_C( 0x2000000000000000 ) + sigA + sigB;
+        if ( sigZ < UINT64_C( 0x4000000000000000 ) ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    }
+    return softfloat_roundPackToF64( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip32_1.c b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip32_1.c
new file mode 100644
index 000000000000..913307111c39
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip32_1.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_approxRecip32_1
+
+extern const uint16_t softfloat_approxRecip_1k0s[16];
+extern const uint16_t softfloat_approxRecip_1k1s[16];
+
+uint32_t softfloat_approxRecip32_1( uint32_t a )
+{
+    int index;
+    uint16_t eps, r0;
+    uint32_t sigma0;
+    uint_fast32_t r;
+    uint32_t sqrSigma0;
+
+    index = a>>27 & 0xF;
+    eps = (uint16_t) (a>>11);
+    r0 = softfloat_approxRecip_1k0s[index]
+             - ((softfloat_approxRecip_1k1s[index] * (uint_fast32_t) eps)>>20);
+    sigma0 = ~(uint_fast32_t) ((r0 * (uint_fast64_t) a)>>7);
+    r = ((uint_fast32_t) r0<<16) + ((r0 * (uint_fast64_t) sigma0)>>24);
+    sqrSigma0 = ((uint_fast64_t) sigma0 * sigma0)>>32;
+    r += ((uint32_t) r * (uint_fast64_t) sqrSigma0)>>48;
+    return r;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt32_1.c b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt32_1.c
new file mode 100644
index 000000000000..c95d4ef81531
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt32_1.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_approxRecipSqrt32_1
+
+extern const uint16_t softfloat_approxRecipSqrt_1k0s[];
+extern const uint16_t softfloat_approxRecipSqrt_1k1s[];
+
+uint32_t softfloat_approxRecipSqrt32_1( unsigned int oddExpA, uint32_t a )
+{
+    int index;
+    uint16_t eps, r0;
+    uint_fast32_t ESqrR0;
+    uint32_t sigma0;
+    uint_fast32_t r;
+    uint32_t sqrSigma0;
+
+    index = (a>>27 & 0xE) + oddExpA;
+    eps = (uint16_t) (a>>12);
+    r0 = softfloat_approxRecipSqrt_1k0s[index]
+             - ((softfloat_approxRecipSqrt_1k1s[index] * (uint_fast32_t) eps)
+                    >>20);
+    ESqrR0 = (uint_fast32_t) r0 * r0;
+    if ( ! oddExpA ) ESqrR0 <<= 1;
+    sigma0 = ~(uint_fast32_t) (((uint32_t) ESqrR0 * (uint_fast64_t) a)>>23);
+    r = ((uint_fast32_t) r0<<16) + ((r0 * (uint_fast64_t) sigma0)>>25);
+    sqrSigma0 = ((uint_fast64_t) sigma0 * sigma0)>>32;
+    r += ((uint32_t) ((r>>1) + (r>>3) - ((uint_fast32_t) r0<<14))
+              * (uint_fast64_t) sqrSigma0)
+             >>48;
+    if ( ! (r & 0x80000000) ) r = 0x80000000;
+    return r;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt_1Ks.c b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt_1Ks.c
new file mode 100644
index 000000000000..6923b42e1b45
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecipSqrt_1Ks.c
@@ -0,0 +1,49 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitives.h"
+
+const uint16_t softfloat_approxRecipSqrt_1k0s[16] = {
+    0xB4C9, 0xFFAB, 0xAA7D, 0xF11C, 0xA1C5, 0xE4C7, 0x9A43, 0xDA29,
+    0x93B5, 0xD0E5, 0x8DED, 0xC8B7, 0x88C6, 0xC16D, 0x8424, 0xBAE1
+};
+const uint16_t softfloat_approxRecipSqrt_1k1s[16] = {
+    0xA5A5, 0xEA42, 0x8C21, 0xC62D, 0x788F, 0xAA7F, 0x6928, 0x94B6,
+    0x5CC7, 0x8335, 0x52A6, 0x74E2, 0x4A3E, 0x68FE, 0x432B, 0x5EFD
+};
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip_1Ks.c b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip_1Ks.c
new file mode 100644
index 000000000000..e296bd44b7d5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_approxRecip_1Ks.c
@@ -0,0 +1,49 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitives.h"
+
+const uint16_t softfloat_approxRecip_1k0s[16] = {
+    0xFFC4, 0xF0BE, 0xE363, 0xD76F, 0xCCAD, 0xC2F0, 0xBA16, 0xB201,
+    0xAA97, 0xA3C6, 0x9D7A, 0x97A6, 0x923C, 0x8D32, 0x887E, 0x8417
+};
+const uint16_t softfloat_approxRecip_1k1s[16] = {
+    0xF0F1, 0xD62C, 0xBFA1, 0xAC77, 0x9C0A, 0x8DDB, 0x8185, 0x76BA,
+    0x6D3B, 0x64D4, 0x5D5C, 0x56B1, 0x50B6, 0x4B55, 0x4679, 0x4211
+};
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF128UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF128UI.c
new file mode 100644
index 000000000000..9b97f3437dbe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF128UI.c
@@ -0,0 +1,56 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#define softfloat_commonNaNToF128UI softfloat_commonNaNToF128UI
+#include "specialize.h"
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 128-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+struct uint128 softfloat_commonNaNToF128UI( const struct commonNaN *aPtr )
+{
+    struct uint128 uiZ;
+
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+    return uiZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF16UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF16UI.c
new file mode 100644
index 000000000000..861b26965893
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF16UI.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF32UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF32UI.c
new file mode 100644
index 000000000000..861b26965893
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF32UI.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF64UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF64UI.c
new file mode 100644
index 000000000000..861b26965893
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_commonNaNToF64UI.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_compare128M.c b/arch/riscv/kernel/soft_vector/softfloat/s_compare128M.c
new file mode 100644
index 000000000000..205f31454adf
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_compare128M.c
@@ -0,0 +1,62 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_compare128M
+
+int_fast8_t softfloat_compare128M( const uint32_t *aPtr, const uint32_t *bPtr )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA, wordB;
+
+    index = indexWordHi( 4 );
+    lastIndex = indexWordLo( 4 );
+    for (;;) {
+        wordA = aPtr[index];
+        wordB = bPtr[index];
+        if ( wordA != wordB ) return (wordA < wordB) ? -1 : 1;
+        if ( index == lastIndex ) break;
+        index -= wordIncr;
+    }
+    return 0;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_compare96M.c b/arch/riscv/kernel/soft_vector/softfloat/s_compare96M.c
new file mode 100644
index 000000000000..d92845e9e09a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_compare96M.c
@@ -0,0 +1,62 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_compare96M
+
+int_fast8_t softfloat_compare96M( const uint32_t *aPtr, const uint32_t *bPtr )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA, wordB;
+
+    index = indexWordHi( 3 );
+    lastIndex = indexWordLo( 3 );
+    for (;;) {
+        wordA = aPtr[index];
+        wordB = bPtr[index];
+        if ( wordA != wordB ) return (wordA < wordB) ? -1 : 1;
+        if ( index == lastIndex ) break;
+        index -= wordIncr;
+    }
+    return 0;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros16.c b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros16.c
new file mode 100644
index 000000000000..2b5087aa95b7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros16.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_countLeadingZeros16
+
+#define softfloat_countLeadingZeros16 softfloat_countLeadingZeros16
+#include "primitives.h"
+
+uint_fast8_t softfloat_countLeadingZeros16( uint16_t a )
+{
+    uint_fast8_t count;
+
+    count = 8;
+    if ( 0x100 <= a ) {
+        count = 0;
+        a >>= 8;
+    }
+    count += softfloat_countLeadingZeros8[a];
+    return count;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros32.c b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros32.c
new file mode 100644
index 000000000000..4c18a6e9351d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros32.c
@@ -0,0 +1,64 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_countLeadingZeros32
+
+#define softfloat_countLeadingZeros32 softfloat_countLeadingZeros32
+#include "primitives.h"
+
+uint_fast8_t softfloat_countLeadingZeros32( uint32_t a )
+{
+    uint_fast8_t count;
+
+    count = 0;
+    if ( a < 0x10000 ) {
+        count = 16;
+        a <<= 16;
+    }
+    if ( a < 0x1000000 ) {
+        count += 8;
+        a <<= 8;
+    }
+    count += softfloat_countLeadingZeros8[a>>24];
+    return count;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros64.c b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros64.c
new file mode 100644
index 000000000000..f9286c8d6597
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros64.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_countLeadingZeros64
+
+#define softfloat_countLeadingZeros64 softfloat_countLeadingZeros64
+#include "primitives.h"
+
+uint_fast8_t softfloat_countLeadingZeros64( uint64_t a )
+{
+    uint_fast8_t count;
+    uint32_t a32;
+
+    count = 0;
+    a32 = a>>32;
+    if ( ! a32 ) {
+        count = 32;
+        a32 = a;
+    }
+    /*------------------------------------------------------------------------
+    | From here, result is current count + count leading zeros of `a32'.
+    *------------------------------------------------------------------------*/
+    if ( a32 < 0x10000 ) {
+        count += 16;
+        a32 <<= 16;
+    }
+    if ( a32 < 0x1000000 ) {
+        count += 8;
+        a32 <<= 8;
+    }
+    count += softfloat_countLeadingZeros8[a32>>24];
+    return count;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros8.c b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros8.c
new file mode 100644
index 000000000000..4a50ce438f4b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_countLeadingZeros8.c
@@ -0,0 +1,59 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitives.h"
+
+const uint_least8_t softfloat_countLeadingZeros8[256] = {
+    8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_eq128.c b/arch/riscv/kernel/soft_vector/softfloat/s_eq128.c
new file mode 100644
index 000000000000..1e72a165a4e5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_eq128.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_eq128
+
+bool softfloat_eq128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+
+    return (a64 == b64) && (a0 == b0);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_f128UIToCommonNaN.c b/arch/riscv/kernel/soft_vector/softfloat/s_f128UIToCommonNaN.c
new file mode 100644
index 000000000000..861b26965893
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_f128UIToCommonNaN.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_f16UIToCommonNaN.c b/arch/riscv/kernel/soft_vector/softfloat/s_f16UIToCommonNaN.c
new file mode 100644
index 000000000000..861b26965893
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_f16UIToCommonNaN.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_f32UIToCommonNaN.c b/arch/riscv/kernel/soft_vector/softfloat/s_f32UIToCommonNaN.c
new file mode 100644
index 000000000000..861b26965893
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_f32UIToCommonNaN.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_f64UIToCommonNaN.c b/arch/riscv/kernel/soft_vector/softfloat/s_f64UIToCommonNaN.c
new file mode 100644
index 000000000000..861b26965893
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_f64UIToCommonNaN.c
@@ -0,0 +1,5 @@
+
+/*----------------------------------------------------------------------------
+| This file intentionally contains no code.
+*----------------------------------------------------------------------------*/
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_le128.c b/arch/riscv/kernel/soft_vector/softfloat/s_le128.c
new file mode 100644
index 000000000000..23c1cadd20c6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_le128.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_le128
+
+bool softfloat_le128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+
+    return (a64 < b64) || ((a64 == b64) && (a0 <= b0));
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_lt128.c b/arch/riscv/kernel/soft_vector/softfloat/s_lt128.c
new file mode 100644
index 000000000000..93c275b7f22b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_lt128.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_lt128
+
+bool softfloat_lt128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+
+    return (a64 < b64) || ((a64 == b64) && (a0 < b0));
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul128By32.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul128By32.c
new file mode 100644
index 000000000000..4274612ff02e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul128By32.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul128By32
+
+struct uint128 softfloat_mul128By32( uint64_t a64, uint64_t a0, uint32_t b )
+{
+    struct uint128 z;
+    uint_fast64_t mid;
+    uint_fast32_t carry;
+
+    z.v0 = a0 * b;
+    mid = (uint_fast64_t) (uint32_t) (a0>>32) * b;
+    carry = (uint32_t) ((uint_fast32_t) (z.v0>>32) - (uint_fast32_t) mid);
+    z.v64 = a64 * b + (uint_fast32_t) ((mid + carry)>>32);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul128MTo256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul128MTo256M.c
new file mode 100644
index 000000000000..c4a666437bbd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul128MTo256M.c
@@ -0,0 +1,100 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul128MTo256M
+
+void
+ softfloat_mul128MTo256M(
+     const uint32_t *aPtr, const uint32_t *bPtr, uint32_t *zPtr )
+{
+    uint32_t *lastZPtr, wordB;
+    uint64_t dwordProd;
+    uint32_t wordZ;
+    uint_fast8_t carry;
+
+    bPtr += indexWordLo( 4 );
+    lastZPtr = zPtr + indexMultiwordHi( 8, 5 );
+    zPtr += indexMultiwordLo( 8, 5 );
+    wordB = *bPtr;
+    dwordProd = (uint64_t) aPtr[indexWord( 4, 0 )] * wordB;
+    zPtr[indexWord( 5, 0 )] = dwordProd;
+    dwordProd = (uint64_t) aPtr[indexWord( 4, 1 )] * wordB + (dwordProd>>32);
+    zPtr[indexWord( 5, 1 )] = dwordProd;
+    dwordProd = (uint64_t) aPtr[indexWord( 4, 2 )] * wordB + (dwordProd>>32);
+    zPtr[indexWord( 5, 2 )] = dwordProd;
+    dwordProd = (uint64_t) aPtr[indexWord( 4, 3 )] * wordB + (dwordProd>>32);
+    zPtr[indexWord( 5, 3 )] = dwordProd;
+    zPtr[indexWord( 5, 4 )] = dwordProd>>32;
+    do {
+        bPtr += wordIncr;
+        zPtr += wordIncr;
+        wordB = *bPtr;
+        dwordProd = (uint64_t) aPtr[indexWord( 4, 0 )] * wordB;
+        wordZ = zPtr[indexWord( 5, 0 )] + (uint32_t) dwordProd;
+        zPtr[indexWord( 5, 0 )] = wordZ;
+        carry = (wordZ < (uint32_t) dwordProd);
+        dwordProd =
+            (uint64_t) aPtr[indexWord( 4, 1 )] * wordB + (dwordProd>>32);
+        wordZ = zPtr[indexWord( 5, 1 )] + (uint32_t) dwordProd + carry;
+        zPtr[indexWord( 5, 1 )] = wordZ;
+        if ( wordZ != (uint32_t) dwordProd ) {
+            carry = (wordZ < (uint32_t) dwordProd);
+        }
+        dwordProd =
+            (uint64_t) aPtr[indexWord( 4, 2 )] * wordB + (dwordProd>>32);
+        wordZ = zPtr[indexWord( 5, 2 )] + (uint32_t) dwordProd + carry;
+        zPtr[indexWord( 5, 2 )] = wordZ;
+        if ( wordZ != (uint32_t) dwordProd ) {
+            carry = (wordZ < (uint32_t) dwordProd);
+        }
+        dwordProd =
+            (uint64_t) aPtr[indexWord( 4, 3 )] * wordB + (dwordProd>>32);
+        wordZ = zPtr[indexWord( 5, 3 )] + (uint32_t) dwordProd + carry;
+        zPtr[indexWord( 5, 3 )] = wordZ;
+        if ( wordZ != (uint32_t) dwordProd ) {
+            carry = (wordZ < (uint32_t) dwordProd);
+        }
+        zPtr[indexWord( 5, 4 )] = (dwordProd>>32) + carry;
+    } while ( zPtr != lastZPtr );
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul128To256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul128To256M.c
new file mode 100644
index 000000000000..8fd2ce00e47c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul128To256M.c
@@ -0,0 +1,71 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_mul128To256M
+
+#define softfloat_mul128To256M softfloat_mul128To256M
+#include "primitives.h"
+
+void
+ softfloat_mul128To256M(
+     uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0, uint64_t *zPtr )
+{
+    struct uint128 p0, p64, p128;
+    uint_fast64_t z64, z128, z192;
+
+    p0 = softfloat_mul64To128( a0, b0 );
+    zPtr[indexWord( 4, 0 )] = p0.v0;
+    p64 = softfloat_mul64To128( a64, b0 );
+    z64 = p64.v0 + p0.v64;
+    z128 = p64.v64 + (z64 < p64.v0);
+    p128 = softfloat_mul64To128( a64, b64 );
+    z128 += p128.v0;
+    z192 = p128.v64 + (z128 < p128.v0);
+    p64 = softfloat_mul64To128( a0, b64 );
+    z64 += p64.v0;
+    zPtr[indexWord( 4, 1 )] = z64;
+    p64.v64 += (z64 < p64.v0);
+    z128 += p64.v64;
+    zPtr[indexWord( 4, 2 )] = z128;
+    zPtr[indexWord( 4, 3 )] = z192 + (z128 < p64.v64);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul64ByShifted32To128.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul64ByShifted32To128.c
new file mode 100644
index 000000000000..8439dec331c8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul64ByShifted32To128.c
@@ -0,0 +1,56 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul64ByShifted32To128
+
+struct uint128 softfloat_mul64ByShifted32To128( uint64_t a, uint32_t b )
+{
+    uint_fast64_t mid;
+    struct uint128 z;
+
+    mid = (uint_fast64_t) (uint32_t) a * b;
+    z.v0 = mid<<32;
+    z.v64 = (uint_fast64_t) (uint32_t) (a>>32) * b + (mid>>32);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128.c
new file mode 100644
index 000000000000..3dbebd334b12
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128.c
@@ -0,0 +1,66 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul64To128
+
+struct uint128 softfloat_mul64To128( uint64_t a, uint64_t b )
+{
+    uint32_t a32, a0, b32, b0;
+    struct uint128 z;
+    uint64_t mid1, mid;
+
+    a32 = a>>32;
+    a0 = a;
+    b32 = b>>32;
+    b0 = b;
+    z.v0 = (uint_fast64_t) a0 * b0;
+    mid1 = (uint_fast64_t) a32 * b0;
+    mid = mid1 + (uint_fast64_t) a0 * b32;
+    z.v64 = (uint_fast64_t) a32 * b32;
+    z.v64 += (uint_fast64_t) (mid < mid1)<<32 | mid>>32;
+    mid <<= 32;
+    z.v0 += mid;
+    z.v64 += (z.v0 < mid);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128M.c b/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128M.c
new file mode 100644
index 000000000000..fa85495155fd
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mul64To128M.c
@@ -0,0 +1,68 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_mul64To128M
+
+void softfloat_mul64To128M( uint64_t a, uint64_t b, uint32_t *zPtr )
+{
+    uint32_t a32, a0, b32, b0;
+    uint64_t z0, mid1, z64, mid;
+
+    a32 = a>>32;
+    a0 = a;
+    b32 = b>>32;
+    b0 = b;
+    z0 = (uint64_t) a0 * b0;
+    mid1 = (uint64_t) a32 * b0;
+    mid = mid1 + (uint64_t) a0 * b32;
+    z64 = (uint64_t) a32 * b32;
+    z64 += (uint64_t) (mid < mid1)<<32 | mid>>32;
+    mid <<= 32;
+    z0 += mid;
+    zPtr[indexWord( 4, 1 )] = z0>>32;
+    zPtr[indexWord( 4, 0 )] = z0;
+    z64 += (z0 < mid);
+    zPtr[indexWord( 4, 3 )] = z64>>32;
+    zPtr[indexWord( 4, 2 )] = z64;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF128.c
new file mode 100644
index 000000000000..cc85413725b8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF128.c
@@ -0,0 +1,350 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t
+ softfloat_mulAddF128(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0,
+     uint_fast64_t uiC64,
+     uint_fast64_t uiC0,
+     uint_fast8_t op
+ )
+{
+    bool signA;
+    int_fast32_t expA;
+    struct uint128 sigA;
+    bool signB;
+    int_fast32_t expB;
+    struct uint128 sigB;
+    bool signC;
+    int_fast32_t expC;
+    struct uint128 sigC;
+    bool signZ;
+    uint_fast64_t magBits;
+    struct uint128 uiZ;
+    struct exp32_sig128 normExpSig;
+    int_fast32_t expZ;
+    uint64_t sig256Z[4];
+    struct uint128 sigZ;
+    int_fast32_t shiftDist, expDiff;
+    struct uint128 x128;
+    uint64_t sig256C[4];
+    static uint64_t zero256[4] = INIT_UINTM4( 0, 0, 0, 0 );
+    uint_fast64_t sigZExtra, sig256Z0;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF128UI64( uiA64 );
+    expA  = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    signB = signF128UI64( uiB64 );
+    expB  = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    signC = signF128UI64( uiC64 ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF128UI64( uiC64 );
+    sigC.v64 = fracF128UI64( uiC64 );
+    sigC.v0  = uiC0;
+    signZ = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FFF ) {
+        if (
+            (sigA.v64 | sigA.v0) || ((expB == 0x7FFF) && (sigB.v64 | sigB.v0))
+        ) {
+            goto propagateNaN_ABC;
+        }
+        magBits = expB | sigB.v64 | sigB.v0;
+        goto infProdArg;
+    }
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN_ABC;
+        magBits = expA | sigA.v64 | sigA.v0;
+        goto infProdArg;
+    }
+    if ( expC == 0x7FFF ) {
+        if ( sigC.v64 | sigC.v0 ) {
+            uiZ.v64 = 0;
+            uiZ.v0  = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ.v64 = uiC64;
+        uiZ.v0  = uiC0;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! (sigA.v64 | sigA.v0) ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF128Sig( sigA.v64, sigA.v0 );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! (sigB.v64 | sigB.v0) ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF128Sig( sigB.v64, sigB.v0 );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x3FFE;
+    sigA.v64 |= UINT64_C( 0x0001000000000000 );
+    sigB.v64 |= UINT64_C( 0x0001000000000000 );
+    sigA = softfloat_shortShiftLeft128( sigA.v64, sigA.v0, 8 );
+    sigB = softfloat_shortShiftLeft128( sigB.v64, sigB.v0, 15 );
+    softfloat_mul128To256M( sigA.v64, sigA.v0, sigB.v64, sigB.v0, sig256Z );
+    sigZ.v64 = sig256Z[indexWord( 4, 3 )];
+    sigZ.v0  = sig256Z[indexWord( 4, 2 )];
+    shiftDist = 0;
+    if ( ! (sigZ.v64 & UINT64_C( 0x0100000000000000 )) ) {
+        --expZ;
+        shiftDist = -1;
+    }
+    if ( ! expC ) {
+        if ( ! (sigC.v64 | sigC.v0) ) {
+            shiftDist += 8;
+            goto sigZ;
+        }
+        normExpSig = softfloat_normSubnormalF128Sig( sigC.v64, sigC.v0 );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC.v64 |= UINT64_C( 0x0001000000000000 );
+    sigC = softfloat_shortShiftLeft128( sigC.v64, sigC.v0, 8 );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expZ - expC;
+    if ( expDiff < 0 ) {
+        expZ = expC;
+        if ( (signZ == signC) || (expDiff < -1) ) {
+            shiftDist -= expDiff;
+            if ( shiftDist ) {
+                sigZ =
+                    softfloat_shiftRightJam128( sigZ.v64, sigZ.v0, shiftDist );
+            }
+        } else {
+            if ( ! shiftDist ) {
+                x128 =
+                    softfloat_shortShiftRight128(
+                        sig256Z[indexWord( 4, 1 )], sig256Z[indexWord( 4, 0 )],
+                        1
+                    );
+                sig256Z[indexWord( 4, 1 )] = (sigZ.v0<<63) | x128.v64;
+                sig256Z[indexWord( 4, 0 )] = x128.v0;
+                sigZ = softfloat_shortShiftRight128( sigZ.v64, sigZ.v0, 1 );
+                sig256Z[indexWord( 4, 3 )] = sigZ.v64;
+                sig256Z[indexWord( 4, 2 )] = sigZ.v0;
+            }
+        }
+    } else {
+        if ( shiftDist ) softfloat_add256M( sig256Z, sig256Z, sig256Z );
+        if ( ! expDiff ) {
+            sigZ.v64 = sig256Z[indexWord( 4, 3 )];
+            sigZ.v0  = sig256Z[indexWord( 4, 2 )];
+        } else {
+            sig256C[indexWord( 4, 3 )] = sigC.v64;
+            sig256C[indexWord( 4, 2 )] = sigC.v0;
+            sig256C[indexWord( 4, 1 )] = 0;
+            sig256C[indexWord( 4, 0 )] = 0;
+            softfloat_shiftRightJam256M( sig256C, expDiff, sig256C );
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    shiftDist = 8;
+    if ( signZ == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            sigZ = softfloat_add128( sigC.v64, sigC.v0, sigZ.v64, sigZ.v0 );
+        } else {
+            softfloat_add256M( sig256Z, sig256C, sig256Z );
+            sigZ.v64 = sig256Z[indexWord( 4, 3 )];
+            sigZ.v0  = sig256Z[indexWord( 4, 2 )];
+        }
+        if ( sigZ.v64 & UINT64_C( 0x0200000000000000 ) ) {
+            ++expZ;
+            shiftDist = 9;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            if ( expDiff < -1 ) {
+                sigZ =
+                    softfloat_sub128( sigC.v64, sigC.v0, sigZ.v64, sigZ.v0 );
+                sigZExtra =
+                    sig256Z[indexWord( 4, 1 )] | sig256Z[indexWord( 4, 0 )];
+                if ( sigZExtra ) {
+                    sigZ = softfloat_sub128( sigZ.v64, sigZ.v0, 0, 1 );
+                }
+                if ( ! (sigZ.v64 & UINT64_C( 0x0100000000000000 )) ) {
+                    --expZ;
+                    shiftDist = 7;
+                }
+                goto shiftRightRoundPack;
+            } else {
+                sig256C[indexWord( 4, 3 )] = sigC.v64;
+                sig256C[indexWord( 4, 2 )] = sigC.v0;
+                sig256C[indexWord( 4, 1 )] = 0;
+                sig256C[indexWord( 4, 0 )] = 0;
+                softfloat_sub256M( sig256C, sig256Z, sig256Z );
+            }
+        } else if ( ! expDiff ) {
+            sigZ = softfloat_sub128( sigZ.v64, sigZ.v0, sigC.v64, sigC.v0 );
+            if (
+                ! (sigZ.v64 | sigZ.v0) && ! sig256Z[indexWord( 4, 1 )]
+                    && ! sig256Z[indexWord( 4, 0 )]
+            ) {
+                goto completeCancellation;
+            }
+            sig256Z[indexWord( 4, 3 )] = sigZ.v64;
+            sig256Z[indexWord( 4, 2 )] = sigZ.v0;
+            if ( sigZ.v64 & UINT64_C( 0x8000000000000000 ) ) {
+                signZ = ! signZ;
+                softfloat_sub256M( zero256, sig256Z, sig256Z );
+            }
+        } else {
+            softfloat_sub256M( sig256Z, sig256C, sig256Z );
+            if ( 1 < expDiff ) {
+                sigZ.v64 = sig256Z[indexWord( 4, 3 )];
+                sigZ.v0  = sig256Z[indexWord( 4, 2 )];
+                if ( ! (sigZ.v64 & UINT64_C( 0x0100000000000000 )) ) {
+                    --expZ;
+                    shiftDist = 7;
+                }
+                goto sigZ;
+            }
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sigZ.v64  = sig256Z[indexWord( 4, 3 )];
+        sigZ.v0   = sig256Z[indexWord( 4, 2 )];
+        sigZExtra = sig256Z[indexWord( 4, 1 )];
+        sig256Z0  = sig256Z[indexWord( 4, 0 )];
+        if ( sigZ.v64 ) {
+            if ( sig256Z0 ) sigZExtra |= 1;
+        } else {
+            expZ -= 64;
+            sigZ.v64  = sigZ.v0;
+            sigZ.v0   = sigZExtra;
+            sigZExtra = sig256Z0;
+            if ( ! sigZ.v64 ) {
+                expZ -= 64;
+                sigZ.v64  = sigZ.v0;
+                sigZ.v0   = sigZExtra;
+                sigZExtra = 0;
+                if ( ! sigZ.v64 ) {
+                    expZ -= 64;
+                    sigZ.v64 = sigZ.v0;
+                    sigZ.v0  = 0;
+                }
+            }
+        }
+        shiftDist = softfloat_countLeadingZeros64( sigZ.v64 );
+        expZ += 7 - shiftDist;
+        shiftDist = 15 - shiftDist;
+        if ( 0 < shiftDist ) goto shiftRightRoundPack;
+        if ( shiftDist ) {
+            shiftDist = -shiftDist;
+            sigZ = softfloat_shortShiftLeft128( sigZ.v64, sigZ.v0, shiftDist );
+            x128 = softfloat_shortShiftLeft128( 0, sigZExtra, shiftDist );
+            sigZ.v0 |= x128.v64;
+            sigZExtra = x128.v0;
+        }
+        goto roundPack;
+    }
+ sigZ:
+    sigZExtra = sig256Z[indexWord( 4, 1 )] | sig256Z[indexWord( 4, 0 )];
+ shiftRightRoundPack:
+    sigZExtra = (uint64_t) (sigZ.v0<<(64 - shiftDist)) | (sigZExtra != 0);
+    sigZ = softfloat_shortShiftRight128( sigZ.v64, sigZ.v0, shiftDist );
+ roundPack:
+    return
+        softfloat_roundPackToF128(
+            signZ, expZ - 1, sigZ.v64, sigZ.v0, sigZExtra );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ.v64 = packToF128UI64( signZ, 0x7FFF, 0 );
+        uiZ.v0 = 0;
+        if ( expC != 0x7FFF ) goto uiZ;
+        if ( sigC.v64 | sigC.v0 ) goto propagateNaN_ZC;
+        if ( signZ == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF128UI( uiZ.v64, uiZ.v0, uiC64, uiC0 );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ.v64 = uiC64;
+    uiZ.v0  = uiC0;
+    if ( ! (expC | sigC.v64 | sigC.v0) && (signZ != signC) ) {
+ completeCancellation:
+        uiZ.v64 =
+            packToF128UI64(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+        uiZ.v0 = 0;
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF16.c
new file mode 100644
index 000000000000..e4550fe3456c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF16.c
@@ -0,0 +1,226 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t
+ softfloat_mulAddF16(
+     uint_fast16_t uiA, uint_fast16_t uiB, uint_fast16_t uiC, uint_fast8_t op )
+{
+    bool signA;
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    bool signB;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    bool signC;
+    int_fast8_t expC;
+    uint_fast16_t sigC;
+    bool signProd;
+    uint_fast16_t magBits, uiZ;
+    struct exp8_sig16 normExpSig;
+    int_fast8_t expProd;
+    uint_fast32_t sigProd;
+    bool signZ;
+    int_fast8_t expZ;
+    uint_fast16_t sigZ;
+    int_fast8_t expDiff;
+    uint_fast32_t sig32Z, sig32C;
+    int_fast8_t shiftDist;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF16UI( uiA );
+    expA  = expF16UI( uiA );
+    sigA  = fracF16UI( uiA );
+    signB = signF16UI( uiB );
+    expB  = expF16UI( uiB );
+    sigB  = fracF16UI( uiB );
+    signC = signF16UI( uiC ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF16UI( uiC );
+    sigC  = fracF16UI( uiC );
+    signProd = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x1F ) {
+        if ( sigA || ((expB == 0x1F) && sigB) ) goto propagateNaN_ABC;
+        magBits = expB | sigB;
+        goto infProdArg;
+    }
+    if ( expB == 0x1F ) {
+        if ( sigB ) goto propagateNaN_ABC;
+        magBits = expA | sigA;
+        goto infProdArg;
+    }
+    if ( expC == 0x1F ) {
+        if ( sigC ) {
+            uiZ = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ = uiC;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF16Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF16Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expProd = expA + expB - 0xE;
+    sigA = (sigA | 0x0400)<<4;
+    sigB = (sigB | 0x0400)<<4;
+    sigProd = (uint_fast32_t) sigA * sigB;
+    if ( sigProd < 0x20000000 ) {
+        --expProd;
+        sigProd <<= 1;
+    }
+    signZ = signProd;
+    if ( ! expC ) {
+        if ( ! sigC ) {
+            expZ = expProd - 1;
+            sigZ = sigProd>>15 | ((sigProd & 0x7FFF) != 0);
+            goto roundPack;
+        }
+        normExpSig = softfloat_normSubnormalF16Sig( sigC );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC = (sigC | 0x0400)<<3;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expProd - expC;
+    if ( signProd == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            expZ = expC;
+            sigZ = sigC + softfloat_shiftRightJam32( sigProd, 16 - expDiff );
+        } else {
+            expZ = expProd;
+            sig32Z =
+                sigProd
+                    + softfloat_shiftRightJam32(
+                          (uint_fast32_t) sigC<<16, expDiff );
+            sigZ = sig32Z>>16 | ((sig32Z & 0xFFFF) != 0 );
+        }
+        if ( sigZ < 0x4000 ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig32C = (uint_fast32_t) sigC<<16;
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            expZ = expC;
+            sig32Z = sig32C - softfloat_shiftRightJam32( sigProd, -expDiff );
+        } else if ( ! expDiff ) {
+            expZ = expProd;
+            sig32Z = sigProd - sig32C;
+            if ( ! sig32Z ) goto completeCancellation;
+            if ( sig32Z & 0x80000000 ) {
+                signZ = ! signZ;
+                sig32Z = -sig32Z;
+            }
+        } else {
+            expZ = expProd;
+            sig32Z = sigProd - softfloat_shiftRightJam32( sig32C, expDiff );
+        }
+        shiftDist = softfloat_countLeadingZeros32( sig32Z ) - 1;
+        expZ -= shiftDist;
+        shiftDist -= 16;
+        if ( shiftDist < 0 ) {
+            sigZ =
+                sig32Z>>(-shiftDist)
+                    | ((uint32_t) (sig32Z<<(shiftDist & 31)) != 0);
+        } else {
+            sigZ = (uint_fast16_t) sig32Z<<shiftDist;
+        }
+    }
+ roundPack:
+    return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ = packToF16UI( signProd, 0x1F, 0 );
+        if ( expC != 0x1F ) goto uiZ;
+        if ( sigC ) goto propagateNaN_ZC;
+        if ( signProd == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF16UI;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF16UI( uiZ, uiC );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ = uiC;
+    if ( ! (expC | sigC) && (signProd != signC) ) {
+ completeCancellation:
+        uiZ =
+            packToF16UI(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF32.c
new file mode 100644
index 000000000000..90face07392d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF32.c
@@ -0,0 +1,224 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t
+ softfloat_mulAddF32(
+     uint_fast32_t uiA, uint_fast32_t uiB, uint_fast32_t uiC, uint_fast8_t op )
+{
+    bool signA;
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    bool signC;
+    int_fast16_t expC;
+    uint_fast32_t sigC;
+    bool signProd;
+    uint_fast32_t magBits, uiZ;
+    struct exp16_sig32 normExpSig;
+    int_fast16_t expProd;
+    uint_fast64_t sigProd;
+    bool signZ;
+    int_fast16_t expZ;
+    uint_fast32_t sigZ;
+    int_fast16_t expDiff;
+    uint_fast64_t sig64Z, sig64C;
+    int_fast8_t shiftDist;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF32UI( uiA );
+    expA  = expF32UI( uiA );
+    sigA  = fracF32UI( uiA );
+    signB = signF32UI( uiB );
+    expB  = expF32UI( uiB );
+    sigB  = fracF32UI( uiB );
+    signC = signF32UI( uiC ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF32UI( uiC );
+    sigC  = fracF32UI( uiC );
+    signProd = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0xFF ) {
+        if ( sigA || ((expB == 0xFF) && sigB) ) goto propagateNaN_ABC;
+        magBits = expB | sigB;
+        goto infProdArg;
+    }
+    if ( expB == 0xFF ) {
+        if ( sigB ) goto propagateNaN_ABC;
+        magBits = expA | sigA;
+        goto infProdArg;
+    }
+    if ( expC == 0xFF ) {
+        if ( sigC ) {
+            uiZ = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ = uiC;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF32Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF32Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expProd = expA + expB - 0x7E;
+    sigA = (sigA | 0x00800000)<<7;
+    sigB = (sigB | 0x00800000)<<7;
+    sigProd = (uint_fast64_t) sigA * sigB;
+    if ( sigProd < UINT64_C( 0x2000000000000000 ) ) {
+        --expProd;
+        sigProd <<= 1;
+    }
+    signZ = signProd;
+    if ( ! expC ) {
+        if ( ! sigC ) {
+            expZ = expProd - 1;
+            sigZ = softfloat_shortShiftRightJam64( sigProd, 31 );
+            goto roundPack;
+        }
+        normExpSig = softfloat_normSubnormalF32Sig( sigC );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC = (sigC | 0x00800000)<<6;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expProd - expC;
+    if ( signProd == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            expZ = expC;
+            sigZ = sigC + softfloat_shiftRightJam64( sigProd, 32 - expDiff );
+        } else {
+            expZ = expProd;
+            sig64Z =
+                sigProd
+                    + softfloat_shiftRightJam64(
+                          (uint_fast64_t) sigC<<32, expDiff );
+            sigZ = softfloat_shortShiftRightJam64( sig64Z, 32 );
+        }
+        if ( sigZ < 0x40000000 ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sig64C = (uint_fast64_t) sigC<<32;
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            expZ = expC;
+            sig64Z = sig64C - softfloat_shiftRightJam64( sigProd, -expDiff );
+        } else if ( ! expDiff ) {
+            expZ = expProd;
+            sig64Z = sigProd - sig64C;
+            if ( ! sig64Z ) goto completeCancellation;
+            if ( sig64Z & UINT64_C( 0x8000000000000000 ) ) {
+                signZ = ! signZ;
+                sig64Z = -sig64Z;
+            }
+        } else {
+            expZ = expProd;
+            sig64Z = sigProd - softfloat_shiftRightJam64( sig64C, expDiff );
+        }
+        shiftDist = softfloat_countLeadingZeros64( sig64Z ) - 1;
+        expZ -= shiftDist;
+        shiftDist -= 32;
+        if ( shiftDist < 0 ) {
+            sigZ = softfloat_shortShiftRightJam64( sig64Z, -shiftDist );
+        } else {
+            sigZ = (uint_fast32_t) sig64Z<<shiftDist;
+        }
+    }
+ roundPack:
+    return softfloat_roundPackToF32( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ = packToF32UI( signProd, 0xFF, 0 );
+        if ( expC != 0xFF ) goto uiZ;
+        if ( sigC ) goto propagateNaN_ZC;
+        if ( signProd == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF32UI;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF32UI( uiZ, uiC );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ = uiC;
+    if ( ! (expC | sigC) && (signProd != signC) ) {
+ completeCancellation:
+        uiZ =
+            packToF32UI(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF64.c
new file mode 100644
index 000000000000..f6e7c5c51aaa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_mulAddF64.c
@@ -0,0 +1,496 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+float64_t
+ softfloat_mulAddF64(
+     uint_fast64_t uiA, uint_fast64_t uiB, uint_fast64_t uiC, uint_fast8_t op )
+{
+    bool signA;
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    bool signB;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    bool signC;
+    int_fast16_t expC;
+    uint_fast64_t sigC;
+    bool signZ;
+    uint_fast64_t magBits, uiZ;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+    struct uint128 sig128Z;
+    uint_fast64_t sigZ;
+    int_fast16_t expDiff;
+    struct uint128 sig128C;
+    int_fast8_t shiftDist;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    signB = signF64UI( uiB );
+    expB  = expF64UI( uiB );
+    sigB  = fracF64UI( uiB );
+    signC = signF64UI( uiC ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF64UI( uiC );
+    sigC  = fracF64UI( uiC );
+    signZ = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA || ((expB == 0x7FF) && sigB) ) goto propagateNaN_ABC;
+        magBits = expB | sigB;
+        goto infProdArg;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN_ABC;
+        magBits = expA | sigA;
+        goto infProdArg;
+    }
+    if ( expC == 0x7FF ) {
+        if ( sigC ) {
+            uiZ = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ = uiC;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x3FE;
+    sigA = (sigA | UINT64_C( 0x0010000000000000 ))<<10;
+    sigB = (sigB | UINT64_C( 0x0010000000000000 ))<<10;
+    sig128Z = softfloat_mul64To128( sigA, sigB );
+    if ( sig128Z.v64 < UINT64_C( 0x2000000000000000 ) ) {
+        --expZ;
+        sig128Z =
+            softfloat_add128(
+                sig128Z.v64, sig128Z.v0, sig128Z.v64, sig128Z.v0 );
+    }
+    if ( ! expC ) {
+        if ( ! sigC ) {
+            --expZ;
+            sigZ = sig128Z.v64<<1 | (sig128Z.v0 != 0);
+            goto roundPack;
+        }
+        normExpSig = softfloat_normSubnormalF64Sig( sigC );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC = (sigC | UINT64_C( 0x0010000000000000 ))<<9;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expZ - expC;
+    if ( expDiff < 0 ) {
+        expZ = expC;
+        if ( (signZ == signC) || (expDiff < -1) ) {
+            sig128Z.v64 = softfloat_shiftRightJam64( sig128Z.v64, -expDiff );
+        } else {
+            sig128Z =
+                softfloat_shortShiftRightJam128( sig128Z.v64, sig128Z.v0, 1 );
+        }
+    } else if ( expDiff ) {
+        sig128C = softfloat_shiftRightJam128( sigC, 0, expDiff );
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signZ == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            sigZ = (sigC + sig128Z.v64) | (sig128Z.v0 != 0);
+        } else {
+            sig128Z =
+                softfloat_add128(
+                    sig128Z.v64, sig128Z.v0, sig128C.v64, sig128C.v0 );
+            sigZ = sig128Z.v64 | (sig128Z.v0 != 0);
+        }
+        if ( sigZ < UINT64_C( 0x4000000000000000 ) ) {
+            --expZ;
+            sigZ <<= 1;
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            sig128Z = softfloat_sub128( sigC, 0, sig128Z.v64, sig128Z.v0 );
+        } else if ( ! expDiff ) {
+            sig128Z.v64 = sig128Z.v64 - sigC;
+            if ( ! (sig128Z.v64 | sig128Z.v0) ) goto completeCancellation;
+            if ( sig128Z.v64 & UINT64_C( 0x8000000000000000 ) ) {
+                signZ = ! signZ;
+                sig128Z = softfloat_sub128( 0, 0, sig128Z.v64, sig128Z.v0 );
+            }
+        } else {
+            sig128Z =
+                softfloat_sub128(
+                    sig128Z.v64, sig128Z.v0, sig128C.v64, sig128C.v0 );
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( ! sig128Z.v64 ) {
+            expZ -= 64;
+            sig128Z.v64 = sig128Z.v0;
+            sig128Z.v0 = 0;
+        }
+        shiftDist = softfloat_countLeadingZeros64( sig128Z.v64 ) - 1;
+        expZ -= shiftDist;
+        if ( shiftDist < 0 ) {
+            sigZ = softfloat_shortShiftRightJam64( sig128Z.v64, -shiftDist );
+        } else {
+            sig128Z =
+                softfloat_shortShiftLeft128(
+                    sig128Z.v64, sig128Z.v0, shiftDist );
+            sigZ = sig128Z.v64;
+        }
+        sigZ |= (sig128Z.v0 != 0);
+    }
+ roundPack:
+    return softfloat_roundPackToF64( signZ, expZ, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ = packToF64UI( signZ, 0x7FF, 0 );
+        if ( expC != 0x7FF ) goto uiZ;
+        if ( sigC ) goto propagateNaN_ZC;
+        if ( signZ == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF64UI( uiZ, uiC );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ = uiC;
+    if ( ! (expC | sigC) && (signZ != signC) ) {
+ completeCancellation:
+        uiZ =
+            packToF64UI(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
+#else
+
+float64_t
+ softfloat_mulAddF64(
+     uint_fast64_t uiA, uint_fast64_t uiB, uint_fast64_t uiC, uint_fast8_t op )
+{
+    bool signA;
+    int_fast16_t expA;
+    uint64_t sigA;
+    bool signB;
+    int_fast16_t expB;
+    uint64_t sigB;
+    bool signC;
+    int_fast16_t expC;
+    uint64_t sigC;
+    bool signZ;
+    uint64_t magBits, uiZ;
+    struct exp16_sig64 normExpSig;
+    int_fast16_t expZ;
+    uint32_t sig128Z[4];
+    uint64_t sigZ;
+    int_fast16_t shiftDist, expDiff;
+    uint32_t sig128C[4];
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    signA = signF64UI( uiA );
+    expA  = expF64UI( uiA );
+    sigA  = fracF64UI( uiA );
+    signB = signF64UI( uiB );
+    expB  = expF64UI( uiB );
+    sigB  = fracF64UI( uiB );
+    signC = signF64UI( uiC ) ^ (op == softfloat_mulAdd_subC);
+    expC  = expF64UI( uiC );
+    sigC  = fracF64UI( uiC );
+    signZ = signA ^ signB ^ (op == softfloat_mulAdd_subProd);
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( expA == 0x7FF ) {
+        if ( sigA || ((expB == 0x7FF) && sigB) ) goto propagateNaN_ABC;
+        magBits = expB | sigB;
+        goto infProdArg;
+    }
+    if ( expB == 0x7FF ) {
+        if ( sigB ) goto propagateNaN_ABC;
+        magBits = expA | sigA;
+        goto infProdArg;
+    }
+    if ( expC == 0x7FF ) {
+        if ( sigC ) {
+            uiZ = 0;
+            goto propagateNaN_ZC;
+        }
+        uiZ = uiC;
+        goto uiZ;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( ! expA ) {
+        if ( ! sigA ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF64Sig( sigA );
+        expA = normExpSig.exp;
+        sigA = normExpSig.sig;
+    }
+    if ( ! expB ) {
+        if ( ! sigB ) goto zeroProd;
+        normExpSig = softfloat_normSubnormalF64Sig( sigB );
+        expB = normExpSig.exp;
+        sigB = normExpSig.sig;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expZ = expA + expB - 0x3FE;
+    sigA = (sigA | UINT64_C( 0x0010000000000000 ))<<10;
+    sigB = (sigB | UINT64_C( 0x0010000000000000 ))<<11;
+    softfloat_mul64To128M( sigA, sigB, sig128Z );
+    sigZ =
+        (uint64_t) sig128Z[indexWord( 4, 3 )]<<32 | sig128Z[indexWord( 4, 2 )];
+    shiftDist = 0;
+    if ( ! (sigZ & UINT64_C( 0x4000000000000000 )) ) {
+        --expZ;
+        shiftDist = -1;
+    }
+    if ( ! expC ) {
+        if ( ! sigC ) {
+            if ( shiftDist ) sigZ <<= 1;
+            goto sigZ;
+        }
+        normExpSig = softfloat_normSubnormalF64Sig( sigC );
+        expC = normExpSig.exp;
+        sigC = normExpSig.sig;
+    }
+    sigC = (sigC | UINT64_C( 0x0010000000000000 ))<<10;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expZ - expC;
+    if ( expDiff < 0 ) {
+        expZ = expC;
+        if ( (signZ == signC) || (expDiff < -1) ) {
+            shiftDist -= expDiff;
+            if ( shiftDist) {
+                sigZ = softfloat_shiftRightJam64( sigZ, shiftDist );
+            }
+        } else {
+            if ( ! shiftDist ) {
+                softfloat_shortShiftRight128M( sig128Z, 1, sig128Z );
+            }
+        }
+    } else {
+        if ( shiftDist ) softfloat_add128M( sig128Z, sig128Z, sig128Z );
+        if ( ! expDiff ) {
+            sigZ =
+                (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                    | sig128Z[indexWord( 4, 2 )];
+        } else {
+            sig128C[indexWord( 4, 3 )] = sigC>>32;
+            sig128C[indexWord( 4, 2 )] = sigC;
+            sig128C[indexWord( 4, 1 )] = 0;
+            sig128C[indexWord( 4, 0 )] = 0;
+            softfloat_shiftRightJam128M( sig128C, expDiff, sig128C );
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( signZ == signC ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff <= 0 ) {
+            sigZ += sigC;
+        } else {
+            softfloat_add128M( sig128Z, sig128C, sig128Z );
+            sigZ =
+                (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                    | sig128Z[indexWord( 4, 2 )];
+        }
+        if ( sigZ & UINT64_C( 0x8000000000000000 ) ) {
+            ++expZ;
+            sigZ = softfloat_shortShiftRightJam64( sigZ, 1 );
+        }
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expDiff < 0 ) {
+            signZ = signC;
+            if ( expDiff < -1 ) {
+                sigZ = sigC - sigZ;
+                if (
+                    sig128Z[indexWord( 4, 1 )] || sig128Z[indexWord( 4, 0 )]
+                ) {
+                    sigZ = (sigZ - 1) | 1;
+                }
+                if ( ! (sigZ & UINT64_C( 0x4000000000000000 )) ) {
+                    --expZ;
+                    sigZ <<= 1;
+                }
+                goto roundPack;
+            } else {
+                sig128C[indexWord( 4, 3 )] = sigC>>32;
+                sig128C[indexWord( 4, 2 )] = sigC;
+                sig128C[indexWord( 4, 1 )] = 0;
+                sig128C[indexWord( 4, 0 )] = 0;
+                softfloat_sub128M( sig128C, sig128Z, sig128Z );
+            }
+        } else if ( ! expDiff ) {
+            sigZ -= sigC;
+            if (
+                ! sigZ && ! sig128Z[indexWord( 4, 1 )]
+                    && ! sig128Z[indexWord( 4, 0 )]
+            ) {
+                goto completeCancellation;
+            }
+            sig128Z[indexWord( 4, 3 )] = sigZ>>32;
+            sig128Z[indexWord( 4, 2 )] = sigZ;
+            if ( sigZ & UINT64_C( 0x8000000000000000 ) ) {
+                signZ = ! signZ;
+                softfloat_negX128M( sig128Z );
+            }
+        } else {
+            softfloat_sub128M( sig128Z, sig128C, sig128Z );
+            if ( 1 < expDiff ) {
+                sigZ =
+                    (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                        | sig128Z[indexWord( 4, 2 )];
+                if ( ! (sigZ & UINT64_C( 0x4000000000000000 )) ) {
+                    --expZ;
+                    sigZ <<= 1;
+                }
+                goto sigZ;
+            }
+        }
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        shiftDist = 0;
+        sigZ =
+            (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                | sig128Z[indexWord( 4, 2 )];
+        if ( ! sigZ ) {
+            shiftDist = 64;
+            sigZ =
+                (uint64_t) sig128Z[indexWord( 4, 1 )]<<32
+                    | sig128Z[indexWord( 4, 0 )];
+        }
+        shiftDist += softfloat_countLeadingZeros64( sigZ ) - 1;
+        if ( shiftDist ) {
+            expZ -= shiftDist;
+            softfloat_shiftLeft128M( sig128Z, shiftDist, sig128Z );
+            sigZ =
+                (uint64_t) sig128Z[indexWord( 4, 3 )]<<32
+                    | sig128Z[indexWord( 4, 2 )];
+        }
+    }
+ sigZ:
+    if ( sig128Z[indexWord( 4, 1 )] || sig128Z[indexWord( 4, 0 )] ) sigZ |= 1;
+ roundPack:
+    return softfloat_roundPackToF64( signZ, expZ - 1, sigZ );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN_ABC:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+    goto propagateNaN_ZC;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ infProdArg:
+    if ( magBits ) {
+        uiZ = packToF64UI( signZ, 0x7FF, 0 );
+        if ( expC != 0x7FF ) goto uiZ;
+        if ( sigC ) goto propagateNaN_ZC;
+        if ( signZ == signC ) goto uiZ;
+    }
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    uiZ = defaultNaNF64UI;
+ propagateNaN_ZC:
+    uiZ = softfloat_propagateNaNF64UI( uiZ, uiC );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ zeroProd:
+    uiZ = uiC;
+    if ( ! (expC | sigC) && (signZ != signC) ) {
+ completeCancellation:
+        uiZ =
+            packToF64UI(
+                (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    }
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_negXM.c b/arch/riscv/kernel/soft_vector/softfloat/s_negXM.c
new file mode 100644
index 000000000000..73fe71eccede
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_negXM.c
@@ -0,0 +1,63 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_negXM
+
+void softfloat_negXM( uint_fast8_t size_words, uint32_t *zPtr )
+{
+    unsigned int index, lastIndex;
+    uint_fast8_t carry;
+    uint32_t word;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    carry = 1;
+    for (;;) {
+        word = ~zPtr[index] + carry;
+        zPtr[index] = word;
+        if ( index == lastIndex ) break;
+        index += wordIncr;
+        if ( word ) carry = 0;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF128.c
new file mode 100644
index 000000000000..9b3fb7706e8a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF128.c
@@ -0,0 +1,81 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+float128_t
+ softfloat_normRoundPackToF128(
+     bool sign, int_fast32_t exp, uint_fast64_t sig64, uint_fast64_t sig0 )
+{
+    int_fast8_t shiftDist;
+    struct uint128 sig128;
+    union ui128_f128 uZ;
+    uint_fast64_t sigExtra;
+    struct uint128_extra sig128Extra;
+
+    if ( ! sig64 ) {
+        exp -= 64;
+        sig64 = sig0;
+        sig0 = 0;
+    }
+    shiftDist = softfloat_countLeadingZeros64( sig64 ) - 15;
+    exp -= shiftDist;
+    if ( 0 <= shiftDist ) {
+        if ( shiftDist ) {
+            sig128 = softfloat_shortShiftLeft128( sig64, sig0, shiftDist );
+            sig64 = sig128.v64;
+            sig0  = sig128.v0;
+        }
+        if ( (uint32_t) exp < 0x7FFD ) {
+            uZ.ui.v64 = packToF128UI64( sign, sig64 | sig0 ? exp : 0, sig64 );
+            uZ.ui.v0  = sig0;
+            return uZ.f;
+        }
+        sigExtra = 0;
+    } else {
+        sig128Extra =
+            softfloat_shortShiftRightJam128Extra( sig64, sig0, 0, -shiftDist );
+        sig64 = sig128Extra.v.v64;
+        sig0  = sig128Extra.v.v0;
+        sigExtra = sig128Extra.extra;
+    }
+    return softfloat_roundPackToF128( sign, exp, sig64, sig0, sigExtra );
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF16.c
new file mode 100644
index 000000000000..e4f9e647276d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF16.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+float16_t
+ softfloat_normRoundPackToF16( bool sign, int_fast16_t exp, uint_fast16_t sig )
+{
+    int_fast8_t shiftDist;
+    union ui16_f16 uZ;
+
+    shiftDist = softfloat_countLeadingZeros16( sig ) - 1;
+    exp -= shiftDist;
+    if ( (4 <= shiftDist) && ((unsigned int) exp < 0x1D) ) {
+        uZ.ui = packToF16UI( sign, sig ? exp : 0, sig<<(shiftDist - 4) );
+        return uZ.f;
+    } else {
+        return softfloat_roundPackToF16( sign, exp, sig<<shiftDist );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF32.c
new file mode 100644
index 000000000000..41128ed78282
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF32.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+float32_t
+ softfloat_normRoundPackToF32( bool sign, int_fast16_t exp, uint_fast32_t sig )
+{
+    int_fast8_t shiftDist;
+    union ui32_f32 uZ;
+
+    shiftDist = softfloat_countLeadingZeros32( sig ) - 1;
+    exp -= shiftDist;
+    if ( (7 <= shiftDist) && ((unsigned int) exp < 0xFD) ) {
+        uZ.ui = packToF32UI( sign, sig ? exp : 0, sig<<(shiftDist - 7) );
+        return uZ.f;
+    } else {
+        return softfloat_roundPackToF32( sign, exp, sig<<shiftDist );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF64.c
new file mode 100644
index 000000000000..1222479cd004
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normRoundPackToF64.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+float64_t
+ softfloat_normRoundPackToF64( bool sign, int_fast16_t exp, uint_fast64_t sig )
+{
+    int_fast8_t shiftDist;
+    union ui64_f64 uZ;
+
+    shiftDist = softfloat_countLeadingZeros64( sig ) - 1;
+    exp -= shiftDist;
+    if ( (10 <= shiftDist) && ((unsigned int) exp < 0x7FD) ) {
+        uZ.ui = packToF64UI( sign, sig ? exp : 0, sig<<(shiftDist - 10) );
+        return uZ.f;
+    } else {
+        return softfloat_roundPackToF64( sign, exp, sig<<shiftDist );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF128Sig.c b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF128Sig.c
new file mode 100644
index 000000000000..d14cbff7c3ab
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF128Sig.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+struct exp32_sig128
+ softfloat_normSubnormalF128Sig( uint_fast64_t sig64, uint_fast64_t sig0 )
+{
+    int_fast8_t shiftDist;
+    struct exp32_sig128 z;
+
+    if ( ! sig64 ) {
+        shiftDist = softfloat_countLeadingZeros64( sig0 ) - 15;
+        z.exp = -63 - shiftDist;
+        if ( shiftDist < 0 ) {
+            z.sig.v64 = sig0>>-shiftDist;
+            z.sig.v0  = sig0<<(shiftDist & 63);
+        } else {
+            z.sig.v64 = sig0<<shiftDist;
+            z.sig.v0  = 0;
+        }
+    } else {
+        shiftDist = softfloat_countLeadingZeros64( sig64 ) - 15;
+        z.exp = 1 - shiftDist;
+        z.sig = softfloat_shortShiftLeft128( sig64, sig0, shiftDist );
+    }
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF16Sig.c b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF16Sig.c
new file mode 100644
index 000000000000..9738b5ab2842
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF16Sig.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+struct exp8_sig16 softfloat_normSubnormalF16Sig( uint_fast16_t sig )
+{
+    int_fast8_t shiftDist;
+    struct exp8_sig16 z;
+
+    shiftDist = softfloat_countLeadingZeros16( sig ) - 5;
+    z.exp = 1 - shiftDist;
+    z.sig = sig<<shiftDist;
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF32Sig.c b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF32Sig.c
new file mode 100644
index 000000000000..5fd077f96434
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF32Sig.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+struct exp16_sig32 softfloat_normSubnormalF32Sig( uint_fast32_t sig )
+{
+    int_fast8_t shiftDist;
+    struct exp16_sig32 z;
+
+    shiftDist = softfloat_countLeadingZeros32( sig ) - 8;
+    z.exp = 1 - shiftDist;
+    z.sig = sig<<shiftDist;
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF64Sig.c b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF64Sig.c
new file mode 100644
index 000000000000..e1d06199289c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_normSubnormalF64Sig.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+
+struct exp16_sig64 softfloat_normSubnormalF64Sig( uint_fast64_t sig )
+{
+    int_fast8_t shiftDist;
+    struct exp16_sig64 z;
+
+    shiftDist = softfloat_countLeadingZeros64( sig ) - 11;
+    z.exp = 1 - shiftDist;
+    z.sig = sig<<shiftDist;
+    return z;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF128UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF128UI.c
new file mode 100644
index 000000000000..99cc198a8ac7
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF128UI.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Interpreting the unsigned integer formed from concatenating `uiA64' and
+| `uiA0' as a 128-bit floating-point value, and likewise interpreting the
+| unsigned integer formed from concatenating `uiB64' and `uiB0' as another
+| 128-bit floating-point value, and assuming at least on of these floating-
+| point values is a NaN, returns the bit pattern of the combined NaN result.
+| If either original floating-point value is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_propagateNaNF128UI(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0
+ )
+{
+    struct uint128 uiZ;
+
+    if (
+           softfloat_isSigNaNF128UI( uiA64, uiA0 )
+        || softfloat_isSigNaNF128UI( uiB64, uiB0 )
+    ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+    }
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+    return uiZ;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF16UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF16UI.c
new file mode 100644
index 000000000000..a166913383a5
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF16UI.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 16-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast16_t
+ softfloat_propagateNaNF16UI( uint_fast16_t uiA, uint_fast16_t uiB )
+{
+
+    if ( softfloat_isSigNaNF16UI( uiA ) || softfloat_isSigNaNF16UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+    }
+    return defaultNaNF16UI;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF32UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF32UI.c
new file mode 100644
index 000000000000..d815c278d8c8
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF32UI.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 32-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast32_t
+ softfloat_propagateNaNF32UI( uint_fast32_t uiA, uint_fast32_t uiB )
+{
+
+    if ( softfloat_isSigNaNF32UI( uiA ) || softfloat_isSigNaNF32UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+    }
+    return defaultNaNF32UI;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF64UI.c b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF64UI.c
new file mode 100644
index 000000000000..679432f9d115
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_propagateNaNF64UI.c
@@ -0,0 +1,58 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 64-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast64_t
+ softfloat_propagateNaNF64UI( uint_fast64_t uiA, uint_fast64_t uiB )
+{
+
+    if ( softfloat_isSigNaNF64UI( uiA ) || softfloat_isSigNaNF64UI( uiB ) ) {
+        softfloat_raiseFlags( softfloat_flag_invalid );
+    }
+    return defaultNaNF64UI;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_remStepMBy32.c b/arch/riscv/kernel/soft_vector/softfloat/s_remStepMBy32.c
new file mode 100644
index 000000000000..02d7acd4dea6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_remStepMBy32.c
@@ -0,0 +1,86 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_remStepMBy32
+
+void
+ softfloat_remStepMBy32(
+     uint_fast8_t size_words,
+     const uint32_t *remPtr,
+     uint_fast8_t dist,
+     const uint32_t *bPtr,
+     uint32_t q,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint64_t dwordProd;
+    uint32_t wordRem, wordShiftedRem, wordProd;
+    uint_fast8_t uNegDist, borrow;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    dwordProd = (uint64_t) bPtr[index] * q;
+    wordRem = remPtr[index];
+    wordShiftedRem = wordRem<<dist;
+    wordProd = dwordProd;
+    zPtr[index] = wordShiftedRem - wordProd;
+    if ( index != lastIndex ) {
+        uNegDist = -dist;
+        borrow = (wordShiftedRem < wordProd);
+        for (;;) {
+            wordShiftedRem = wordRem>>(uNegDist & 31);
+            index += wordIncr;
+            dwordProd = (uint64_t) bPtr[index] * q + (dwordProd>>32);
+            wordRem = remPtr[index];
+            wordShiftedRem |= wordRem<<dist;
+            wordProd = dwordProd;
+            zPtr[index] = wordShiftedRem - wordProd - borrow;
+            if ( index == lastIndex ) break;
+            borrow =
+                borrow ? (wordShiftedRem <= wordProd)
+                    : (wordShiftedRem < wordProd);
+        }
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundMToI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundMToI64.c
new file mode 100644
index 000000000000..791cc01d4bbc
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundMToI64.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t
+ softfloat_roundMToI64(
+     bool sign, uint32_t *extSigPtr, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint32_t sigExtra;
+    bool doIncrement;
+    uint64_t sig;
+    union { uint64_t ui; int64_t i; } uZ;
+    int64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    sigExtra = extSigPtr[indexWordLo( 3 )];
+    doIncrement = (0x80000000 <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    sig =
+        (uint64_t) extSigPtr[indexWord( 3, 2 )]<<32
+            | extSigPtr[indexWord( 3, 1 )];
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        if ( ! (sigExtra & 0x7FFFFFFF) && roundNearEven ) sig &= ~1;
+    }
+    uZ.ui = sign ? -sig : sig;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundMToUI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundMToUI64.c
new file mode 100644
index 000000000000..7f5ecdc09358
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundMToUI64.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ softfloat_roundMToUI64(
+     bool sign, uint32_t *extSigPtr, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint32_t sigExtra;
+    bool doIncrement;
+    uint64_t sig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    sigExtra = extSigPtr[indexWordLo( 3 )];
+    doIncrement = (0x80000000 <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    sig =
+        (uint64_t) extSigPtr[indexWord( 3, 2 )]<<32
+            | extSigPtr[indexWord( 3, 1 )];
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        if ( ! (sigExtra & 0x7FFFFFFF) && roundNearEven ) sig &= ~1;
+    }
+    if ( sign && sig ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sig;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToI64.c
new file mode 100644
index 000000000000..4f6bf0c90575
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToI64.c
@@ -0,0 +1,88 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t
+ softfloat_roundPackMToI64(
+     bool sign, uint32_t *extSigPtr, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint32_t sigExtra;
+    bool doIncrement;
+    uint64_t sig;
+    union { uint64_t ui; int64_t i; } uZ;
+    int64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    sigExtra = extSigPtr[indexWordLo( 3 )];
+    doIncrement = (0x80000000 <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    sig =
+        (uint64_t) extSigPtr[indexWord( 3, 2 )]<<32
+            | extSigPtr[indexWord( 3, 1 )];
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        if ( ! (sigExtra & 0x7FFFFFFF) && roundNearEven ) sig &= ~1;
+    }
+    uZ.ui = sign ? -sig : sig;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToUI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToUI64.c
new file mode 100644
index 000000000000..7db00901d9b4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackMToUI64.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ softfloat_roundPackMToUI64(
+     bool sign, uint32_t *extSigPtr, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint32_t sigExtra;
+    bool doIncrement;
+    uint64_t sig;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    sigExtra = extSigPtr[indexWordLo( 3 )];
+    doIncrement = (0x80000000 <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    sig =
+        (uint64_t) extSigPtr[indexWord( 3, 2 )]<<32
+            | extSigPtr[indexWord( 3, 1 )];
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        if ( ! (sigExtra & 0x7FFFFFFF) && roundNearEven ) sig &= ~1;
+    }
+    if ( sign && sig ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sig;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF128.c
new file mode 100644
index 000000000000..820914ef47c6
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF128.c
@@ -0,0 +1,171 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t
+ softfloat_roundPackToF128(
+     bool sign,
+     int_fast32_t exp,
+     uint_fast64_t sig64,
+     uint_fast64_t sig0,
+     uint_fast64_t sigExtra
+ )
+{
+    uint_fast8_t roundingMode;
+    bool roundNearEven, doIncrement, isTiny;
+    struct uint128_extra sig128Extra;
+    uint_fast64_t uiZ64, uiZ0;
+    struct uint128 sig128;
+    union ui128_f128 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundingMode = softfloat_roundingMode;
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x7FFD <= (uint32_t) exp ) {
+        if ( exp < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            isTiny =
+                   (softfloat_detectTininess
+                        == softfloat_tininess_beforeRounding)
+                || (exp < -1)
+                || ! doIncrement
+                || softfloat_lt128(
+                       sig64,
+                       sig0,
+                       UINT64_C( 0x0001FFFFFFFFFFFF ),
+                       UINT64_C( 0xFFFFFFFFFFFFFFFF )
+                   );
+            sig128Extra =
+                softfloat_shiftRightJam128Extra( sig64, sig0, sigExtra, -exp );
+            sig64 = sig128Extra.v.v64;
+            sig0  = sig128Extra.v.v0;
+            sigExtra = sig128Extra.extra;
+            exp = 0;
+            if ( isTiny && sigExtra ) {
+                softfloat_raiseFlags( softfloat_flag_underflow );
+            }
+            doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+            if (
+                   ! roundNearEven
+                && (roundingMode != softfloat_round_near_maxMag)
+            ) {
+                doIncrement =
+                    (roundingMode
+                         == (sign ? softfloat_round_min : softfloat_round_max))
+                        && sigExtra;
+            }
+        } else if (
+               (0x7FFD < exp)
+            || ((exp == 0x7FFD)
+                    && softfloat_eq128( 
+                           sig64,
+                           sig0,
+                           UINT64_C( 0x0001FFFFFFFFFFFF ),
+                           UINT64_C( 0xFFFFFFFFFFFFFFFF )
+                       )
+                    && doIncrement)
+        ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            softfloat_raiseFlags(
+                softfloat_flag_overflow | softfloat_flag_inexact );
+            if (
+                   roundNearEven
+                || (roundingMode == softfloat_round_near_maxMag)
+                || (roundingMode
+                        == (sign ? softfloat_round_min : softfloat_round_max))
+            ) {
+                uiZ64 = packToF128UI64( sign, 0x7FFF, 0 );
+                uiZ0  = 0;
+            } else {
+                uiZ64 =
+                    packToF128UI64(
+                        sign, 0x7FFE, UINT64_C( 0x0000FFFFFFFFFFFF ) );
+                uiZ0 = UINT64_C( 0xFFFFFFFFFFFFFFFF );
+            }
+            goto uiZ;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+#ifdef SOFTFLOAT_ROUND_ODD
+        if ( roundingMode == softfloat_round_odd ) {
+            sig0 |= 1;
+            goto packReturn;
+        }
+#endif
+    }
+    if ( doIncrement ) {
+        sig128 = softfloat_add128( sig64, sig0, 0, 1 );
+        sig64 = sig128.v64;
+        sig0 =
+            sig128.v0
+                & ~(uint64_t)
+                       (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                            & roundNearEven);
+    } else {
+        if ( ! (sig64 | sig0) ) exp = 0;
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ packReturn:
+    uiZ64 = packToF128UI64( sign, exp, sig64 );
+    uiZ0  = sig0;
+ uiZ:
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = uiZ0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF16.c
new file mode 100644
index 000000000000..fccc449b4556
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF16.c
@@ -0,0 +1,113 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t
+ softfloat_roundPackToF16( bool sign, int_fast16_t exp, uint_fast16_t sig )
+{
+    uint_fast8_t roundingMode;
+    bool roundNearEven;
+    uint_fast8_t roundIncrement, roundBits;
+    bool isTiny;
+    uint_fast16_t uiZ;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundingMode = softfloat_roundingMode;
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x8;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0xF
+                : 0;
+    }
+    roundBits = sig & 0xF;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x1D <= (unsigned int) exp ) {
+        if ( exp < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            isTiny =
+                (softfloat_detectTininess == softfloat_tininess_beforeRounding)
+                    || (exp < -1) || (sig + roundIncrement < 0x8000);
+            sig = softfloat_shiftRightJam32( sig, -exp );
+            exp = 0;
+            roundBits = sig & 0xF;
+            if ( isTiny && roundBits ) {
+                softfloat_raiseFlags( softfloat_flag_underflow );
+            }
+        } else if ( (0x1D < exp) || (0x8000 <= sig + roundIncrement) ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            softfloat_raiseFlags(
+                softfloat_flag_overflow | softfloat_flag_inexact );
+            uiZ = packToF16UI( sign, 0x1F, 0 ) - ! roundIncrement;
+            goto uiZ;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig + roundIncrement)>>4;
+    if ( roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+#ifdef SOFTFLOAT_ROUND_ODD
+        if ( roundingMode == softfloat_round_odd ) {
+            sig |= 1;
+            goto packReturn;
+        }
+#endif
+    }
+    sig &= ~(uint_fast16_t) (! (roundBits ^ 8) & roundNearEven);
+    if ( ! sig ) exp = 0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ packReturn:
+    uiZ = packToF16UI( sign, exp, sig );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF32.c
new file mode 100644
index 000000000000..fa22076504c1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF32.c
@@ -0,0 +1,113 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t
+ softfloat_roundPackToF32( bool sign, int_fast16_t exp, uint_fast32_t sig )
+{
+    uint_fast8_t roundingMode;
+    bool roundNearEven;
+    uint_fast8_t roundIncrement, roundBits;
+    bool isTiny;
+    uint_fast32_t uiZ;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundingMode = softfloat_roundingMode;
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x40;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0x7F
+                : 0;
+    }
+    roundBits = sig & 0x7F;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0xFD <= (unsigned int) exp ) {
+        if ( exp < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            isTiny =
+                (softfloat_detectTininess == softfloat_tininess_beforeRounding)
+                    || (exp < -1) || (sig + roundIncrement < 0x80000000);
+            sig = softfloat_shiftRightJam32( sig, -exp );
+            exp = 0;
+            roundBits = sig & 0x7F;
+            if ( isTiny && roundBits ) {
+                softfloat_raiseFlags( softfloat_flag_underflow );
+            }
+        } else if ( (0xFD < exp) || (0x80000000 <= sig + roundIncrement) ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            softfloat_raiseFlags(
+                softfloat_flag_overflow | softfloat_flag_inexact );
+            uiZ = packToF32UI( sign, 0xFF, 0 ) - ! roundIncrement;
+            goto uiZ;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig + roundIncrement)>>7;
+    if ( roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+#ifdef SOFTFLOAT_ROUND_ODD
+        if ( roundingMode == softfloat_round_odd ) {
+            sig |= 1;
+            goto packReturn;
+        }
+#endif
+    }
+    sig &= ~(uint_fast32_t) (! (roundBits ^ 0x40) & roundNearEven);
+    if ( ! sig ) exp = 0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ packReturn:
+    uiZ = packToF32UI( sign, exp, sig );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF64.c
new file mode 100644
index 000000000000..1a3b8debb803
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToF64.c
@@ -0,0 +1,117 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t
+ softfloat_roundPackToF64( bool sign, int_fast16_t exp, uint_fast64_t sig )
+{
+    uint_fast8_t roundingMode;
+    bool roundNearEven;
+    uint_fast16_t roundIncrement, roundBits;
+    bool isTiny;
+    uint_fast64_t uiZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundingMode = softfloat_roundingMode;
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x200;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0x3FF
+                : 0;
+    }
+    roundBits = sig & 0x3FF;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    if ( 0x7FD <= (uint16_t) exp ) {
+        if ( exp < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            isTiny =
+                (softfloat_detectTininess == softfloat_tininess_beforeRounding)
+                    || (exp < -1)
+                    || (sig + roundIncrement < UINT64_C( 0x8000000000000000 ));
+            sig = softfloat_shiftRightJam64( sig, -exp );
+            exp = 0;
+            roundBits = sig & 0x3FF;
+            if ( isTiny && roundBits ) {
+                softfloat_raiseFlags( softfloat_flag_underflow );
+            }
+        } else if (
+            (0x7FD < exp)
+                || (UINT64_C( 0x8000000000000000 ) <= sig + roundIncrement)
+        ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            softfloat_raiseFlags(
+                softfloat_flag_overflow | softfloat_flag_inexact );
+            uiZ = packToF64UI( sign, 0x7FF, 0 ) - ! roundIncrement;
+            goto uiZ;
+        }
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    sig = (sig + roundIncrement)>>10;
+    if ( roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+#ifdef SOFTFLOAT_ROUND_ODD
+        if ( roundingMode == softfloat_round_odd ) {
+            sig |= 1;
+            goto packReturn;
+        }
+#endif
+    }
+    sig &= ~(uint_fast64_t) (! (roundBits ^ 0x200) & roundNearEven);
+    if ( ! sig ) exp = 0;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ packReturn:
+    uiZ = packToF64UI( sign, exp, sig );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI32.c
new file mode 100644
index 000000000000..e29d8b3f1065
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t
+ softfloat_roundPackToI32(
+     bool sign, uint_fast64_t sig, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint_fast8_t roundIncrement, roundBits;
+    uint_fast32_t sig32;
+    union { uint32_t ui; int32_t i; } uZ;
+    int_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x40;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0x7F
+                : 0;
+    }
+    roundBits = sig & 0x7F;
+    sig += roundIncrement;
+    if ( sig & UINT64_C( 0xFFFFFF8000000000 ) ) goto invalid;
+    sig32 = sig>>7;
+    sig32 &= ~(uint_fast32_t) (! (roundBits ^ 0x40) & roundNearEven);
+    uZ.ui = sign ? -sig32 : sig32;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI64.c
new file mode 100644
index 000000000000..7a4af767feb9
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToI64.c
@@ -0,0 +1,89 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t
+ softfloat_roundPackToI64(
+     bool sign,
+     uint_fast64_t sig,
+     uint_fast64_t sigExtra,
+     uint_fast8_t roundingMode,
+     bool exact
+ )
+{
+    bool roundNearEven, doIncrement;
+    union { uint64_t ui; int64_t i; } uZ;
+    int_fast64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        sig &=
+            ~(uint_fast64_t)
+                 (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                      & roundNearEven);
+    }
+    uZ.ui = sign ? -sig : sig;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI32.c
new file mode 100644
index 000000000000..43a5fbbdf26b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI32.c
@@ -0,0 +1,80 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t
+ softfloat_roundPackToUI32(
+     bool sign, uint_fast64_t sig, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint_fast8_t roundIncrement, roundBits;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x40;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0x7F
+                : 0;
+    }
+    roundBits = sig & 0x7F;
+    sig += roundIncrement;
+    if ( sig & UINT64_C( 0xFFFFFF8000000000 ) ) goto invalid;
+    z = sig>>7;
+    z &= ~(uint_fast32_t) (! (roundBits ^ 0x40) & roundNearEven);
+    if ( sign && z ) goto invalid;
+    if ( exact && roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI64.c
new file mode 100644
index 000000000000..e6a748244d8a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundPackToUI64.c
@@ -0,0 +1,85 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3a+, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ softfloat_roundPackToUI64(
+     bool sign,
+     uint_fast64_t sig,
+     uint_fast64_t sigExtra,
+     uint_fast8_t roundingMode,
+     bool exact
+ )
+{
+    bool roundNearEven, doIncrement;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        sig &=
+            ~(uint_fast64_t)
+                 (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                      & roundNearEven);
+    }
+    if ( sign && sig ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sig;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundToI32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundToI32.c
new file mode 100644
index 000000000000..a9e186c0807d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundToI32.c
@@ -0,0 +1,84 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast32_t
+ softfloat_roundToI32(
+     bool sign, uint_fast64_t sig, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint_fast16_t roundIncrement, roundBits;
+    uint_fast32_t sig32;
+    union { uint32_t ui; int32_t i; } uZ;
+    int_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x800;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0xFFF
+                : 0;
+    }
+    roundBits = sig & 0xFFF;
+    sig += roundIncrement;
+    if ( sig & UINT64_C( 0xFFFFF00000000000 ) ) goto invalid;
+    sig32 = sig>>12;
+    sig32 &= ~(uint_fast32_t) (! (roundBits ^ 0x800) & roundNearEven);
+    uZ.ui = sign ? -sig32 : sig32;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i32_fromNegOverflow : i32_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundToI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundToI64.c
new file mode 100644
index 000000000000..6ac4daa99c5f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundToI64.c
@@ -0,0 +1,89 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+int_fast64_t
+ softfloat_roundToI64(
+     bool sign,
+     uint_fast64_t sig,
+     uint_fast64_t sigExtra,
+     uint_fast8_t roundingMode,
+     bool exact
+ )
+{
+    bool roundNearEven, doIncrement;
+    union { uint64_t ui; int64_t i; } uZ;
+    int_fast64_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        sig &=
+            ~(uint_fast64_t)
+                 (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                      & roundNearEven);
+    }
+    uZ.ui = sign ? -sig : sig;
+    z = uZ.i;
+    if ( z && ((z < 0) ^ sign) ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? i64_fromNegOverflow : i64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI32.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI32.c
new file mode 100644
index 000000000000..fabd74552d18
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI32.c
@@ -0,0 +1,80 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast32_t
+ softfloat_roundToUI32(
+     bool sign, uint_fast64_t sig, uint_fast8_t roundingMode, bool exact )
+{
+    bool roundNearEven;
+    uint_fast16_t roundIncrement, roundBits;
+    uint_fast32_t z;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    roundIncrement = 0x800;
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        roundIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                ? 0xFFF
+                : 0;
+    }
+    roundBits = sig & 0xFFF;
+    sig += roundIncrement;
+    if ( sig & UINT64_C( 0xFFFFF00000000000 ) ) goto invalid;
+    z = sig>>12;
+    z &= ~(uint_fast32_t) (! (roundBits ^ 0x800) & roundNearEven);
+    if ( sign && z ) goto invalid;
+    if ( exact && roundBits ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return z;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui32_fromNegOverflow : ui32_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI64.c b/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI64.c
new file mode 100644
index 000000000000..fe6c52968540
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_roundToUI64.c
@@ -0,0 +1,85 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+uint_fast64_t
+ softfloat_roundToUI64(
+     bool sign,
+     uint_fast64_t sig,
+     uint_fast64_t sigExtra,
+     uint_fast8_t roundingMode,
+     bool exact
+ )
+{
+    bool roundNearEven, doIncrement;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    roundNearEven = (roundingMode == softfloat_round_near_even);
+    doIncrement = (UINT64_C( 0x8000000000000000 ) <= sigExtra);
+    if ( ! roundNearEven && (roundingMode != softfloat_round_near_maxMag) ) {
+        doIncrement =
+            (roundingMode
+                 == (sign ? softfloat_round_min : softfloat_round_max))
+                && sigExtra;
+    }
+    if ( doIncrement ) {
+        ++sig;
+        if ( ! sig ) goto invalid;
+        sig &=
+            ~(uint_fast64_t)
+                 (! (sigExtra & UINT64_C( 0x7FFFFFFFFFFFFFFF ))
+                      & roundNearEven);
+    }
+    if ( sign && sig ) goto invalid;
+    if ( exact && sigExtra ) {
+        softfloat_exceptionFlags |= softfloat_flag_inexact;
+    }
+    return sig;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ invalid:
+    softfloat_raiseFlags( softfloat_flag_invalid );
+    return sign ? ui64_fromNegOverflow : ui64_fromPosOverflow;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128.c
new file mode 100644
index 000000000000..3c5127ac29f4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128.c
@@ -0,0 +1,69 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shiftRightJam128
+
+struct uint128
+ softfloat_shiftRightJam128( uint64_t a64, uint64_t a0, uint_fast32_t dist )
+{
+    uint_fast8_t u8NegDist;
+    struct uint128 z;
+
+    if ( dist < 64 ) {
+        u8NegDist = -dist;
+        z.v64 = a64>>dist;
+        z.v0 =
+            a64<<(u8NegDist & 63) | a0>>dist
+                | ((uint64_t) (a0<<(u8NegDist & 63)) != 0);
+    } else {
+        z.v64 = 0;
+        z.v0 =
+            (dist < 127)
+                ? a64>>(dist & 63)
+                      | (((a64 & (((uint_fast64_t) 1<<(dist & 63)) - 1)) | a0)
+                             != 0)
+                : ((a64 | a0) != 0);
+    }
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128Extra.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128Extra.c
new file mode 100644
index 000000000000..2fa0d1de2861
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam128Extra.c
@@ -0,0 +1,77 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shiftRightJam128Extra
+
+struct uint128_extra
+ softfloat_shiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast32_t dist )
+{
+    uint_fast8_t u8NegDist;
+    struct uint128_extra z;
+
+    u8NegDist = -dist;
+    if ( dist < 64 ) {
+        z.v.v64 = a64>>dist;
+        z.v.v0 = a64<<(u8NegDist & 63) | a0>>dist;
+        z.extra = a0<<(u8NegDist & 63);
+    } else {
+        z.v.v64 = 0;
+        if ( dist == 64 ) {
+            z.v.v0 = a64;
+            z.extra = a0;
+        } else {
+            extra |= a0;
+            if ( dist < 128 ) {
+                z.v.v0 = a64>>(dist & 63);
+                z.extra = a64<<(u8NegDist & 63);
+            } else {
+                z.v.v0 = 0;
+                z.extra = (dist == 128) ? a64 : (a64 != 0);
+            }
+        }
+    }
+    z.extra |= (extra != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam256M.c
new file mode 100644
index 000000000000..7080209cfa02
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam256M.c
@@ -0,0 +1,126 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shiftRightJam256M
+
+static
+ void
+  softfloat_shortShiftRightJamM(
+      uint_fast8_t size_words,
+      const uint64_t *aPtr,
+      uint_fast8_t dist,
+      uint64_t *zPtr
+  )
+{
+    uint_fast8_t uNegDist;
+    unsigned int index, lastIndex;
+    uint64_t partWordZ, wordA;
+
+    uNegDist = -dist;
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    wordA = aPtr[index];
+    partWordZ = wordA>>dist;
+    if ( partWordZ<<dist != wordA ) partWordZ |= 1;
+    while ( index != lastIndex ) {
+        wordA = aPtr[index + wordIncr];
+        zPtr[index] = wordA<<(uNegDist & 63) | partWordZ;
+        index += wordIncr;
+        partWordZ = wordA>>dist;
+    }
+    zPtr[index] = partWordZ;
+
+}
+
+void
+ softfloat_shiftRightJam256M(
+     const uint64_t *aPtr, uint_fast32_t dist, uint64_t *zPtr )
+{
+    uint64_t wordJam;
+    uint_fast32_t wordDist;
+    uint64_t *ptr;
+    uint_fast8_t i, innerDist;
+
+    wordJam = 0;
+    wordDist = dist>>6;
+    if ( wordDist ) {
+        if ( 4 < wordDist ) wordDist = 4;
+        ptr = (uint64_t *) (aPtr + indexMultiwordLo( 4, wordDist ));
+        i = wordDist;
+        do {
+            wordJam = *ptr++;
+            if ( wordJam ) break;
+            --i;
+        } while ( i );
+        ptr = zPtr;
+    }
+    if ( wordDist < 4 ) {
+        aPtr += indexMultiwordHiBut( 4, wordDist );
+        innerDist = dist & 63;
+        if ( innerDist ) {
+            softfloat_shortShiftRightJamM(
+                4 - wordDist,
+                aPtr,
+                innerDist,
+                zPtr + indexMultiwordLoBut( 4, wordDist )
+            );
+            if ( ! wordDist ) goto wordJam;
+        } else {
+            aPtr += indexWordLo( 4 - wordDist );
+            ptr = zPtr + indexWordLo( 4 );
+            for ( i = 4 - wordDist; i; --i ) {
+                *ptr = *aPtr;
+                aPtr += wordIncr;
+                ptr += wordIncr;
+            }
+        }
+        ptr = zPtr + indexMultiwordHi( 4, wordDist );
+    }
+    do {
+        *ptr++ = 0;
+        --wordDist;
+    } while ( wordDist );
+ wordJam:
+    if ( wordJam ) zPtr[indexWordLo( 4 )] |= 1;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam32.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam32.c
new file mode 100644
index 000000000000..291c5db8fa6c
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam32.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_shiftRightJam32
+
+uint32_t softfloat_shiftRightJam32( uint32_t a, uint_fast16_t dist )
+{
+
+    return
+        (dist < 31) ? a>>dist | ((uint32_t) (a<<(-dist & 31)) != 0) : (a != 0);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64.c
new file mode 100644
index 000000000000..1d5d94d70b10
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64.c
@@ -0,0 +1,51 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_shiftRightJam64
+
+uint64_t softfloat_shiftRightJam64( uint64_t a, uint_fast32_t dist )
+{
+
+    return
+        (dist < 63) ? a>>dist | ((uint64_t) (a<<(-dist & 63)) != 0) : (a != 0);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64Extra.c b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64Extra.c
new file mode 100644
index 000000000000..891479045dda
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shiftRightJam64Extra.c
@@ -0,0 +1,62 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shiftRightJam64Extra
+
+struct uint64_extra
+ softfloat_shiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast32_t dist )
+{
+    struct uint64_extra z;
+
+    if ( dist < 64 ) {
+        z.v = a>>dist;
+        z.extra = a<<(-dist & 63);
+    } else {
+        z.v = 0;
+        z.extra = (dist == 64) ? a : (a != 0);
+    }
+    z.extra |= (extra != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft128.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft128.c
new file mode 100644
index 000000000000..ba0716e73fff
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft128.c
@@ -0,0 +1,55 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftLeft128
+
+struct uint128
+ softfloat_shortShiftLeft128( uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    struct uint128 z;
+
+    z.v64 = a64<<dist | a0>>(-dist & 63);
+    z.v0 = a0<<dist;
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft64To96M.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft64To96M.c
new file mode 100644
index 000000000000..725503e46d1f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftLeft64To96M.c
@@ -0,0 +1,56 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftLeft64To96M
+
+void
+ softfloat_shortShiftLeft64To96M(
+     uint64_t a, uint_fast8_t dist, uint32_t *zPtr )
+{
+
+    zPtr[indexWord( 3, 0 )] = (uint32_t) a<<dist;
+    a >>= 32 - dist;
+    zPtr[indexWord( 3, 2 )] = a>>32;
+    zPtr[indexWord( 3, 1 )] = a;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRight128.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRight128.c
new file mode 100644
index 000000000000..6b1894f7231d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRight128.c
@@ -0,0 +1,55 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRight128
+
+struct uint128
+ softfloat_shortShiftRight128( uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    struct uint128 z;
+
+    z.v64 = a64>>dist;
+    z.v0 = a64<<(-dist & 63) | a0>>dist;
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightExtendM.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightExtendM.c
new file mode 100644
index 000000000000..ad793318b0da
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightExtendM.c
@@ -0,0 +1,73 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightExtendM
+
+void
+ softfloat_shortShiftRightExtendM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ )
+{
+    uint_fast8_t uNegDist;
+    unsigned int indexA, lastIndexA;
+    uint32_t partWordZ, wordA;
+
+    uNegDist = -dist;
+    indexA = indexWordLo( size_words );
+    lastIndexA = indexWordHi( size_words );
+    zPtr += indexWordLo( size_words + 1 );
+    partWordZ = 0;
+    for (;;) {
+        wordA = aPtr[indexA];
+        *zPtr = wordA<<(uNegDist & 31) | partWordZ;
+        zPtr += wordIncr;
+        partWordZ = wordA>>dist;
+        if ( indexA == lastIndexA ) break;
+        indexA += wordIncr;
+    }
+    *zPtr = partWordZ;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128.c
new file mode 100644
index 000000000000..61b0836e2175
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightJam128
+
+struct uint128
+ softfloat_shortShiftRightJam128(
+     uint64_t a64, uint64_t a0, uint_fast8_t dist )
+{
+    uint_fast8_t uNegDist;
+    struct uint128 z;
+
+    uNegDist = -dist;
+    z.v64 = a64>>dist;
+    z.v0 =
+        a64<<(uNegDist & 63) | a0>>dist
+            | ((uint64_t) (a0<<(uNegDist & 63)) != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128Extra.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128Extra.c
new file mode 100644
index 000000000000..336e5d11679b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam128Extra.c
@@ -0,0 +1,59 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightJam128Extra
+
+struct uint128_extra
+ softfloat_shortShiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast8_t dist )
+{
+    uint_fast8_t uNegDist;
+    struct uint128_extra z;
+
+    uNegDist = -dist;
+    z.v.v64 = a64>>dist;
+    z.v.v0 = a64<<(uNegDist & 63) | a0>>dist;
+    z.extra = a0<<(uNegDist & 63) | (extra != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64.c
new file mode 100644
index 000000000000..bb7dd375ad20
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64.c
@@ -0,0 +1,50 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+
+#ifndef softfloat_shortShiftRightJam64
+
+uint64_t softfloat_shortShiftRightJam64( uint64_t a, uint_fast8_t dist )
+{
+
+    return a>>dist | ((a & (((uint_fast64_t) 1<<dist) - 1)) != 0);
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64Extra.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64Extra.c
new file mode 100644
index 000000000000..3bfe6720d9a4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightJam64Extra.c
@@ -0,0 +1,56 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightJam64Extra
+
+struct uint64_extra
+ softfloat_shortShiftRightJam64Extra(
+     uint64_t a, uint64_t extra, uint_fast8_t dist )
+{
+    struct uint64_extra z;
+
+    z.v = a>>dist;
+    z.extra = a<<(-dist & 63) | (extra != 0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightM.c b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightM.c
new file mode 100644
index 000000000000..d972fcc42868
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_shortShiftRightM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_shortShiftRightM
+
+void
+ softfloat_shortShiftRightM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ )
+{
+    uint_fast8_t uNegDist;
+    unsigned int index, lastIndex;
+    uint32_t partWordZ, wordA;
+
+    uNegDist = -dist;
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    partWordZ = aPtr[index]>>dist;
+    while ( index != lastIndex ) {
+        wordA = aPtr[index + wordIncr];
+        zPtr[index] = wordA<<(uNegDist & 31) | partWordZ;
+        index += wordIncr;
+        partWordZ = wordA>>dist;
+    }
+    zPtr[index] = partWordZ;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_sub128.c b/arch/riscv/kernel/soft_vector/softfloat/s_sub128.c
new file mode 100644
index 000000000000..19bdff75b37f
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_sub128.c
@@ -0,0 +1,55 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_sub128
+
+struct uint128
+ softfloat_sub128( uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0 )
+{
+    struct uint128 z;
+
+    z.v0 = a0 - b0;
+    z.v64 = a64 - b64 - (a0 < b0);
+    return z;
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_sub1XM.c b/arch/riscv/kernel/soft_vector/softfloat/s_sub1XM.c
new file mode 100644
index 000000000000..a700a6348a55
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_sub1XM.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_sub1XM
+
+void softfloat_sub1XM( uint_fast8_t size_words, uint32_t *zPtr )
+{
+    unsigned int index, lastIndex;
+    uint32_t wordA;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    for (;;) {
+        wordA = zPtr[index];
+        zPtr[index] = wordA - 1;
+        if ( wordA || (index == lastIndex) ) break;
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_sub256M.c b/arch/riscv/kernel/soft_vector/softfloat/s_sub256M.c
new file mode 100644
index 000000000000..f6b5a0219086
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_sub256M.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_sub256M
+
+void
+ softfloat_sub256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr )
+{
+    unsigned int index;
+    uint_fast8_t borrow;
+    uint64_t wordA, wordB;
+
+    index = indexWordLo( 4 );
+    borrow = 0;
+    for (;;) {
+        wordA = aPtr[index];
+        wordB = bPtr[index];
+        zPtr[index] = wordA - wordB - borrow;
+        if ( index == indexWordHi( 4 ) ) break;
+        borrow = borrow ? (wordA <= wordB) : (wordA < wordB);
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subM.c b/arch/riscv/kernel/soft_vector/softfloat/s_subM.c
new file mode 100644
index 000000000000..6c19f92a125d
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subM.c
@@ -0,0 +1,70 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_subM
+
+void
+ softfloat_subM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ )
+{
+    unsigned int index, lastIndex;
+    uint_fast8_t borrow;
+    uint32_t wordA, wordB;
+
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    borrow = 0;
+    for (;;) {
+        wordA = aPtr[index];
+        wordB = bPtr[index];
+        zPtr[index] = wordA - wordB - borrow;
+        if ( index == lastIndex ) break;
+        borrow = borrow ? (wordA <= wordB) : (wordA < wordB);
+        index += wordIncr;
+    }
+
+}
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF128.c b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF128.c
new file mode 100644
index 000000000000..a79ebc898760
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF128.c
@@ -0,0 +1,139 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float128_t
+ softfloat_subMagsF128(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0,
+     bool signZ
+ )
+{
+    int_fast32_t expA;
+    struct uint128 sigA;
+    int_fast32_t expB;
+    struct uint128 sigB, sigZ;
+    int_fast32_t expDiff, expZ;
+    struct uint128 uiZ;
+    union ui128_f128 uZ;
+
+    expA = expF128UI64( uiA64 );
+    sigA.v64 = fracF128UI64( uiA64 );
+    sigA.v0  = uiA0;
+    expB = expF128UI64( uiB64 );
+    sigB.v64 = fracF128UI64( uiB64 );
+    sigB.v0  = uiB0;
+    sigA = softfloat_shortShiftLeft128( sigA.v64, sigA.v0, 4 );
+    sigB = softfloat_shortShiftLeft128( sigB.v64, sigB.v0, 4 );
+    expDiff = expA - expB;
+    if ( 0 < expDiff ) goto expABigger;
+    if ( expDiff < 0 ) goto expBBigger;
+    if ( expA == 0x7FFF ) {
+        if ( sigA.v64 | sigA.v0 | sigB.v64 | sigB.v0 ) goto propagateNaN;
+        softfloat_raiseFlags( softfloat_flag_invalid );
+        uiZ.v64 = defaultNaNF128UI64;
+        uiZ.v0  = defaultNaNF128UI0;
+        goto uiZ;
+    }
+    expZ = expA;
+    if ( ! expZ ) expZ = 1;
+    if ( sigB.v64 < sigA.v64 ) goto aBigger;
+    if ( sigA.v64 < sigB.v64 ) goto bBigger;
+    if ( sigB.v0 < sigA.v0 ) goto aBigger;
+    if ( sigA.v0 < sigB.v0 ) goto bBigger;
+    uiZ.v64 =
+        packToF128UI64(
+            (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+    uiZ.v0 = 0;
+    goto uiZ;
+ expBBigger:
+    if ( expB == 0x7FFF ) {
+        if ( sigB.v64 | sigB.v0 ) goto propagateNaN;
+        uiZ.v64 = packToF128UI64( signZ ^ 1, 0x7FFF, 0 );
+        uiZ.v0  = 0;
+        goto uiZ;
+    }
+    if ( expA ) {
+        sigA.v64 |= UINT64_C( 0x0010000000000000 );
+    } else {
+        ++expDiff;
+        if ( ! expDiff ) goto newlyAlignedBBigger;
+    }
+    sigA = softfloat_shiftRightJam128( sigA.v64, sigA.v0, -expDiff );
+ newlyAlignedBBigger:
+    expZ = expB;
+    sigB.v64 |= UINT64_C( 0x0010000000000000 );
+ bBigger:
+    signZ = ! signZ;
+    sigZ = softfloat_sub128( sigB.v64, sigB.v0, sigA.v64, sigA.v0 );
+    goto normRoundPack;
+ expABigger:
+    if ( expA == 0x7FFF ) {
+        if ( sigA.v64 | sigA.v0 ) goto propagateNaN;
+        uiZ.v64 = uiA64;
+        uiZ.v0  = uiA0;
+        goto uiZ;
+    }
+    if ( expB ) {
+        sigB.v64 |= UINT64_C( 0x0010000000000000 );
+    } else {
+        --expDiff;
+        if ( ! expDiff ) goto newlyAlignedABigger;
+    }
+    sigB = softfloat_shiftRightJam128( sigB.v64, sigB.v0, expDiff );
+ newlyAlignedABigger:
+    expZ = expA;
+    sigA.v64 |= UINT64_C( 0x0010000000000000 );
+ aBigger:
+    sigZ = softfloat_sub128( sigA.v64, sigA.v0, sigB.v64, sigB.v0 );
+ normRoundPack:
+    return softfloat_normRoundPackToF128( signZ, expZ - 5, sigZ.v64, sigZ.v0 );
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF128UI( uiA64, uiA0, uiB64, uiB0 );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF16.c b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF16.c
new file mode 100644
index 000000000000..09bd1cfa66a3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF16.c
@@ -0,0 +1,187 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float16_t softfloat_subMagsF16( uint_fast16_t uiA, uint_fast16_t uiB )
+{
+    int_fast8_t expA;
+    uint_fast16_t sigA;
+    int_fast8_t expB;
+    uint_fast16_t sigB;
+    int_fast8_t expDiff;
+    uint_fast16_t uiZ;
+    int_fast16_t sigDiff;
+    bool signZ;
+    int_fast8_t shiftDist, expZ;
+    uint_fast16_t sigZ, sigX, sigY;
+    uint_fast32_t sig32Z;
+    int_fast8_t roundingMode;
+    union ui16_f16 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF16UI( uiA );
+    sigA = fracF16UI( uiA );
+    expB = expF16UI( uiB );
+    sigB = fracF16UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expA == 0x1F ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            uiZ = defaultNaNF16UI;
+            goto uiZ;
+        }
+        sigDiff = sigA - sigB;
+        if ( ! sigDiff ) {
+            uiZ =
+                packToF16UI(
+                    (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+            goto uiZ;
+        }
+        if ( expA ) --expA;
+        signZ = signF16UI( uiA );
+        if ( sigDiff < 0 ) {
+            signZ = ! signZ;
+            sigDiff = -sigDiff;
+        }
+        shiftDist = softfloat_countLeadingZeros16( sigDiff ) - 5;
+        expZ = expA - shiftDist;
+        if ( expZ < 0 ) {
+            shiftDist = expA;
+            expZ = 0;
+        }
+        sigZ = sigDiff<<shiftDist;
+        goto pack;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        signZ = signF16UI( uiA );
+        if ( expDiff < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            signZ = ! signZ;
+            if ( expB == 0x1F ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF16UI( signZ, 0x1F, 0 );
+                goto uiZ;
+            }
+            if ( expDiff <= -13 ) {
+                uiZ = packToF16UI( signZ, expB, sigB );
+                if ( expA | sigA ) goto subEpsilon;
+                goto uiZ;
+            }
+            expZ = expA + 19;
+            sigX = sigB | 0x0400;
+            sigY = sigA + (expA ? 0x0400 : sigA);
+            expDiff = -expDiff;
+        } else {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            uiZ = uiA;
+            if ( expA == 0x1F ) {
+                if ( sigA ) goto propagateNaN;
+                goto uiZ;
+            }
+            if ( 13 <= expDiff ) {
+                if ( expB | sigB ) goto subEpsilon;
+                goto uiZ;
+            }
+            expZ = expB + 19;
+            sigX = sigA | 0x0400;
+            sigY = sigB + (expB ? 0x0400 : sigB);
+        }
+        sig32Z = ((uint_fast32_t) sigX<<expDiff) - sigY;
+        shiftDist = softfloat_countLeadingZeros32( sig32Z ) - 1;
+        sig32Z <<= shiftDist;
+        expZ -= shiftDist;
+        sigZ = sig32Z>>16;
+        if ( sig32Z & 0xFFFF ) {
+            sigZ |= 1;
+        } else {
+            if ( ! (sigZ & 0xF) && ((unsigned int) expZ < 0x1E) ) {
+                sigZ >>= 4;
+                goto pack;
+            }
+        }
+        return softfloat_roundPackToF16( signZ, expZ, sigZ );
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ subEpsilon:
+    roundingMode = softfloat_roundingMode;
+    if ( roundingMode != softfloat_round_near_even ) {
+        if (
+            (roundingMode == softfloat_round_minMag)
+                || (roundingMode
+                        == (signF16UI( uiZ ) ? softfloat_round_max
+                                : softfloat_round_min))
+        ) {
+            --uiZ;
+        }
+#ifdef SOFTFLOAT_ROUND_ODD
+        else if ( roundingMode == softfloat_round_odd ) {
+            uiZ = (uiZ - 1) | 1;
+        }
+#endif
+    }
+    softfloat_exceptionFlags |= softfloat_flag_inexact;
+    goto uiZ;
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ pack:
+    uiZ = packToF16UI( signZ, expZ, sigZ );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF32.c b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF32.c
new file mode 100644
index 000000000000..539f7b7fc3e1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF32.c
@@ -0,0 +1,143 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float32_t softfloat_subMagsF32( uint_fast32_t uiA, uint_fast32_t uiB )
+{
+    int_fast16_t expA;
+    uint_fast32_t sigA;
+    int_fast16_t expB;
+    uint_fast32_t sigB;
+    int_fast16_t expDiff;
+    uint_fast32_t uiZ;
+    int_fast32_t sigDiff;
+    bool signZ;
+    int_fast8_t shiftDist;
+    int_fast16_t expZ;
+    uint_fast32_t sigX, sigY;
+    union ui32_f32 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF32UI( uiA );
+    sigA = fracF32UI( uiA );
+    expB = expF32UI( uiB );
+    sigB = fracF32UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expA == 0xFF ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            uiZ = defaultNaNF32UI;
+            goto uiZ;
+        }
+        sigDiff = sigA - sigB;
+        if ( ! sigDiff ) {
+            uiZ =
+                packToF32UI(
+                    (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+            goto uiZ;
+        }
+        if ( expA ) --expA;
+        signZ = signF32UI( uiA );
+        if ( sigDiff < 0 ) {
+            signZ = ! signZ;
+            sigDiff = -sigDiff;
+        }
+        shiftDist = softfloat_countLeadingZeros32( sigDiff ) - 8;
+        expZ = expA - shiftDist;
+        if ( expZ < 0 ) {
+            shiftDist = expA;
+            expZ = 0;
+        }
+        uiZ = packToF32UI( signZ, expZ, sigDiff<<shiftDist );
+        goto uiZ;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        signZ = signF32UI( uiA );
+        sigA <<= 7;
+        sigB <<= 7;
+        if ( expDiff < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            signZ = ! signZ;
+            if ( expB == 0xFF ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF32UI( signZ, 0xFF, 0 );
+                goto uiZ;
+            }
+            expZ = expB - 1;
+            sigX = sigB | 0x40000000;
+            sigY = sigA + (expA ? 0x40000000 : sigA);
+            expDiff = -expDiff;
+        } else {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            if ( expA == 0xFF ) {
+                if ( sigA ) goto propagateNaN;
+                uiZ = uiA;
+                goto uiZ;
+            }
+            expZ = expA - 1;
+            sigX = sigA | 0x40000000;
+            sigY = sigB + (expB ? 0x40000000 : sigB);
+        }
+        return
+            softfloat_normRoundPackToF32(
+                signZ, expZ, sigX - softfloat_shiftRightJam32( sigY, expDiff )
+            );
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF32UI( uiA, uiB );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF64.c b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF64.c
new file mode 100644
index 000000000000..c9a94c9d19e3
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/s_subMagsF64.c
@@ -0,0 +1,141 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+float64_t
+ softfloat_subMagsF64( uint_fast64_t uiA, uint_fast64_t uiB, bool signZ )
+{
+    int_fast16_t expA;
+    uint_fast64_t sigA;
+    int_fast16_t expB;
+    uint_fast64_t sigB;
+    int_fast16_t expDiff;
+    uint_fast64_t uiZ;
+    int_fast64_t sigDiff;
+    int_fast8_t shiftDist;
+    int_fast16_t expZ;
+    uint_fast64_t sigZ;
+    union ui64_f64 uZ;
+
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expA = expF64UI( uiA );
+    sigA = fracF64UI( uiA );
+    expB = expF64UI( uiB );
+    sigB = fracF64UI( uiB );
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+    expDiff = expA - expB;
+    if ( ! expDiff ) {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        if ( expA == 0x7FF ) {
+            if ( sigA | sigB ) goto propagateNaN;
+            softfloat_raiseFlags( softfloat_flag_invalid );
+            uiZ = defaultNaNF64UI;
+            goto uiZ;
+        }
+        sigDiff = sigA - sigB;
+        if ( ! sigDiff ) {
+            uiZ =
+                packToF64UI(
+                    (softfloat_roundingMode == softfloat_round_min), 0, 0 );
+            goto uiZ;
+        }
+        if ( expA ) --expA;
+        if ( sigDiff < 0 ) {
+            signZ = ! signZ;
+            sigDiff = -sigDiff;
+        }
+        shiftDist = softfloat_countLeadingZeros64( sigDiff ) - 11;
+        expZ = expA - shiftDist;
+        if ( expZ < 0 ) {
+            shiftDist = expA;
+            expZ = 0;
+        }
+        uiZ = packToF64UI( signZ, expZ, sigDiff<<shiftDist );
+        goto uiZ;
+    } else {
+        /*--------------------------------------------------------------------
+        *--------------------------------------------------------------------*/
+        sigA <<= 10;
+        sigB <<= 10;
+        if ( expDiff < 0 ) {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            signZ = ! signZ;
+            if ( expB == 0x7FF ) {
+                if ( sigB ) goto propagateNaN;
+                uiZ = packToF64UI( signZ, 0x7FF, 0 );
+                goto uiZ;
+            }
+            sigA += expA ? UINT64_C( 0x4000000000000000 ) : sigA;
+            sigA = softfloat_shiftRightJam64( sigA, -expDiff );
+            sigB |= UINT64_C( 0x4000000000000000 );
+            expZ = expB;
+            sigZ = sigB - sigA;
+        } else {
+            /*----------------------------------------------------------------
+            *----------------------------------------------------------------*/
+            if ( expA == 0x7FF ) {
+                if ( sigA ) goto propagateNaN;
+                uiZ = uiA;
+                goto uiZ;
+            }
+            sigB += expB ? UINT64_C( 0x4000000000000000 ) : sigB;
+            sigB = softfloat_shiftRightJam64( sigB, expDiff );
+            sigA |= UINT64_C( 0x4000000000000000 );
+            expZ = expA;
+            sigZ = sigA - sigB;
+        }
+        return softfloat_normRoundPackToF64( signZ, expZ - 1, sigZ );
+    }
+    /*------------------------------------------------------------------------
+    *------------------------------------------------------------------------*/
+ propagateNaN:
+    uiZ = softfloat_propagateNaNF64UI( uiA, uiB );
+ uiZ:
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/softfloat.h b/arch/riscv/kernel/soft_vector/softfloat/softfloat.h
new file mode 100644
index 000000000000..f47cc6af2d04
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/softfloat.h
@@ -0,0 +1,396 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+
+/*============================================================================
+| Note:  If SoftFloat is made available as a general library for programs to
+| use, it is strongly recommended that a platform-specific version of this
+| header, "softfloat.h", be created that folds in "softfloat_types.h" and that
+| eliminates all dependencies on compile-time macros.
+*============================================================================*/
+
+
+#ifndef softfloat_h
+#define softfloat_h 1
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "softfloat_types.h"
+
+#ifndef THREAD_LOCAL
+#define THREAD_LOCAL
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*----------------------------------------------------------------------------
+| Software floating-point underflow tininess-detection mode.
+*----------------------------------------------------------------------------*/
+extern THREAD_LOCAL uint_fast8_t softfloat_detectTininess;
+enum {
+    softfloat_tininess_beforeRounding = 0,
+    softfloat_tininess_afterRounding  = 1
+};
+
+/*----------------------------------------------------------------------------
+| Software floating-point rounding mode.  (Mode "odd" is supported only if
+| SoftFloat is compiled with macro 'SOFTFLOAT_ROUND_ODD' defined.)
+*----------------------------------------------------------------------------*/
+extern THREAD_LOCAL uint_fast8_t softfloat_roundingMode;
+enum {
+    softfloat_round_near_even   = 0,
+    softfloat_round_minMag      = 1,
+    softfloat_round_min         = 2,
+    softfloat_round_max         = 3,
+    softfloat_round_near_maxMag = 4,
+    softfloat_round_odd         = 5
+};
+
+/*----------------------------------------------------------------------------
+| Software floating-point exception flags.
+*----------------------------------------------------------------------------*/
+extern THREAD_LOCAL uint_fast8_t softfloat_exceptionFlags;
+enum {
+    softfloat_flag_inexact   =  1,
+    softfloat_flag_underflow =  2,
+    softfloat_flag_overflow  =  4,
+    softfloat_flag_infinite  =  8,
+    softfloat_flag_invalid   = 16
+};
+
+/*----------------------------------------------------------------------------
+| Routine to raise any or all of the software floating-point exception flags.
+*----------------------------------------------------------------------------*/
+void softfloat_raiseFlags( uint_fast8_t );
+
+/*----------------------------------------------------------------------------
+| Integer-to-floating-point conversion routines.
+*----------------------------------------------------------------------------*/
+float16_t ui32_to_f16( uint32_t );
+float32_t ui32_to_f32( uint32_t );
+float64_t ui32_to_f64( uint32_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t ui32_to_extF80( uint32_t );
+float128_t ui32_to_f128( uint32_t );
+#endif
+void ui32_to_extF80M( uint32_t, extFloat80_t * );
+void ui32_to_f128M( uint32_t, float128_t * );
+float16_t ui64_to_f16( uint64_t );
+float32_t ui64_to_f32( uint64_t );
+float64_t ui64_to_f64( uint64_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t ui64_to_extF80( uint64_t );
+float128_t ui64_to_f128( uint64_t );
+#endif
+void ui64_to_extF80M( uint64_t, extFloat80_t * );
+void ui64_to_f128M( uint64_t, float128_t * );
+float16_t i32_to_f16( int32_t );
+float32_t i32_to_f32( int32_t );
+float64_t i32_to_f64( int32_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t i32_to_extF80( int32_t );
+float128_t i32_to_f128( int32_t );
+#endif
+void i32_to_extF80M( int32_t, extFloat80_t * );
+void i32_to_f128M( int32_t, float128_t * );
+float16_t i64_to_f16( int64_t );
+float32_t i64_to_f32( int64_t );
+float64_t i64_to_f64( int64_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t i64_to_extF80( int64_t );
+float128_t i64_to_f128( int64_t );
+#endif
+void i64_to_extF80M( int64_t, extFloat80_t * );
+void i64_to_f128M( int64_t, float128_t * );
+
+/*----------------------------------------------------------------------------
+| 16-bit (half-precision) floating-point operations.
+*----------------------------------------------------------------------------*/
+uint_fast8_t f16_to_ui8( float16_t, uint_fast8_t, bool );
+uint_fast16_t f16_to_ui16( float16_t, uint_fast8_t, bool );
+uint_fast32_t f16_to_ui32( float16_t, uint_fast8_t, bool );
+uint_fast64_t f16_to_ui64( float16_t, uint_fast8_t, bool );
+int_fast8_t f16_to_i8( float16_t, uint_fast8_t, bool );
+int_fast16_t f16_to_i16( float16_t, uint_fast8_t, bool );
+int_fast32_t f16_to_i32( float16_t, uint_fast8_t, bool );
+int_fast64_t f16_to_i64( float16_t, uint_fast8_t, bool );
+uint_fast32_t f16_to_ui32_r_minMag( float16_t, bool );
+uint_fast64_t f16_to_ui64_r_minMag( float16_t, bool );
+int_fast32_t f16_to_i32_r_minMag( float16_t, bool );
+int_fast64_t f16_to_i64_r_minMag( float16_t, bool );
+float32_t f16_to_f32( float16_t );
+float64_t f16_to_f64( float16_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t f16_to_extF80( float16_t );
+float128_t f16_to_f128( float16_t );
+#endif
+void f16_to_extF80M( float16_t, extFloat80_t * );
+void f16_to_f128M( float16_t, float128_t * );
+float16_t f16_roundToInt( float16_t, uint_fast8_t, bool );
+float16_t f16_add( float16_t, float16_t );
+float16_t f16_sub( float16_t, float16_t );
+float16_t f16_max( float16_t, float16_t );
+float16_t f16_min( float16_t, float16_t );
+float16_t f16_mul( float16_t, float16_t );
+float16_t f16_mulAdd( float16_t, float16_t, float16_t );
+float16_t f16_div( float16_t, float16_t );
+float16_t f16_rem( float16_t, float16_t );
+float16_t f16_sqrt( float16_t );
+bool f16_eq( float16_t, float16_t );
+bool f16_le( float16_t, float16_t );
+bool f16_lt( float16_t, float16_t );
+bool f16_eq_signaling( float16_t, float16_t );
+bool f16_le_quiet( float16_t, float16_t );
+bool f16_lt_quiet( float16_t, float16_t );
+bool f16_isSignalingNaN( float16_t );
+uint_fast16_t f16_classify( float16_t );
+
+/*----------------------------------------------------------------------------
+| 32-bit (single-precision) floating-point operations.
+*----------------------------------------------------------------------------*/
+uint_fast16_t f32_to_ui16( float32_t, uint_fast8_t, bool );
+uint_fast32_t f32_to_ui32( float32_t, uint_fast8_t, bool );
+uint_fast64_t f32_to_ui64( float32_t, uint_fast8_t, bool );
+int_fast16_t f32_to_i16( float32_t, uint_fast8_t, bool );
+int_fast32_t f32_to_i32( float32_t, uint_fast8_t, bool );
+int_fast64_t f32_to_i64( float32_t, uint_fast8_t, bool );
+uint_fast32_t f32_to_ui32_r_minMag( float32_t, bool );
+uint_fast64_t f32_to_ui64_r_minMag( float32_t, bool );
+int_fast32_t f32_to_i32_r_minMag( float32_t, bool );
+int_fast64_t f32_to_i64_r_minMag( float32_t, bool );
+float16_t f32_to_f16( float32_t );
+float64_t f32_to_f64( float32_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t f32_to_extF80( float32_t );
+float128_t f32_to_f128( float32_t );
+#endif
+void f32_to_extF80M( float32_t, extFloat80_t * );
+void f32_to_f128M( float32_t, float128_t * );
+float32_t f32_roundToInt( float32_t, uint_fast8_t, bool );
+float32_t f32_add( float32_t, float32_t );
+float32_t f32_sub( float32_t, float32_t );
+float32_t f32_max( float32_t, float32_t );
+float32_t f32_min( float32_t, float32_t );
+float32_t f32_mul( float32_t, float32_t );
+float32_t f32_mulAdd( float32_t, float32_t, float32_t );
+float32_t f32_div( float32_t, float32_t );
+float32_t f32_rem( float32_t, float32_t );
+float32_t f32_sqrt( float32_t );
+bool f32_eq( float32_t, float32_t );
+bool f32_le( float32_t, float32_t );
+bool f32_lt( float32_t, float32_t );
+bool f32_eq_signaling( float32_t, float32_t );
+bool f32_le_quiet( float32_t, float32_t );
+bool f32_lt_quiet( float32_t, float32_t );
+bool f32_isSignalingNaN( float32_t );
+uint_fast16_t f32_classify( float32_t );
+
+/*----------------------------------------------------------------------------
+| 64-bit (double-precision) floating-point operations.
+*----------------------------------------------------------------------------*/
+uint_fast32_t f64_to_ui32( float64_t, uint_fast8_t, bool );
+uint_fast64_t f64_to_ui64( float64_t, uint_fast8_t, bool );
+int_fast32_t f64_to_i32( float64_t, uint_fast8_t, bool );
+int_fast64_t f64_to_i64( float64_t, uint_fast8_t, bool );
+uint_fast32_t f64_to_ui32_r_minMag( float64_t, bool );
+uint_fast64_t f64_to_ui64_r_minMag( float64_t, bool );
+int_fast32_t f64_to_i32_r_minMag( float64_t, bool );
+int_fast64_t f64_to_i64_r_minMag( float64_t, bool );
+float16_t f64_to_f16( float64_t );
+float32_t f64_to_f32( float64_t );
+#ifdef SOFTFLOAT_FAST_INT64
+extFloat80_t f64_to_extF80( float64_t );
+float128_t f64_to_f128( float64_t );
+#endif
+void f64_to_extF80M( float64_t, extFloat80_t * );
+void f64_to_f128M( float64_t, float128_t * );
+float64_t f64_roundToInt( float64_t, uint_fast8_t, bool );
+float64_t f64_add( float64_t, float64_t );
+float64_t f64_sub( float64_t, float64_t );
+float64_t f64_max( float64_t, float64_t );
+float64_t f64_min( float64_t, float64_t );
+float64_t f64_mul( float64_t, float64_t );
+float64_t f64_mulAdd( float64_t, float64_t, float64_t );
+float64_t f64_div( float64_t, float64_t );
+float64_t f64_rem( float64_t, float64_t );
+float64_t f64_sqrt( float64_t );
+bool f64_eq( float64_t, float64_t );
+bool f64_le( float64_t, float64_t );
+bool f64_lt( float64_t, float64_t );
+bool f64_eq_signaling( float64_t, float64_t );
+bool f64_le_quiet( float64_t, float64_t );
+bool f64_lt_quiet( float64_t, float64_t );
+bool f64_isSignalingNaN( float64_t );
+uint_fast16_t f64_classify( float64_t );
+
+/*----------------------------------------------------------------------------
+| Rounding precision for 80-bit extended double-precision floating-point.
+| Valid values are 32, 64, and 80.
+*----------------------------------------------------------------------------*/
+extern THREAD_LOCAL uint_fast8_t extF80_roundingPrecision;
+
+/*----------------------------------------------------------------------------
+| 80-bit extended double-precision floating-point operations.
+*----------------------------------------------------------------------------*/
+#ifdef SOFTFLOAT_FAST_INT64
+uint_fast32_t extF80_to_ui32( extFloat80_t, uint_fast8_t, bool );
+uint_fast64_t extF80_to_ui64( extFloat80_t, uint_fast8_t, bool );
+int_fast32_t extF80_to_i32( extFloat80_t, uint_fast8_t, bool );
+int_fast64_t extF80_to_i64( extFloat80_t, uint_fast8_t, bool );
+uint_fast32_t extF80_to_ui32_r_minMag( extFloat80_t, bool );
+uint_fast64_t extF80_to_ui64_r_minMag( extFloat80_t, bool );
+int_fast32_t extF80_to_i32_r_minMag( extFloat80_t, bool );
+int_fast64_t extF80_to_i64_r_minMag( extFloat80_t, bool );
+float16_t extF80_to_f16( extFloat80_t );
+float32_t extF80_to_f32( extFloat80_t );
+float64_t extF80_to_f64( extFloat80_t );
+float128_t extF80_to_f128( extFloat80_t );
+extFloat80_t extF80_roundToInt( extFloat80_t, uint_fast8_t, bool );
+extFloat80_t extF80_add( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_sub( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_mul( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_div( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_rem( extFloat80_t, extFloat80_t );
+extFloat80_t extF80_sqrt( extFloat80_t );
+bool extF80_eq( extFloat80_t, extFloat80_t );
+bool extF80_le( extFloat80_t, extFloat80_t );
+bool extF80_lt( extFloat80_t, extFloat80_t );
+bool extF80_eq_signaling( extFloat80_t, extFloat80_t );
+bool extF80_le_quiet( extFloat80_t, extFloat80_t );
+bool extF80_lt_quiet( extFloat80_t, extFloat80_t );
+bool extF80_isSignalingNaN( extFloat80_t );
+#endif
+uint_fast32_t extF80M_to_ui32( const extFloat80_t *, uint_fast8_t, bool );
+uint_fast64_t extF80M_to_ui64( const extFloat80_t *, uint_fast8_t, bool );
+int_fast32_t extF80M_to_i32( const extFloat80_t *, uint_fast8_t, bool );
+int_fast64_t extF80M_to_i64( const extFloat80_t *, uint_fast8_t, bool );
+uint_fast32_t extF80M_to_ui32_r_minMag( const extFloat80_t *, bool );
+uint_fast64_t extF80M_to_ui64_r_minMag( const extFloat80_t *, bool );
+int_fast32_t extF80M_to_i32_r_minMag( const extFloat80_t *, bool );
+int_fast64_t extF80M_to_i64_r_minMag( const extFloat80_t *, bool );
+float16_t extF80M_to_f16( const extFloat80_t * );
+float32_t extF80M_to_f32( const extFloat80_t * );
+float64_t extF80M_to_f64( const extFloat80_t * );
+void extF80M_to_f128M( const extFloat80_t *, float128_t * );
+void
+ extF80M_roundToInt(
+     const extFloat80_t *, uint_fast8_t, bool, extFloat80_t * );
+void extF80M_add( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_sub( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_mul( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_div( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_rem( const extFloat80_t *, const extFloat80_t *, extFloat80_t * );
+void extF80M_sqrt( const extFloat80_t *, extFloat80_t * );
+bool extF80M_eq( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_le( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_lt( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_eq_signaling( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_le_quiet( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_lt_quiet( const extFloat80_t *, const extFloat80_t * );
+bool extF80M_isSignalingNaN( const extFloat80_t * );
+
+/*----------------------------------------------------------------------------
+| 128-bit (quadruple-precision) floating-point operations.
+*----------------------------------------------------------------------------*/
+#ifdef SOFTFLOAT_FAST_INT64
+uint_fast32_t f128_to_ui32( float128_t, uint_fast8_t, bool );
+uint_fast64_t f128_to_ui64( float128_t, uint_fast8_t, bool );
+int_fast32_t f128_to_i32( float128_t, uint_fast8_t, bool );
+int_fast64_t f128_to_i64( float128_t, uint_fast8_t, bool );
+uint_fast32_t f128_to_ui32_r_minMag( float128_t, bool );
+uint_fast64_t f128_to_ui64_r_minMag( float128_t, bool );
+int_fast32_t f128_to_i32_r_minMag( float128_t, bool );
+int_fast64_t f128_to_i64_r_minMag( float128_t, bool );
+float16_t f128_to_f16( float128_t );
+float32_t f128_to_f32( float128_t );
+float64_t f128_to_f64( float128_t );
+extFloat80_t f128_to_extF80( float128_t );
+float128_t f128_roundToInt( float128_t, uint_fast8_t, bool );
+float128_t f128_add( float128_t, float128_t );
+float128_t f128_sub( float128_t, float128_t );
+float128_t f128_mul( float128_t, float128_t );
+float128_t f128_mulAdd( float128_t, float128_t, float128_t );
+float128_t f128_div( float128_t, float128_t );
+float128_t f128_rem( float128_t, float128_t );
+float128_t f128_sqrt( float128_t );
+bool f128_eq( float128_t, float128_t );
+bool f128_le( float128_t, float128_t );
+bool f128_lt( float128_t, float128_t );
+bool f128_eq_signaling( float128_t, float128_t );
+bool f128_le_quiet( float128_t, float128_t );
+bool f128_lt_quiet( float128_t, float128_t );
+bool f128_isSignalingNaN( float128_t );
+uint_fast16_t f128_classify( float128_t );
+#endif
+uint_fast32_t f128M_to_ui32( const float128_t *, uint_fast8_t, bool );
+uint_fast64_t f128M_to_ui64( const float128_t *, uint_fast8_t, bool );
+int_fast32_t f128M_to_i32( const float128_t *, uint_fast8_t, bool );
+int_fast64_t f128M_to_i64( const float128_t *, uint_fast8_t, bool );
+uint_fast32_t f128M_to_ui32_r_minMag( const float128_t *, bool );
+uint_fast64_t f128M_to_ui64_r_minMag( const float128_t *, bool );
+int_fast32_t f128M_to_i32_r_minMag( const float128_t *, bool );
+int_fast64_t f128M_to_i64_r_minMag( const float128_t *, bool );
+float16_t f128M_to_f16( const float128_t * );
+float32_t f128M_to_f32( const float128_t * );
+float64_t f128M_to_f64( const float128_t * );
+void f128M_to_extF80M( const float128_t *, extFloat80_t * );
+void f128M_roundToInt( const float128_t *, uint_fast8_t, bool, float128_t * );
+void f128M_add( const float128_t *, const float128_t *, float128_t * );
+void f128M_sub( const float128_t *, const float128_t *, float128_t * );
+void f128M_mul( const float128_t *, const float128_t *, float128_t * );
+void
+ f128M_mulAdd(
+     const float128_t *, const float128_t *, const float128_t *, float128_t *
+ );
+void f128M_div( const float128_t *, const float128_t *, float128_t * );
+void f128M_rem( const float128_t *, const float128_t *, float128_t * );
+void f128M_sqrt( const float128_t *, float128_t * );
+bool f128M_eq( const float128_t *, const float128_t * );
+bool f128M_le( const float128_t *, const float128_t * );
+bool f128M_lt( const float128_t *, const float128_t * );
+bool f128M_eq_signaling( const float128_t *, const float128_t * );
+bool f128M_le_quiet( const float128_t *, const float128_t * );
+bool f128M_lt_quiet( const float128_t *, const float128_t * );
+bool f128M_isSignalingNaN( const float128_t * );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/softfloat_raiseFlags.c b/arch/riscv/kernel/soft_vector/softfloat/softfloat_raiseFlags.c
new file mode 100644
index 000000000000..f2c25adeeaff
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/softfloat_raiseFlags.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "platform.h"
+#include "softfloat.h"
+
+/*----------------------------------------------------------------------------
+| Raises the exceptions specified by `flags'.  Floating-point traps can be
+| defined here if desired.  It is currently not possible for such a trap
+| to substitute a result value.  If traps are not implemented, this routine
+| should be simply `softfloat_exceptionFlags |= flags;'.
+*----------------------------------------------------------------------------*/
+void softfloat_raiseFlags( uint_fast8_t flags )
+{
+
+    softfloat_exceptionFlags |= flags;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/softfloat_state.c b/arch/riscv/kernel/soft_vector/softfloat/softfloat_state.c
new file mode 100644
index 000000000000..d638a72258fa
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/softfloat_state.c
@@ -0,0 +1,52 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "specialize.h"
+#include "softfloat.h"
+
+#ifndef THREAD_LOCAL
+#define THREAD_LOCAL
+#endif
+
+THREAD_LOCAL uint_fast8_t softfloat_roundingMode = softfloat_round_near_even;
+THREAD_LOCAL uint_fast8_t softfloat_detectTininess = init_detectTininess;
+THREAD_LOCAL uint_fast8_t softfloat_exceptionFlags = 0;
+
+THREAD_LOCAL uint_fast8_t extF80_roundingPrecision = 80;
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/softfloat_types.h b/arch/riscv/kernel/soft_vector/softfloat/softfloat_types.h
new file mode 100644
index 000000000000..1f8c345255ec
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/softfloat_types.h
@@ -0,0 +1,81 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_types_h
+#define softfloat_types_h 1
+
+#include "stdint.h"
+
+/*----------------------------------------------------------------------------
+| Types used to pass 16-bit, 32-bit, 64-bit, and 128-bit floating-point
+| arguments and results to/from functions.  These types must be exactly
+| 16 bits, 32 bits, 64 bits, and 128 bits in size, respectively.  Where a
+| platform has "native" support for IEEE-Standard floating-point formats,
+| the types below may, if desired, be defined as aliases for the native types
+| (typically 'float' and 'double', and possibly 'long double').
+*----------------------------------------------------------------------------*/
+typedef struct { uint16_t v; } float16_t;
+typedef struct { uint32_t v; } float32_t;
+typedef struct { uint64_t v; } float64_t;
+typedef struct { uint64_t v[2]; } float128_t;
+
+/*----------------------------------------------------------------------------
+| The format of an 80-bit extended floating-point number in memory.  This
+| structure must contain a 16-bit field named 'signExp' and a 64-bit field
+| named 'signif'.
+*----------------------------------------------------------------------------*/
+#ifdef LITTLEENDIAN
+struct extFloat80M { uint64_t signif; uint16_t signExp; };
+#else
+struct extFloat80M { uint16_t signExp; uint64_t signif; };
+#endif
+
+/*----------------------------------------------------------------------------
+| The type used to pass 80-bit extended floating-point arguments and
+| results to/from functions.  This type must have size identical to
+| 'struct extFloat80M'.  Type 'extFloat80_t' can be defined as an alias for
+| 'struct extFloat80M'.  Alternatively, if a platform has "native" support
+| for IEEE-Standard 80-bit extended floating-point, it may be possible,
+| if desired, to define 'extFloat80_t' as an alias for the native type
+| (presumably either 'long double' or a nonstandard compiler-intrinsic type).
+| In that case, the 'signif' and 'signExp' fields of 'struct extFloat80M'
+| must align exactly with the locations in memory of the sign, exponent, and
+| significand of the native type.
+*----------------------------------------------------------------------------*/
+typedef struct extFloat80M extFloat80_t;
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/specialize.h b/arch/riscv/kernel/soft_vector/softfloat/specialize.h
new file mode 100644
index 000000000000..ff0975bebeb4
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/specialize.h
@@ -0,0 +1,429 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef specialize_h
+#define specialize_h 1
+
+#include "stdbool.h"
+#include "stdint.h"
+#include "primitiveTypes.h"
+#include "softfloat.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*----------------------------------------------------------------------------
+| Default value for `softfloat_detectTininess'.
+*----------------------------------------------------------------------------*/
+#define init_detectTininess softfloat_tininess_afterRounding
+
+/*----------------------------------------------------------------------------
+| The values to return on conversions to 32-bit integer formats that raise an
+| invalid exception.
+*----------------------------------------------------------------------------*/
+#define ui8_fromPosOverflow  0xFF
+#define ui8_fromNegOverflow  0
+#define ui8_fromNaN          0xFF
+#define i8_fromPosOverflow   0x7F
+#define i8_fromNegOverflow   (-0x7F - 1)
+#define i8_fromNaN           0x7F
+
+#define ui16_fromPosOverflow 0xFFFF
+#define ui16_fromNegOverflow 0
+#define ui16_fromNaN         0xFFFF
+#define i16_fromPosOverflow  0x7FFF
+#define i16_fromNegOverflow  (-0x7FFF - 1)
+#define i16_fromNaN          0x7FFF
+
+#define ui32_fromPosOverflow 0xFFFFFFFF
+#define ui32_fromNegOverflow 0
+#define ui32_fromNaN         0xFFFFFFFF
+#define i32_fromPosOverflow  0x7FFFFFFF
+#define i32_fromNegOverflow  (-0x7FFFFFFF - 1)
+#define i32_fromNaN          0x7FFFFFFF
+
+/*----------------------------------------------------------------------------
+| The values to return on conversions to 64-bit integer formats that raise an
+| invalid exception.
+*----------------------------------------------------------------------------*/
+#define ui64_fromPosOverflow UINT64_C( 0xFFFFFFFFFFFFFFFF )
+#define ui64_fromNegOverflow 0
+#define ui64_fromNaN         UINT64_C( 0xFFFFFFFFFFFFFFFF )
+#define i64_fromPosOverflow  UINT64_C( 0x7FFFFFFFFFFFFFFF )
+#define i64_fromNegOverflow  (-UINT64_C( 0x7FFFFFFFFFFFFFFF ) - 1)
+#define i64_fromNaN          UINT64_C( 0x7FFFFFFFFFFFFFFF )
+
+/*----------------------------------------------------------------------------
+| "Common NaN" structure, used to transfer NaN representations from one format
+| to another.
+*----------------------------------------------------------------------------*/
+struct commonNaN { char _unused; };
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 16-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF16UI 0x7E00
+
+/*----------------------------------------------------------------------------
+| Returns true when 16-bit unsigned integer `uiA' has the bit pattern of a
+| 16-bit floating-point signaling NaN.
+| Note:  This macro evaluates its argument more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF16UI( uiA ) ((((uiA) & 0x7E00) == 0x7C00) && ((uiA) & 0x01FF))
+
+/*----------------------------------------------------------------------------
+| Assuming `uiA' has the bit pattern of a 16-bit floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f16UIToCommonNaN( uiA, zPtr ) if ( ! ((uiA) & 0x0200) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 16-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#define softfloat_commonNaNToF16UI( aPtr ) ((uint_fast16_t) defaultNaNF16UI)
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 16-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast16_t
+ softfloat_propagateNaNF16UI( uint_fast16_t uiA, uint_fast16_t uiB );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 32-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF32UI 0x7FC00000
+
+/*----------------------------------------------------------------------------
+| Returns true when 32-bit unsigned integer `uiA' has the bit pattern of a
+| 32-bit floating-point signaling NaN.
+| Note:  This macro evaluates its argument more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF32UI( uiA ) ((((uiA) & 0x7FC00000) == 0x7F800000) && ((uiA) & 0x003FFFFF))
+
+/*----------------------------------------------------------------------------
+| Assuming `uiA' has the bit pattern of a 32-bit floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f32UIToCommonNaN( uiA, zPtr ) if ( ! ((uiA) & 0x00400000) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 32-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#define softfloat_commonNaNToF32UI( aPtr ) ((uint_fast32_t) defaultNaNF32UI)
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 32-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast32_t
+ softfloat_propagateNaNF32UI( uint_fast32_t uiA, uint_fast32_t uiB );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 64-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF64UI UINT64_C( 0x7FF8000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns true when 64-bit unsigned integer `uiA' has the bit pattern of a
+| 64-bit floating-point signaling NaN.
+| Note:  This macro evaluates its argument more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF64UI( uiA ) ((((uiA) & UINT64_C( 0x7FF8000000000000 )) == UINT64_C( 0x7FF0000000000000 )) && ((uiA) & UINT64_C( 0x0007FFFFFFFFFFFF )))
+
+/*----------------------------------------------------------------------------
+| Assuming `uiA' has the bit pattern of a 64-bit floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f64UIToCommonNaN( uiA, zPtr ) if ( ! ((uiA) & UINT64_C( 0x0008000000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 64-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#define softfloat_commonNaNToF64UI( aPtr ) ((uint_fast64_t) defaultNaNF64UI)
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 64-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast64_t
+ softfloat_propagateNaNF64UI( uint_fast64_t uiA, uint_fast64_t uiB );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 80-bit extended floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNExtF80UI64 0x7FFF
+#define defaultNaNExtF80UI0  UINT64_C( 0xC000000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns true when the 80-bit unsigned integer formed from concatenating
+| 16-bit `uiA64' and 64-bit `uiA0' has the bit pattern of an 80-bit extended
+| floating-point signaling NaN.
+| Note:  This macro evaluates its arguments more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNExtF80UI( uiA64, uiA0 ) ((((uiA64) & 0x7FFF) == 0x7FFF) && ! ((uiA0) & UINT64_C( 0x4000000000000000 )) && ((uiA0) & UINT64_C( 0x3FFFFFFFFFFFFFFF )))
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when `SOFTFLOAT_FAST_INT64' is
+| defined.
+*----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+| Assuming the unsigned integer formed from concatenating `uiA64' and `uiA0'
+| has the bit pattern of an 80-bit extended floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_extF80UIToCommonNaN( uiA64, uiA0, zPtr ) if ( ! ((uiA0) & UINT64_C( 0x4000000000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into an 80-bit extended
+| floating-point NaN, and returns the bit pattern of this value as an unsigned
+| integer.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToExtF80UI
+INLINE
+struct uint128 softfloat_commonNaNToExtF80UI( const struct commonNaN *aPtr )
+{
+    struct uint128 uiZ;
+    uiZ.v64 = defaultNaNExtF80UI64;
+    uiZ.v0  = defaultNaNExtF80UI0;
+    return uiZ;
+}
+#else
+struct uint128 softfloat_commonNaNToExtF80UI( const struct commonNaN *aPtr );
+#endif
+
+/*----------------------------------------------------------------------------
+| Interpreting the unsigned integer formed from concatenating `uiA64' and
+| `uiA0' as an 80-bit extended floating-point value, and likewise interpreting
+| the unsigned integer formed from concatenating `uiB64' and `uiB0' as another
+| 80-bit extended floating-point value, and assuming at least on of these
+| floating-point values is a NaN, returns the bit pattern of the combined NaN
+| result.  If either original floating-point value is a signaling NaN, the
+| invalid exception is raised.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_propagateNaNExtF80UI(
+     uint_fast16_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast16_t uiB64,
+     uint_fast64_t uiB0
+ );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 128-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF128UI64 UINT64_C( 0x7FFF800000000000 )
+#define defaultNaNF128UI0  UINT64_C( 0 )
+
+/*----------------------------------------------------------------------------
+| Returns true when the 128-bit unsigned integer formed from concatenating
+| 64-bit `uiA64' and 64-bit `uiA0' has the bit pattern of a 128-bit floating-
+| point signaling NaN.
+| Note:  This macro evaluates its arguments more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF128UI( uiA64, uiA0 ) ((((uiA64) & UINT64_C( 0x7FFF800000000000 )) == UINT64_C( 0x7FFF000000000000 )) && ((uiA0) || ((uiA64) & UINT64_C( 0x00007FFFFFFFFFFF ))))
+
+/*----------------------------------------------------------------------------
+| Assuming the unsigned integer formed from concatenating `uiA64' and `uiA0'
+| has the bit pattern of a 128-bit floating-point NaN, converts this NaN to
+| the common NaN form, and stores the resulting common NaN at the location
+| pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid exception
+| is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f128UIToCommonNaN( uiA64, uiA0, zPtr ) if ( ! ((uiA64) & UINT64_C( 0x0000800000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 128-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToF128UI
+INLINE
+struct uint128 softfloat_commonNaNToF128UI( const struct commonNaN *aPtr )
+{
+    struct uint128 uiZ;
+    uiZ.v64 = defaultNaNF128UI64;
+    uiZ.v0  = defaultNaNF128UI0;
+    return uiZ;
+}
+#else
+struct uint128 softfloat_commonNaNToF128UI( const struct commonNaN * );
+#endif
+
+/*----------------------------------------------------------------------------
+| Interpreting the unsigned integer formed from concatenating `uiA64' and
+| `uiA0' as a 128-bit floating-point value, and likewise interpreting the
+| unsigned integer formed from concatenating `uiB64' and `uiB0' as another
+| 128-bit floating-point value, and assuming at least on of these floating-
+| point values is a NaN, returns the bit pattern of the combined NaN result.
+| If either original floating-point value is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_propagateNaNF128UI(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0
+ );
+
+#else
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when `SOFTFLOAT_FAST_INT64' is not
+| defined.
+*----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+| Assuming the 80-bit extended floating-point value pointed to by `aSPtr' is
+| a NaN, converts this NaN to the common NaN form, and stores the resulting
+| common NaN at the location pointed to by `zPtr'.  If the NaN is a signaling
+| NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_extF80MToCommonNaN( aSPtr, zPtr ) if ( ! ((aSPtr)->signif & UINT64_C( 0x4000000000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into an 80-bit extended
+| floating-point NaN, and stores this NaN at the location pointed to by
+| `zSPtr'.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToExtF80M
+INLINE
+void
+ softfloat_commonNaNToExtF80M(
+     const struct commonNaN *aPtr, struct extFloat80M *zSPtr )
+{
+    zSPtr->signExp = defaultNaNExtF80UI64;
+    zSPtr->signif  = defaultNaNExtF80UI0;
+}
+#else
+void
+ softfloat_commonNaNToExtF80M(
+     const struct commonNaN *aPtr, struct extFloat80M *zSPtr );
+#endif
+
+/*----------------------------------------------------------------------------
+| Assuming at least one of the two 80-bit extended floating-point values
+| pointed to by `aSPtr' and `bSPtr' is a NaN, stores the combined NaN result
+| at the location pointed to by `zSPtr'.  If either original floating-point
+| value is a signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_propagateNaNExtF80M(
+     const struct extFloat80M *aSPtr,
+     const struct extFloat80M *bSPtr,
+     struct extFloat80M *zSPtr
+ );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 128-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF128UI96 0x7FFF8000
+#define defaultNaNF128UI64 0
+#define defaultNaNF128UI32 0
+#define defaultNaNF128UI0  0
+
+/*----------------------------------------------------------------------------
+| Assuming the 128-bit floating-point value pointed to by `aWPtr' is a NaN,
+| converts this NaN to the common NaN form, and stores the resulting common
+| NaN at the location pointed to by `zPtr'.  If the NaN is a signaling NaN,
+| the invalid exception is raised.  Argument `aWPtr' points to an array of
+| four 32-bit elements that concatenate in the platform's normal endian order
+| to form a 128-bit floating-point value.
+*----------------------------------------------------------------------------*/
+#define softfloat_f128MToCommonNaN( aWPtr, zPtr ) if ( ! ((aWPtr)[indexWordHi( 4 )] & UINT64_C( 0x0000800000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 128-bit floating-point
+| NaN, and stores this NaN at the location pointed to by `zWPtr'.  Argument
+| `zWPtr' points to an array of four 32-bit elements that concatenate in the
+| platform's normal endian order to form a 128-bit floating-point value.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToF128M
+INLINE
+void
+ softfloat_commonNaNToF128M( const struct commonNaN *aPtr, uint32_t *zWPtr )
+{
+    zWPtr[indexWord( 4, 3 )] = defaultNaNF128UI96;
+    zWPtr[indexWord( 4, 2 )] = defaultNaNF128UI64;
+    zWPtr[indexWord( 4, 1 )] = defaultNaNF128UI32;
+    zWPtr[indexWord( 4, 0 )] = defaultNaNF128UI0;
+}
+#else
+void
+ softfloat_commonNaNToF128M( const struct commonNaN *aPtr, uint32_t *zWPtr );
+#endif
+
+/*----------------------------------------------------------------------------
+| Assuming at least one of the two 128-bit floating-point values pointed to by
+| `aWPtr' and `bWPtr' is a NaN, stores the combined NaN result at the location
+| pointed to by `zWPtr'.  If either original floating-point value is a
+| signaling NaN, the invalid exception is raised.  Each of `aWPtr', `bWPtr',
+| and `zWPtr' points to an array of four 32-bit elements that concatenate in
+| the platform's normal endian order to form a 128-bit floating-point value.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_propagateNaNF128M(
+     const uint32_t *aWPtr, const uint32_t *bWPtr, uint32_t *zWPtr );
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/stdbool.h b/arch/riscv/kernel/soft_vector/softfloat/stdbool.h
new file mode 100644
index 000000000000..037d666dcb0e
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/stdbool.h
@@ -0,0 +1,7 @@
+
+
+#ifndef _STDBOOL_H
+#define _STDBOOL_H
+#include <linux/stddef.h>
+
+#endif	/* stdbool.h */
diff --git a/arch/riscv/kernel/soft_vector/softfloat/stdint.h b/arch/riscv/kernel/soft_vector/softfloat/stdint.h
new file mode 100644
index 000000000000..78d268faf191
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/stdint.h
@@ -0,0 +1,338 @@
+/* Copyright (C) 2008-2018 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/*
+ * ISO C Standard:  7.18  Integer types  <stdint.h>
+ */
+
+#ifndef _GCC_STDINT_H
+#define _GCC_STDINT_H
+#include <linux/types.h>
+
+/* 7.8.1.2 Minimum-width integer types */
+
+typedef __INT_LEAST8_TYPE__ int_least8_t;
+typedef __INT_LEAST16_TYPE__ int_least16_t;
+typedef __INT_LEAST32_TYPE__ int_least32_t;
+typedef __INT_LEAST64_TYPE__ int_least64_t;
+typedef __UINT_LEAST8_TYPE__ uint_least8_t;
+typedef __UINT_LEAST16_TYPE__ uint_least16_t;
+typedef __UINT_LEAST32_TYPE__ uint_least32_t;
+typedef __UINT_LEAST64_TYPE__ uint_least64_t;
+
+/* 7.8.1.3 Fastest minimum-width integer types */
+
+typedef __INT_FAST8_TYPE__ int_fast8_t;
+typedef __INT_FAST16_TYPE__ int_fast16_t;
+typedef __INT_FAST32_TYPE__ int_fast32_t;
+typedef __INT_FAST64_TYPE__ int_fast64_t;
+typedef __UINT_FAST8_TYPE__ uint_fast8_t;
+typedef __UINT_FAST16_TYPE__ uint_fast16_t;
+typedef __UINT_FAST32_TYPE__ uint_fast32_t;
+typedef __UINT_FAST64_TYPE__ uint_fast64_t;
+
+/* 7.8.1.4 Integer types capable of holding object pointers */
+
+#ifdef __INTPTR_TYPE__
+typedef __INTPTR_TYPE__ intptr_t;
+#endif
+#ifdef __UINTPTR_TYPE__
+typedef __UINTPTR_TYPE__ uintptr_t;
+#endif
+
+/* 7.8.1.5 Greatest-width integer types */
+
+typedef __INTMAX_TYPE__ intmax_t;
+typedef __UINTMAX_TYPE__ uintmax_t;
+
+#if (!defined __cplusplus || __cplusplus >= 201103L \
+     || defined __STDC_LIMIT_MACROS)
+
+/* 7.18.2 Limits of specified-width integer types */
+
+#ifdef __INT8_MAX__
+# undef INT8_MAX
+# define INT8_MAX __INT8_MAX__
+# undef INT8_MIN
+# define INT8_MIN (-INT8_MAX - 1)
+#endif
+#ifdef __UINT8_MAX__
+# undef UINT8_MAX
+# define UINT8_MAX __UINT8_MAX__
+#endif
+#ifdef __INT16_MAX__
+# undef INT16_MAX
+# define INT16_MAX __INT16_MAX__
+# undef INT16_MIN
+# define INT16_MIN (-INT16_MAX - 1)
+#endif
+#ifdef __UINT16_MAX__
+# undef UINT16_MAX
+# define UINT16_MAX __UINT16_MAX__
+#endif
+#ifdef __INT32_MAX__
+# undef INT32_MAX
+# define INT32_MAX __INT32_MAX__
+# undef INT32_MIN
+# define INT32_MIN (-INT32_MAX - 1)
+#endif
+#ifdef __UINT32_MAX__
+# undef UINT32_MAX
+# define UINT32_MAX __UINT32_MAX__
+#endif
+#ifdef __INT64_MAX__
+# undef INT64_MAX
+# define INT64_MAX __INT64_MAX__
+# undef INT64_MIN
+# define INT64_MIN (-INT64_MAX - 1)
+#endif
+#ifdef __UINT64_MAX__
+# undef UINT64_MAX
+# define UINT64_MAX __UINT64_MAX__
+#endif
+
+#undef INT_LEAST8_MAX
+#define INT_LEAST8_MAX __INT_LEAST8_MAX__
+#undef INT_LEAST8_MIN
+#define INT_LEAST8_MIN (-INT_LEAST8_MAX - 1)
+#undef UINT_LEAST8_MAX
+#define UINT_LEAST8_MAX __UINT_LEAST8_MAX__
+#undef INT_LEAST16_MAX
+#define INT_LEAST16_MAX __INT_LEAST16_MAX__
+#undef INT_LEAST16_MIN
+#define INT_LEAST16_MIN (-INT_LEAST16_MAX - 1)
+#undef UINT_LEAST16_MAX
+#define UINT_LEAST16_MAX __UINT_LEAST16_MAX__
+#undef INT_LEAST32_MAX
+#define INT_LEAST32_MAX __INT_LEAST32_MAX__
+#undef INT_LEAST32_MIN
+#define INT_LEAST32_MIN (-INT_LEAST32_MAX - 1)
+#undef UINT_LEAST32_MAX
+#define UINT_LEAST32_MAX __UINT_LEAST32_MAX__
+#undef INT_LEAST64_MAX
+#define INT_LEAST64_MAX __INT_LEAST64_MAX__
+#undef INT_LEAST64_MIN
+#define INT_LEAST64_MIN (-INT_LEAST64_MAX - 1)
+#undef UINT_LEAST64_MAX
+#define UINT_LEAST64_MAX __UINT_LEAST64_MAX__
+
+#undef INT_FAST8_MAX
+#define INT_FAST8_MAX __INT_FAST8_MAX__
+#undef INT_FAST8_MIN
+#define INT_FAST8_MIN (-INT_FAST8_MAX - 1)
+#undef UINT_FAST8_MAX
+#define UINT_FAST8_MAX __UINT_FAST8_MAX__
+#undef INT_FAST16_MAX
+#define INT_FAST16_MAX __INT_FAST16_MAX__
+#undef INT_FAST16_MIN
+#define INT_FAST16_MIN (-INT_FAST16_MAX - 1)
+#undef UINT_FAST16_MAX
+#define UINT_FAST16_MAX __UINT_FAST16_MAX__
+#undef INT_FAST32_MAX
+#define INT_FAST32_MAX __INT_FAST32_MAX__
+#undef INT_FAST32_MIN
+#define INT_FAST32_MIN (-INT_FAST32_MAX - 1)
+#undef UINT_FAST32_MAX
+#define UINT_FAST32_MAX __UINT_FAST32_MAX__
+#undef INT_FAST64_MAX
+#define INT_FAST64_MAX __INT_FAST64_MAX__
+#undef INT_FAST64_MIN
+#define INT_FAST64_MIN (-INT_FAST64_MAX - 1)
+#undef UINT_FAST64_MAX
+#define UINT_FAST64_MAX __UINT_FAST64_MAX__
+
+#ifdef __INTPTR_MAX__
+# undef INTPTR_MAX
+# define INTPTR_MAX __INTPTR_MAX__
+# undef INTPTR_MIN
+# define INTPTR_MIN (-INTPTR_MAX - 1)
+#endif
+#ifdef __UINTPTR_MAX__
+# undef UINTPTR_MAX
+# define UINTPTR_MAX __UINTPTR_MAX__
+#endif
+
+#undef INTMAX_MAX
+#define INTMAX_MAX __INTMAX_MAX__
+#undef INTMAX_MIN
+#define INTMAX_MIN (-INTMAX_MAX - 1)
+#undef UINTMAX_MAX
+#define UINTMAX_MAX __UINTMAX_MAX__
+
+/* 7.18.3 Limits of other integer types */
+
+#undef PTRDIFF_MAX
+#define PTRDIFF_MAX __PTRDIFF_MAX__
+#undef PTRDIFF_MIN
+#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)
+
+#undef SIG_ATOMIC_MAX
+#define SIG_ATOMIC_MAX __SIG_ATOMIC_MAX__
+#undef SIG_ATOMIC_MIN
+#define SIG_ATOMIC_MIN __SIG_ATOMIC_MIN__
+
+#undef SIZE_MAX
+#define SIZE_MAX __SIZE_MAX__
+
+#undef WCHAR_MAX
+#define WCHAR_MAX __WCHAR_MAX__
+#undef WCHAR_MIN
+#define WCHAR_MIN __WCHAR_MIN__
+
+#undef WINT_MAX
+#define WINT_MAX __WINT_MAX__
+#undef WINT_MIN
+#define WINT_MIN __WINT_MIN__
+
+#endif /* (!defined __cplusplus || __cplusplus >= 201103L
+	   || defined __STDC_LIMIT_MACROS)  */
+
+#if (!defined __cplusplus || __cplusplus >= 201103L \
+     || defined __STDC_CONSTANT_MACROS)
+
+#undef INT8_C
+#define INT8_C(c) __INT8_C(c)
+#undef INT16_C
+#define INT16_C(c) __INT16_C(c)
+#undef INT32_C
+#define INT32_C(c) __INT32_C(c)
+#undef INT64_C
+#define INT64_C(c) __INT64_C(c)
+#undef UINT8_C
+#define UINT8_C(c) __UINT8_C(c)
+#undef UINT16_C
+#define UINT16_C(c) __UINT16_C(c)
+#undef UINT32_C
+#define UINT32_C(c) __UINT32_C(c)
+#undef UINT64_C
+#define UINT64_C(c) __UINT64_C(c)
+#undef INTMAX_C
+#define INTMAX_C(c) __INTMAX_C(c)
+#undef UINTMAX_C
+#define UINTMAX_C(c) __UINTMAX_C(c)
+
+#endif /* (!defined __cplusplus || __cplusplus >= 201103L
+	   || defined __STDC_CONSTANT_MACROS) */
+
+#ifdef __STDC_WANT_IEC_60559_BFP_EXT__
+/* TS 18661-1 widths of integer types.  */
+
+#ifdef __INT8_TYPE__
+# undef INT8_WIDTH
+# define INT8_WIDTH 8
+#endif
+#ifdef __UINT8_TYPE__
+# undef UINT8_WIDTH
+# define UINT8_WIDTH 8
+#endif
+#ifdef __INT16_TYPE__
+# undef INT16_WIDTH
+# define INT16_WIDTH 16
+#endif
+#ifdef __UINT16_TYPE__
+# undef UINT16_WIDTH
+# define UINT16_WIDTH 16
+#endif
+#ifdef __INT32_TYPE__
+# undef INT32_WIDTH
+# define INT32_WIDTH 32
+#endif
+#ifdef __UINT32_TYPE__
+# undef UINT32_WIDTH
+# define UINT32_WIDTH 32
+#endif
+#ifdef __INT64_TYPE__
+# undef INT64_WIDTH
+# define INT64_WIDTH 64
+#endif
+#ifdef __UINT64_TYPE__
+# undef UINT64_WIDTH
+# define UINT64_WIDTH 64
+#endif
+
+#undef INT_LEAST8_WIDTH
+#define INT_LEAST8_WIDTH __INT_LEAST8_WIDTH__
+#undef UINT_LEAST8_WIDTH
+#define UINT_LEAST8_WIDTH __INT_LEAST8_WIDTH__
+#undef INT_LEAST16_WIDTH
+#define INT_LEAST16_WIDTH __INT_LEAST16_WIDTH__
+#undef UINT_LEAST16_WIDTH
+#define UINT_LEAST16_WIDTH __INT_LEAST16_WIDTH__
+#undef INT_LEAST32_WIDTH
+#define INT_LEAST32_WIDTH __INT_LEAST32_WIDTH__
+#undef UINT_LEAST32_WIDTH
+#define UINT_LEAST32_WIDTH __INT_LEAST32_WIDTH__
+#undef INT_LEAST64_WIDTH
+#define INT_LEAST64_WIDTH __INT_LEAST64_WIDTH__
+#undef UINT_LEAST64_WIDTH
+#define UINT_LEAST64_WIDTH __INT_LEAST64_WIDTH__
+
+#undef INT_FAST8_WIDTH
+#define INT_FAST8_WIDTH __INT_FAST8_WIDTH__
+#undef UINT_FAST8_WIDTH
+#define UINT_FAST8_WIDTH __INT_FAST8_WIDTH__
+#undef INT_FAST16_WIDTH
+#define INT_FAST16_WIDTH __INT_FAST16_WIDTH__
+#undef UINT_FAST16_WIDTH
+#define UINT_FAST16_WIDTH __INT_FAST16_WIDTH__
+#undef INT_FAST32_WIDTH
+#define INT_FAST32_WIDTH __INT_FAST32_WIDTH__
+#undef UINT_FAST32_WIDTH
+#define UINT_FAST32_WIDTH __INT_FAST32_WIDTH__
+#undef INT_FAST64_WIDTH
+#define INT_FAST64_WIDTH __INT_FAST64_WIDTH__
+#undef UINT_FAST64_WIDTH
+#define UINT_FAST64_WIDTH __INT_FAST64_WIDTH__
+
+#ifdef __INTPTR_TYPE__
+# undef INTPTR_WIDTH
+# define INTPTR_WIDTH __INTPTR_WIDTH__
+#endif
+#ifdef __UINTPTR_TYPE__
+# undef UINTPTR_WIDTH
+# define UINTPTR_WIDTH __INTPTR_WIDTH__
+#endif
+
+#undef INTMAX_WIDTH
+#define INTMAX_WIDTH __INTMAX_WIDTH__
+#undef UINTMAX_WIDTH
+#define UINTMAX_WIDTH __INTMAX_WIDTH__
+
+#undef PTRDIFF_WIDTH
+#define PTRDIFF_WIDTH __PTRDIFF_WIDTH__
+
+#undef SIG_ATOMIC_WIDTH
+#define SIG_ATOMIC_WIDTH __SIG_ATOMIC_WIDTH__
+
+#undef SIZE_WIDTH
+#define SIZE_WIDTH __SIZE_WIDTH__
+
+#undef WCHAR_WIDTH
+#define WCHAR_WIDTH __WCHAR_WIDTH__
+
+#undef WINT_WIDTH
+#define WINT_WIDTH __WINT_WIDTH__
+
+#endif
+
+#endif /* _GCC_STDINT_H */
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f128.c
new file mode 100644
index 000000000000..7cf21236b5fe
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f128.c
@@ -0,0 +1,60 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t ui32_to_f128( uint32_t a )
+{
+    uint_fast64_t uiZ64;
+    int_fast8_t shiftDist;
+    union ui128_f128 uZ;
+
+    uiZ64 = 0;
+    if ( a ) {
+        shiftDist = softfloat_countLeadingZeros32( a ) + 17;
+        uiZ64 =
+            packToF128UI64(
+                0, 0x402E - shiftDist, (uint_fast64_t) a<<shiftDist );
+    }
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = 0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f16.c
new file mode 100644
index 000000000000..5f29efb2e611
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f16.c
@@ -0,0 +1,65 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t ui32_to_f16( uint32_t a )
+{
+    int_fast8_t shiftDist;
+    union ui16_f16 u;
+    uint_fast16_t sig;
+
+    shiftDist = softfloat_countLeadingZeros32( a ) - 21;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF16UI(
+                    0, 0x18 - shiftDist, (uint_fast16_t) a<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 4;
+        sig =
+            (shiftDist < 0)
+                ? a>>(-shiftDist) | ((uint32_t) (a<<(shiftDist & 31)) != 0)
+                : (uint_fast16_t) a<<shiftDist;
+        return softfloat_roundPackToF16( 0, 0x1C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f32.c
new file mode 100644
index 000000000000..cc976456e014
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f32.c
@@ -0,0 +1,57 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t ui32_to_f32( uint32_t a )
+{
+    union ui32_f32 uZ;
+
+    if ( ! a ) {
+        uZ.ui = 0;
+        return uZ.f;
+    }
+    if ( a & 0x80000000 ) {
+        return softfloat_roundPackToF32( 0, 0x9D, a>>1 | (a & 1) );
+    } else {
+        return softfloat_normRoundPackToF32( 0, 0x9C, a );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f64.c
new file mode 100644
index 000000000000..c39d3d39651b
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui32_to_f64.c
@@ -0,0 +1,59 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t ui32_to_f64( uint32_t a )
+{
+    uint_fast64_t uiZ;
+    int_fast8_t shiftDist;
+    union ui64_f64 uZ;
+
+    if ( ! a ) {
+        uiZ = 0;
+    } else {
+        shiftDist = softfloat_countLeadingZeros32( a ) + 21;
+        uiZ =
+            packToF64UI( 0, 0x432 - shiftDist, (uint_fast64_t) a<<shiftDist );
+    }
+    uZ.ui = uiZ;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f128.c b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f128.c
new file mode 100644
index 000000000000..6e5bcdd3af0a
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f128.c
@@ -0,0 +1,68 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float128_t ui64_to_f128( uint64_t a )
+{
+    uint_fast64_t uiZ64, uiZ0;
+    int_fast8_t shiftDist;
+    struct uint128 zSig;
+    union ui128_f128 uZ;
+
+    if ( ! a ) {
+        uiZ64 = 0;
+        uiZ0  = 0;
+    } else {
+        shiftDist = softfloat_countLeadingZeros64( a ) + 49;
+        if ( 64 <= shiftDist ) {
+            zSig.v64 = a<<(shiftDist - 64);
+            zSig.v0  = 0;
+        } else {
+            zSig = softfloat_shortShiftLeft128( 0, a, shiftDist );
+        }
+        uiZ64 = packToF128UI64( 0, 0x406E - shiftDist, zSig.v64 );
+        uiZ0  = zSig.v0;
+    }
+    uZ.ui.v64 = uiZ64;
+    uZ.ui.v0  = uiZ0;
+    return uZ.f;
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f16.c b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f16.c
new file mode 100644
index 000000000000..b9faa59f1a10
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f16.c
@@ -0,0 +1,64 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float16_t ui64_to_f16( uint64_t a )
+{
+    int_fast8_t shiftDist;
+    union ui16_f16 u;
+    uint_fast16_t sig;
+
+    shiftDist = softfloat_countLeadingZeros64( a ) - 53;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF16UI(
+                    0, 0x18 - shiftDist, (uint_fast16_t) a<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 4;
+        sig =
+            (shiftDist < 0) ? softfloat_shortShiftRightJam64( a, -shiftDist )
+                : (uint_fast16_t) a<<shiftDist;
+        return softfloat_roundPackToF16( 0, 0x1C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f32.c b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f32.c
new file mode 100644
index 000000000000..4053ce2ff2f1
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f32.c
@@ -0,0 +1,64 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float32_t ui64_to_f32( uint64_t a )
+{
+    int_fast8_t shiftDist;
+    union ui32_f32 u;
+    uint_fast32_t sig;
+
+    shiftDist = softfloat_countLeadingZeros64( a ) - 40;
+    if ( 0 <= shiftDist ) {
+        u.ui =
+            a ? packToF32UI(
+                    0, 0x95 - shiftDist, (uint_fast32_t) a<<shiftDist )
+                : 0;
+        return u.f;
+    } else {
+        shiftDist += 7;
+        sig =
+            (shiftDist < 0) ? softfloat_shortShiftRightJam64( a, -shiftDist )
+                : (uint_fast32_t) a<<shiftDist;
+        return softfloat_roundPackToF32( 0, 0x9C - shiftDist, sig );
+    }
+
+}
+
diff --git a/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f64.c b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f64.c
new file mode 100644
index 000000000000..286fb9498dc2
--- /dev/null
+++ b/arch/riscv/kernel/soft_vector/softfloat/ui64_to_f64.c
@@ -0,0 +1,59 @@
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014 The Regents of the University of California.
+All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include "stdint.h"
+#include "platform.h"
+#include "internals.h"
+#include "softfloat.h"
+
+float64_t ui64_to_f64( uint64_t a )
+{
+    union ui64_f64 uZ;
+
+    if ( ! a ) {
+        uZ.ui = 0;
+        return uZ.f;
+    }
+    if ( a & UINT64_C( 0x8000000000000000 ) ) {
+        return
+            softfloat_roundPackToF64(
+                0, 0x43D, softfloat_shortShiftRightJam64( a, 1 ) );
+    } else {
+        return softfloat_normRoundPackToF64( 0, 0x43C, a );
+    }
+
+}
+
-- 
2.17.1

