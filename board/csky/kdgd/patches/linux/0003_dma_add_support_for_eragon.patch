diff --git a/drivers/dma/dw/core.c b/drivers/dma/dw/core.c
index c2c0a61..f09a7a0 100644
--- a/drivers/dma/dw/core.c
+++ b/drivers/dma/dw/core.c
@@ -49,11 +49,12 @@
 			_dwc->dws.p_master : _dwc->dws.m_master;	\
 		u8 _sms = (_dwc->direction == DMA_DEV_TO_MEM) ?		\
 			_dwc->dws.p_master : _dwc->dws.m_master;	\
+		u32 _llp = _dwc->nollp ?				\
+			0 : (DWC_CTLL_LLP_D_EN | DWC_CTLL_LLP_S_EN);	\
 								\
 		(DWC_CTLL_DST_MSIZE(_dmsize)			\
 		 | DWC_CTLL_SRC_MSIZE(_smsize)			\
-		 | DWC_CTLL_LLP_D_EN				\
-		 | DWC_CTLL_LLP_S_EN				\
+		 | _llp						\
 		 | DWC_CTLL_DMS(_dms)				\
 		 | DWC_CTLL_SMS(_sms));				\
 	})
@@ -757,6 +758,9 @@ static irqreturn_t dw_dma_interrupt(int irq, void *dev_id)
 	if (unlikely(!is_slave_direction(direction) || !sg_len))
 		return NULL;
 
+	if (dwc->nollp && (sg_len > 1))
+		return NULL;
+
 	dwc->direction = direction;
 
 	prev = first = NULL;
@@ -1138,6 +1142,13 @@ static int dwc_alloc_chan_resources(struct dma_chan *chan)
 		return -EINVAL;
 	}
 
+	if ((chan->private == NULL) &&
+	    (dwc->dws.m_master == 0) &&
+	    (dwc->dws.p_master == 0)) {
+		printk("master id: %d\n", dw->default_master);
+		dwc->dws.m_master = dwc->dws.p_master = dw->default_master;
+	}
+
 	/* Enable controller here if needed */
 	if (!dw->in_use)
 		dw_dma_on(dw);
@@ -1451,6 +1462,7 @@ int dw_dma_probe(struct dw_dma_chip *chip)
 
 	dw->regs = chip->regs;
 	chip->dw = dw;
+	dw->default_master = chip->default_master;
 
 	pm_runtime_get_sync(chip->dev);
 
@@ -1566,11 +1578,13 @@ int dw_dma_probe(struct dw_dma_chip *chip)
 			dwc->block_size =
 				(4 << ((pdata->block_size >> 4 * i) & 0xf)) - 1;
 			dwc->nollp =
-				(dwc_params >> DWC_PARAMS_MBLK_EN & 0x1) == 0;
+				(dwc_params >> DWC_PARAMS_HC_LLP & 0x1) == 1;
 		} else {
 			dwc->block_size = pdata->block_size;
 			dwc->nollp = pdata->is_nollp;
 		}
+
+		printk("nollp: %d\n", dwc->nollp);
 	}
 
 	/* Clear all interrupts on all channels. */
diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 5bda0eb..0307325 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -163,6 +163,13 @@ static int dw_probe(struct platform_device *pdev)
 	struct resource *mem;
 	const struct dw_dma_platform_data *pdata;
 	int err;
+	unsigned int default_master;
+
+	if (of_property_read_u32(pdev->dev.of_node,
+				 "master-id", &default_master)) {
+		printk("error: master id not defined in dts\n");
+		return -EINVAL;
+	}
 
 	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
 	if (!chip)
@@ -187,6 +194,7 @@ static int dw_probe(struct platform_device *pdev)
 
 	chip->dev = dev;
 	chip->pdata = pdata;
+	chip->default_master = default_master;
 
 	chip->clk = devm_clk_get(chip->dev, "hclk");
 	if (IS_ERR(chip->clk))
diff --git a/drivers/dma/dw/regs.h b/drivers/dma/dw/regs.h
index f65dd10..dab2e0f 100644
--- a/drivers/dma/dw/regs.h
+++ b/drivers/dma/dw/regs.h
@@ -126,6 +126,7 @@ struct dw_dma_regs {
 
 /* Bitfields in DWC_PARAMS */
 #define DWC_PARAMS_MBLK_EN	11		/* multi block transfer */
+#define DWC_PARAMS_HC_LLP	13		/* hardcode LLP register to 0 */
 
 /* bursts size */
 enum dw_dma_msize {
@@ -280,6 +281,7 @@ struct dw_dma {
 
 	/* platform data */
 	struct dw_dma_platform_data	*pdata;
+	unsigned int		default_master;
 };
 
 static inline struct dw_dma_regs __iomem *__dw_regs(struct dw_dma *dw)
diff --git a/include/linux/dma/dw.h b/include/linux/dma/dw.h
index ccfd0c3..99ba4ad 100644
--- a/include/linux/dma/dw.h
+++ b/include/linux/dma/dw.h
@@ -37,6 +37,7 @@ struct dw_dma_chip {
 	struct dw_dma	*dw;
 
 	const struct dw_dma_platform_data	*pdata;
+	unsigned int	default_master;
 };
 
 /* Export to the platform drivers */
